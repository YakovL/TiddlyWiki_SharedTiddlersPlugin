<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<script id="versionArea" type="text/javascript">
//<![CDATA[
var version = {title: "TiddlyWiki", major: 2, minor: 10, revision: 1, date: new Date("February 5, 2024"), extensions: {}};

//]]>
</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="copyright" content="
TiddlyWiki created by Jeremy Ruston, (jeremy [at] osmosoft [dot] com)

Copyright (c) Jeremy Ruston 2004-2007
Copyright (c) UnaMesa Association 2007-2012

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the UnaMesa Association nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

" />
<!--PRE-HEAD-START-->
<!--{{{-->
<link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml' />
<!--}}}-->

<!--PRE-HEAD-END-->
<title> SharedTiddlersPlugin - a tool for sharing tiddlers between TiddlyWikis </title>
<style id="styleArea" type="text/css">
#saveTest, #messageArea, #copyright, #storeArea, #shadowArea {
	display: none;
}
#javascriptWarning {
	text-align: center;
	padding: 1em;
	font-weight: bold;
	background-color: #dd1100;
	color: #fff;
}

</style>
<!--POST-HEAD-START-->

<!--POST-HEAD-END-->
</head>
<body onload="main();" onunload="if(window.unload) unload();">
<!--PRE-BODY-START-->

<!--PRE-BODY-END-->
<div id="copyright">
Welcome to TiddlyWiki created by Jeremy Ruston; Copyright &copy; 2004-2007 Jeremy Ruston, Copyright &copy; 2007-2011 UnaMesa Association
</div>
<noscript>
<div id="javascriptWarning">
This page requires JavaScript to function properly.<br /><br />If you are using Microsoft Internet Explorer you may need to click on the yellow bar above and select 'Allow Blocked Content'. You must then click 'Yes' on the following security warning.
</div>

</noscript>
<div id="saveTest"></div>
<div id="backstageCloak"></div>
<div id="backstageButton"></div>
<div id="backstageArea"><div id="backstageToolbar"></div></div>
<div id="backstage">
	<div id="backstagePanel"></div>
</div>
<div id="contentWrapper"></div>
<div id="contentStash"></div>
<div id="shadowArea">
<div title="ColorPalette">
<pre>Background: #fff
Foreground: #000
PrimaryPale: #8cf
PrimaryLight: #18f
PrimaryMid: #04b
PrimaryDark: #014
SecondaryPale: #ffc
SecondaryLight: #fe8
SecondaryMid: #db4
SecondaryDark: #841
TertiaryPale: #eee
TertiaryLight: #ccc
TertiaryMid: #999
TertiaryDark: #666
Error: #f88
</pre>
</div>
<div title="EditTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' macro='toolbar [[ToolbarCommands::EditToolbar]]'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit title'&gt;&lt;/div&gt;
&lt;div macro='annotations'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit text'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit tags'&gt;&lt;/div&gt;&lt;div class='editorFooter'&gt;&lt;span macro='message views.editor.tagPrompt'&gt;&lt;/span&gt;&lt;span macro='tagChooser excludeLists'&gt;&lt;/span&gt;&lt;/div&gt;
&lt;!--}}}--&gt;
</pre>
</div>
<div title="GettingStarted">
<pre>When getting started, you may want to:
* Set your username for signing your edits: &lt;&lt;option txtUserName&gt;&gt;
* Change the page [[title|SiteTitle]] (now &quot;&lt;&lt;tiddler SiteTitle&gt;&gt;&quot;) and [[subtitle|SiteSubtitle]] (now &quot;&lt;&lt;tiddler SiteSubtitle&gt;&gt;&quot;); they also set the browser tab title
* Create a tiddler where your content &quot;starts&quot;
** Use the button on the sidebar or [[link|My first tiddler]] it here, follow the link, edit, and click &quot;done&quot;
** It will be shown in the Timeline (usually on the right), but you may want to link it in the MainMenu (usually on the left)
** and/or make it open when the ~TiddlyWiki is opened by editing the list of [[DefaultTiddlers]] (separate links with spaces or linebreaks)
* Save your ~TiddlyWiki
** Although &quot;download saving&quot; works in any browser, it's not that convenient, so you'll probably want to use [[a dedicated saver|https://classic.tiddlywiki.com/#%5B%5BSetting up saving%5D%5D]]
</pre>
</div>
<div title="ImportTiddlers">
<pre>&lt;&lt;importTiddlers&gt;&gt;
</pre>
</div>
<div title="MarkupPreHead">
<pre>&lt;!--{{{--&gt;
&lt;link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml' /&gt;
&lt;!--}}}--&gt;
</pre>
</div>
<div title="OptionsPanel">
<pre>These [[InterfaceOptions]] for customising [[TiddlyWiki]] are saved in your browser

Your username for signing your edits. Write it as a [[WikiWord]] (eg [[JoeBloggs]])

&lt;&lt;option txtUserName&gt;&gt;
&lt;&lt;option chkSaveBackups&gt;&gt; [[SaveBackups]]
&lt;&lt;option chkAutoSave&gt;&gt; [[AutoSave]]
&lt;&lt;option chkRegExpSearch&gt;&gt; [[RegExpSearch]]
&lt;&lt;option chkCaseSensitiveSearch&gt;&gt; [[CaseSensitiveSearch]]
&lt;&lt;option chkAnimate&gt;&gt; [[EnableAnimations]]

----
Also see [[AdvancedOptions]]
</pre>
</div>
<div title="PageTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='header' role='banner'&gt;
  &lt;div class='headerShadow'&gt;
    &lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
    &lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class='headerForeground'&gt;
    &lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
    &lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id='mainMenu' role='navigation' refresh='content' tiddler='MainMenu'&gt;&lt;/div&gt;
&lt;div id='sidebar'&gt;
  &lt;div id='sidebarOptions' role='navigation' refresh='content' tiddler='SideBarOptions'&gt;&lt;/div&gt;
  &lt;div id='sidebarTabs' role='complementary' refresh='content' force='true' tiddler='SideBarTabs'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id='displayArea' role='main'&gt;
&lt;div id='messageArea'&gt;&lt;/div&gt;
&lt;div id='tiddlerDisplay'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!--}}}--&gt;
</pre>
</div>
<div title="StyleSheetColors">
<pre>/*{{{*/
body {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}

a {color:[[ColorPalette::PrimaryMid]];}
a:hover {background-color:[[ColorPalette::PrimaryMid]]; color:[[ColorPalette::Background]];}
a img {border:0;}

h1, h2, h3, h4, h5, h6 { color: [[ColorPalette::SecondaryDark]]; }
h1 {border-bottom:2px solid [[ColorPalette::TertiaryLight]];}
h2,h3 {border-bottom:1px solid [[ColorPalette::TertiaryLight]];}

.txtOptionInput {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}

.button {color:[[ColorPalette::PrimaryDark]]; border:1px solid [[ColorPalette::Background]];}
.button:hover {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::SecondaryLight]]; border-color:[[ColorPalette::SecondaryMid]];}
.button:active {color:[[ColorPalette::Background]]; background:[[ColorPalette::SecondaryMid]]; border:1px solid [[ColorPalette::SecondaryDark]];}

.header {
	background: -moz-linear-gradient(to bottom, [[ColorPalette::PrimaryLight]], [[ColorPalette::PrimaryMid]]);
	background: linear-gradient(to bottom, [[ColorPalette::PrimaryLight]], [[ColorPalette::PrimaryMid]]);
}
.header a:hover {background:transparent;}
.headerShadow {color:[[ColorPalette::Foreground]];}
.headerShadow a {font-weight:normal; color:[[ColorPalette::Foreground]];}
.headerForeground {color:[[ColorPalette::Background]];}
.headerForeground a {font-weight:normal; color:[[ColorPalette::PrimaryPale]];}

.tabSelected {
	color:[[ColorPalette::Foreground]];
	background:[[ColorPalette::Background]];
	border-left:1px solid [[ColorPalette::TertiaryLight]];
	border-top:1px solid [[ColorPalette::TertiaryLight]];
	border-right:1px solid [[ColorPalette::TertiaryLight]];
}
.tabUnselected {color:[[ColorPalette::Background]]; background:[[ColorPalette::TertiaryMid]];}
.tabContents {border:1px solid [[ColorPalette::TertiaryLight]];}
.tabContents .button {border:0;}

#sidebar {}
#sidebarOptions input {border:1px solid [[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel {background:[[ColorPalette::PrimaryPale]];}
#sidebarOptions .sliderPanel a {border:none;color:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:hover {color:[[ColorPalette::Background]]; background:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:active {color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::Background]];}

.wizard { background:[[ColorPalette::PrimaryPale]]; }
.wizard__title    { color:[[ColorPalette::PrimaryDark]]; border:none; }
.wizard__subtitle { color:[[ColorPalette::Foreground]]; border:none; }
.wizardStep { background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]]; }
.wizardStep.wizardStepDone {background:[[ColorPalette::TertiaryLight]];}
.wizardFooter {background:[[ColorPalette::PrimaryPale]];}
.wizardFooter .status {background:[[ColorPalette::PrimaryDark]]; color:[[ColorPalette::Background]];}
.wizardFooter .status a { color: [[ColorPalette::PrimaryPale]]; }
.wizard .button {
	color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryLight]]; border: 1px solid;
	border-color:[[ColorPalette::SecondaryDark]];
}
.wizard .button:hover {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Background]];}
.wizard .button:active {
	color:[[ColorPalette::Background]]; background:[[ColorPalette::Foreground]]; border: 1px solid;
	border-color:[[ColorPalette::PrimaryDark]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryDark]];
}

.wizard .notChanged {background:transparent;}
.wizard .changedLocally {background:#80ff80;}
.wizard .changedServer {background:#8080ff;}
.wizard .changedBoth {background:#ff8080;}
.wizard .notFound {background:#ffff80;}
.wizard .putToServer {background:#ff80ff;}
.wizard .gotFromServer {background:#80ffff;}

#messageArea { background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; box-shadow: 1px 2px 5px [[ColorPalette::TertiaryMid]]; }
.messageToolbar__button { color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::SecondaryPale]]; border:none; }
.messageToolbar__button_withIcon { background:inherit; }
.messageToolbar__button_withIcon:active { background:inherit; border:none; }
.tw-icon line { stroke: [[ColorPalette::TertiaryDark]]; }
.messageToolbar__button:hover .tw-icon line { stroke: [[ColorPalette::Foreground]]; }

.popup {
	background: [[ColorPalette::Background]];
	color: [[ColorPalette::TertiaryDark]];
	box-shadow: 1px 2px 5px [[ColorPalette::TertiaryMid]];
}
.popup li a, .popup li a:visited, .popup li a:hover, .popup li a:active {
	color:[[ColorPalette::Foreground]]; border: none;
}
.popup li a:hover { background:[[ColorPalette::SecondaryLight]]; }
.popup li a:active { background:[[ColorPalette::SecondaryPale]]; }
.popup li.disabled { color:[[ColorPalette::TertiaryMid]]; }
.popupHighlight {color:[[ColorPalette::Foreground]];}
.popup hr {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::PrimaryDark]]; border-bottom:1px;}
.listBreak div {border-bottom:1px solid [[ColorPalette::TertiaryDark]];}

.popupTiddler {background:[[ColorPalette::TertiaryPale]]; border:2px solid [[ColorPalette::TertiaryMid]];}

.tiddler .defaultCommand {font-weight:bold;}

.shadow .title {color:[[ColorPalette::TertiaryDark]];}

.title {color:[[ColorPalette::SecondaryDark]];}
.subtitle {color:[[ColorPalette::TertiaryDark]];}

.toolbar {color:[[ColorPalette::PrimaryMid]];}
.toolbar a {color:[[ColorPalette::TertiaryLight]];}
.selected .toolbar a {color:[[ColorPalette::TertiaryMid]];}
.selected .toolbar a:hover {color:[[ColorPalette::Foreground]];}

.tagging, .tagged { border: 2px solid [[ColorPalette::TertiaryPale]]; }
.selected .tagging, .selected .tagged { border: 2px solid [[ColorPalette::TertiaryLight]]; }
.tagging .listTitle, .tagged .listTitle {color:[[ColorPalette::PrimaryDark]];}
.tagging .button, .tagged .button { border:none; }

.footer {color:[[ColorPalette::TertiaryLight]];}
.selected .footer {color:[[ColorPalette::TertiaryMid]];}

.error, .errorButton {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Error]];}
.warning {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryPale]];}
.lowlight {background:[[ColorPalette::TertiaryLight]];}

.zoomer {background:none; color:[[ColorPalette::TertiaryMid]]; border:3px solid [[ColorPalette::TertiaryMid]];}

.imageLink, #displayArea .imageLink {background:transparent;}

.annotation { background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; }

.viewer .listTitle {list-style-type:none; margin-left:-2em;}
.viewer .button {border:1px solid [[ColorPalette::SecondaryMid]];}
.viewer blockquote {border-left:3px solid [[ColorPalette::TertiaryDark]];}

.viewer th, .viewer thead td, .twtable th, .twtable thead td { background: [[ColorPalette::SecondaryMid]]; color: [[ColorPalette::Background]]; }
.viewer td, .viewer tr, .twtable td, .twtable tr { border: 1px solid [[ColorPalette::TertiaryLight]]; }
.twtable caption { color: [[ColorPalette::TertiaryMid]]; }

.viewer pre {background:[[ColorPalette::SecondaryPale]];}
.viewer code {color:[[ColorPalette::SecondaryDark]];}
.viewer hr {border:0; border-top:dashed 1px [[ColorPalette::TertiaryDark]]; color:[[ColorPalette::TertiaryDark]];}

.highlight, .marked {background:[[ColorPalette::SecondaryLight]];}

.editor input {border:1px solid [[ColorPalette::PrimaryMid]]; background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
.editor textarea {border:1px solid [[ColorPalette::PrimaryMid]]; width:100%; background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
.editorFooter {color:[[ColorPalette::TertiaryMid]];}
.readOnly {background:[[ColorPalette::TertiaryPale]];}

#backstageArea {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::TertiaryMid]];}
#backstageArea a {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstageArea a:hover {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; }
#backstageArea a.backstageSelTab {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
#backstageButton a {background:none; color:[[ColorPalette::Background]]; border:none;}
#backstageButton a:hover {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstagePanel {background:[[ColorPalette::Background]]; border-color: [[ColorPalette::Background]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]];}
.backstagePanelFooter .button {border:none; color:[[ColorPalette::Background]];}
.backstagePanelFooter .button:hover {color:[[ColorPalette::Foreground]];}
#backstageCloak {background:[[ColorPalette::Foreground]]; opacity:0.6; filter:alpha(opacity=60);}
/*}}}*/
</pre>
</div>
<div title="StyleSheetLayout">
<pre>/*{{{*/
body { font-size:.75em; font-family:arial,helvetica,sans-serif; margin:0; padding:0; }

* html .tiddler {height:1%;}

h1,h2,h3,h4,h5,h6 {font-weight:bold; text-decoration:none;}
h1,h2,h3 {padding-bottom:1px; margin-top:1.2em;margin-bottom:0.3em;}
h4,h5,h6 {margin-top:1em;}
h1 {font-size:1.35em;}
h2 {font-size:1.25em;}
h3 {font-size:1.1em;}
h4 {font-size:1em;}
h5 {font-size:.9em;}

hr {height:1px;}

dt {font-weight:bold;}

ol {list-style-type:decimal;}
ol ol {list-style-type:lower-alpha;}
ol ol ol {list-style-type:lower-roman;}
ol ol ol ol {list-style-type:decimal;}
ol ol ol ol ol {list-style-type:lower-alpha;}
ol ol ol ol ol ol {list-style-type:lower-roman;}
ol ol ol ol ol ol ol {list-style-type:decimal;}

.txtOptionInput {width:11em; border-width: 1px; }

#contentWrapper .chkOptionInput {border:0;}

.indent {margin-left:3em;}
.outdent {margin-left:3em; text-indent:-3em;}
code.escaped {white-space:nowrap;}


a {text-decoration:none;}

.externalLink {text-decoration:underline;}

.tiddlyLinkExisting {font-weight:bold;}
.tiddlyLinkNonExisting {font-style:italic;}

/* the 'a' is required for IE, otherwise it renders the whole tiddler in bold */
a.tiddlyLinkNonExisting.shadow {font-weight:bold;}

#mainMenu .tiddlyLinkExisting,
#mainMenu .tiddlyLinkNonExisting,
#sidebarTabs .tiddlyLinkNonExisting {font-weight:normal; font-style:normal;}
#sidebarTabs .tiddlyLinkExisting {font-weight:bold; font-style:normal;}


.header {position:relative;}
.headerShadow {position:relative; padding:3em 0 1em 1em; left:-1px; top:-1px;}
.headerForeground {position:absolute; padding:3em 0 1em 1em; left:0; top:0;}

.siteTitle {font-size:3em;}
.siteSubtitle {font-size:1.2em;}

#mainMenu {position:absolute; left:0; width:10em; text-align:right; line-height:1.6em; padding:1.5em 0.5em 0.5em 0.5em; font-size:1.1em;}

#sidebar {position:absolute; right:3px; width:16em; font-size:.9em;}
#sidebarOptions {padding-top:0.3em;}
#sidebarOptions a {margin:0 0.2em; padding:0.2em 0.3em; display:block;}
#sidebarOptions input {margin:0.4em 0.5em;}
#sidebarOptions .sliderPanel {margin-left:1em; padding:0.5em; font-size:.85em;}
#sidebarOptions .sliderPanel a {font-weight:bold; display:inline; padding:0;}
#sidebarOptions .sliderPanel input {margin:0 0 0.3em 0;}
#sidebarTabs .tabContents {width:15em; overflow:hidden;}

.wizard { padding:0.1em 2em 0; }
.wizard__title    { font-size:2em; }
.wizard__subtitle { font-size:1.2em; }
.wizard__title, .wizard__subtitle { font-weight:bold; background:none; padding:0; margin:0.4em 0 0.2em; }
.wizardStep { padding:1em; }
.wizardFooter { padding: 0.8em 0; }
.wizardFooter .status { display: inline-block; line-height: 1.5; padding: 0.3em 1em; }
.wizardFooter .button { margin:0.5em 0 0; font-size:1.2em; padding:0.2em 0.5em; }

#messageArea { position:fixed; top:2em; right:0; margin:0.5em; padding:0.7em 1em; z-index:2000; }
.messageToolbar { text-align:right; padding:0.2em 0; }
.messageToolbar__button { text-decoration:underline; }
.messageToolbar__button_withIcon { display: inline-block; }
.tw-icon { height: 1em; width: 1em; } /* width for IE */
.tw-icon line { stroke-width: 1; stroke-linecap: round; }
.messageArea__text a { text-decoration:underline; }

.popup {position:absolute; z-index:300; font-size:.9em; padding:0.3em 0; list-style:none; margin:0;}
.popup .popupMessage, .popup li.disabled, .popup li a { padding: 0.3em 0.7em; }
.popup li a {display:block; font-weight:normal; cursor:pointer;}
.popup hr {display:block; height:1px; width:auto; padding:0; margin:0.2em 0;}
.listBreak {font-size:1px; line-height:1px;}
.listBreak div {margin:2px 0;}

.tiddlerPopupButton {padding:0.2em;}
.popupTiddler {position: absolute; z-index:300; padding:1em; margin:0;}

.tabset {padding:1em 0 0 0.5em;}
.tab {display: inline-block; white-space: nowrap; position: relative; bottom: -0.7px; margin: 0 0.25em 0 0; padding:0.2em;}
.tabContents {padding:0.5em;}
.tabContents ul, .tabContents ol {margin:0; padding:0;}
.txtMainTab .tabContents li {list-style:none;}
.tabContents li.listLink { margin-left:.75em;}

#contentWrapper {display:block;}
#splashScreen {display:none;}

#displayArea {margin:1em 17em 0 14em;}

.toolbar {text-align:right; font-size:.9em;}

.tiddler { padding: 1em; }

.title { font-size: 1.6em; font-weight: bold; }
.subtitle { font-size: 1.1em; }

.missing .viewer, .missing .title { font-style: italic; }
.missing .subtitle { display: none; }

.tiddler .button {padding:0.2em 0.4em;}

.tagging {margin:0.5em 0.5em 0.5em 0; float:left; display:none;}
.isTag .tagging {display:block;}
.tagged {margin:0.5em; float:right;}
.tagging, .tagged {font-size:0.9em; padding:0.25em;}
.tagging ul, .tagged ul {list-style:none; margin:0.25em; padding:0;}
.tagged li, .tagging li { margin: 0.3em 0; }
.tagClear {clear:both;}

.footer {font-size:.9em;}
.footer li {display:inline;}

.annotation { padding: 0.5em 0.8em; margin: 0.5em 1px; }

.viewer {line-height:1.4em; padding-top:0.5em;}
.viewer .button {margin:0 0.25em; padding:0 0.25em;}
.viewer blockquote {line-height:1.5em; padding-left:0.8em;margin-left:2.5em;}
.viewer ul, .viewer ol {margin-left:0.5em; padding-left:1.5em;}

.viewer table, table.twtable { border-collapse: collapse; margin: 0.8em 0; }
.viewer th, .viewer td, .viewer tr, .viewer caption, .twtable th, .twtable td, .twtable tr, .twtable caption { padding: 0.2em 0.4em; }
.twtable caption { font-size: 0.9em; }
table.listView { margin: 0.8em 1.0em; }
table.listView th, table.listView td, table.listView tr { text-align: left; }
.listView &gt; thead { position: sticky; top: 0; }

* html .viewer pre {width:99%; padding:0 0 1em 0;}
.viewer pre {padding:0.5em; overflow:auto;}
pre, code { font-family: monospace, monospace; font-size: 1em; }
.viewer pre, .viewer code { line-height: 1.4em; }

.editor {font-size:1.1em; line-height:1.4em;}
.editor input, .editor textarea {display:block; width:100%; box-sizing: border-box; font:inherit;}
.editorFooter {padding:0.25em 0; font-size:.9em;}
.editorFooter .button {padding-top:0; padding-bottom:0;}

.fieldsetFix {border:0; padding:0; margin:1px 0;}

.zoomer {font-size:1.1em; position:absolute; overflow:hidden;}
.zoomer div {padding:1em;}

* html #backstage {width:99%;}
* html #backstageArea {width:99%;}
#backstageArea {display:none; position:relative; overflow: hidden; z-index:150; padding:0.3em 0.5em;}
#backstageToolbar {position:relative;}
#backstageArea a {font-weight:bold; margin-left:0.5em; padding:0.3em 0.5em;}
#backstageButton {display:none; position:absolute; z-index:175; top:0; right:0;}
#backstageButton a {padding: 0.3em 0.5em; display: inline-block;}
#backstage {position:relative; width:100%; z-index:50;}
#backstagePanel { display:none; z-index:100; position:absolute; width:90%; margin:0 5%; }
.backstagePanelFooter {padding-top:0.2em; float:right;}
.backstagePanelFooter a {padding:0.2em 0.4em;}
#backstageCloak {display:none; z-index:20; position:absolute; width:100%; height:100px;}

.whenBackstage {display:none;}
.backstageVisible .whenBackstage {display:block;}
/*}}}*/
</pre>
</div>
<div title="StyleSheetLocale">
<pre>/***
StyleSheet for use when a translation requires any css style changes.
This StyleSheet can be used directly by languages such as Chinese, Japanese and Korean which need larger font sizes.
***/
/*{{{*/
body {font-size:0.8em;}
#sidebarOptions {font-size:1.05em;}
#sidebarOptions a {font-style:normal;}
#sidebarOptions .sliderPanel {font-size:0.95em;}
.subtitle {font-size:0.8em;}
.viewer table.listView {font-size:0.95em;}
/*}}}*/
</pre>
</div>
<div title="StyleSheetPrint">
<pre>/*{{{*/
@media print {
  #mainMenu, #sidebar, #messageArea, .toolbar, #backstageButton, #backstageArea { display: none !important; }
  #displayArea { margin: 1em 1em 0em; }
}
/*}}}*/
</pre>
</div>
<div title="ViewTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' role='navigation' macro='toolbar [[ToolbarCommands::ViewToolbar]]'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='subtitle'&gt;&lt;span macro='view modifier link'&gt;&lt;/span&gt;, &lt;span macro='view modified date'&gt;&lt;/span&gt; (&lt;span macro='message views.wikified.createdPrompt'&gt;&lt;/span&gt; &lt;span macro='view created date'&gt;&lt;/span&gt;)&lt;/div&gt;
&lt;div class='tagging' macro='tagging'&gt;&lt;/div&gt;
&lt;div class='tagged' macro='tags'&gt;&lt;/div&gt;
&lt;div class='viewer' macro='view text wikified'&gt;&lt;/div&gt;
&lt;div class='tagClear'&gt;&lt;/div&gt;
&lt;!--}}}--&gt;
</pre>
</div>

</div>
<!--POST-SHADOWAREA-->
<div id="storeArea">
<div title="AddTestShadowPlugin" creator="Titan" modifier="Yakov Litvin" created="201205251346" modified="201312101019" tags="code systemConfig [[SharedTiddlersPlugin tests+]]" changecount="6">
<pre>//{{{
config.shadowTiddlers['Test tiddler which is a shadow in the main document and not in the included one'] =
        'This is the the text of the shadow from the main document.';
//}}}</pre>
</div>
<div title="DefaultTiddlers" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261503" changecount="1">
<pre>[[Introduction to SharedTiddlersPlugin]]</pre>
</div>
<div title="Example of a tiddler with a name used in both main and included document" creator="Titan" modifier="Titan" created="201102231045" changecount="1">
<pre>Are there any problems with it? This one is from the main document.</pre>
</div>
<div title="ExtensionsExplorerPlugin" creator="Yakov Litvin" modifier="Yakov Litvin" created="202307200747" modified="202307200749" tags="systemConfig systemConfigDisable" changecount="2">
<pre>/***
|Description|checks and reports updates of installed extensions on startup, introduces a macro/backstage button to explore, install and update extensions|
|Version    |0.6.2|
|Author     |Yakov Litvin|
|Source     |https://github.com/YakovL/TiddlyWiki_ExtensionsExplorerPlugin/blob/master/ExtensionsExplorerPlugin.js|
|License    |[[MIT|https://github.com/YakovL/TiddlyWiki_YL_ExtensionsCollection/blob/master/Common%20License%20(MIT)]]|
!!!Installation &amp; configuration
Installation of the plugin is as usual: import the tiddler or copy and tag it with {{{systemConfig}}}; reload TW.

{{FpG{not yet (will be useful once collections are introduced): In some cases, you may want to customize AvailableExtensions: {{PoGc{when/why? how?}}} }}}

!!!What EEP does, how to use it
Once you install this plugin, on startup, it will try to check if installed extensions have any updates available and report if it finds any. An update of a particular extension is looked up by the url in the Source slice (see this tiddler for example). EEP will recognize an &quot;update&quot; if it finds the content by that url, and that content has a Version slice and the version is higher than the installed one (like: 0.4.2 is higher than 0.3.9; 0.0.1 is also higher than none).

It also adds &quot;explore extensions&quot; in the backstage (and the {{{&lt;&lt;extensionsExplorer&gt;&gt;}}} macro with the same interface) that shows some extensions available for installation and the list of installed plugins with buttons to check for updates.

Note: With some TW savers/servers, loading an extension may fail if its author hasn't enabled CORS on the server pointed by Source.

!!!For extension authors: how to prepare extensions and repositories
To make EEP find updates for your extensions, you have to
# put it somewhere in the internet:
** the server should have CORS enabled (~GitHub is fine);
** the extension should be in either form: &quot;plain text&quot; (.js or .txt file extension) or a tiddler in a TW (.html extension);
# ensure that the extension has a Source slice with a url that points to itself (i.e. where to look for the latest version):
** for plain text, one can use a direct url, like: https://raw.githubusercontent.com/YakovL/TiddlyWiki_ShowUnsavedPlugin/master/ShowUnsavedPlugin.js;
** for ~GitHub, one can also use the url of the UI page (i.e. navigate to it via ~GitHub UI and copy the address): https://github.com/YakovL/TiddlyWiki_ShowUnsavedPlugin/blob/master/ShowUnsavedPlugin.js;
** for a tiddler inside a TW, use a permalink, like: https://TiddlyTools.com/Classic/#NestedSlidersPlugin (note that the Source slice in this plugin is in fact outdated: http://www.TiddlyTools.com/#NestedSlidersPlugin – you should avoid that as this will break the updating flow);
** for a tiddler inside a TW on ~GitHub, use ~GitHub Pages (this is in fact how ~TiddlyTools is served, they just use a custom domain; an example of an &quot;ordinary&quot; url: https://yakovl.github.io/TiddlyWiki_ExtraFilters/#ExtraFiltersPlugin);
** for your dev flow, it may be useful to put the plugin to ~GitHub as a .js file and load it into the demo TW via [[TiddlerInFilePlugin|https://github.com/YakovL/TiddlyWiki_TiddlerInFilePlugin]]. An example of such setup can be found [[here|https://github.com/YakovL/TiddlyWiki_FromPlaceToPlacePlugin]].

To make your extension explorable, you can do one of the following:
* simply announce [[in the community|https://groups.google.com/group/TiddlyWikiClassic]] or elsewhere
* [single extension, PR to .. collection]
* [multiple extensions, own collection, PR to ..]
{{PoGc{collections: not yet}}}
***/
//{{{
// Returns the slice value if it is present or defaultText otherwise
//
Tiddler.prototype.getSlice = Tiddler.prototype.getSlice || function(sliceName, defaultText) {
	let re = TiddlyWiki.prototype.slicesRE, m
	re.lastIndex = 0
	while(m = re.exec(this.text)) {
		if(m[2]) {
			if(m[2] == sliceName) return m[3]
		} else {
			if(m[5] == sliceName) return m[6]
		}
	}
	return defaultText
}

const centralSourcesListName = &quot;AvailableExtensions&quot;

config.macros.extensionsExplorer = {
	lingo: {
// TODO: review order, looks somewhat chaotic
// TODO: probably add listeners of custom events, displayMessage there
		installButtonLabel: &quot;install&quot;,
		installButtonPrompt: &quot;get and install this extension&quot;,
		getFailedToLoadMsg: name =&gt; &quot;failed to load &quot; + name,
		getSucceededToLoadMsg: name =&gt; `loaded ${name}, about to import and install...`,
		noSourceUrlAvailable: &quot;no source url&quot;,
		getEvalSuccessMsg: name =&gt; `Successfully installed ${name} (reload is not necessary)`,
		getEvalFailMsg: (name, error) =&gt; `${name} failed with error: ${error}`,
		getImportSuccessMsg: (title, versionString, isUpdated) =&gt; isUpdated ?
			`Updated ${title}${versionString ? &quot; to &quot; + versionString : &quot;&quot;}` :
			`Imported ${title}${versionString ? &quot; v&quot; + versionString : &quot;&quot;}`,

		updateButtonCheckLabel: &quot;check&quot;,
		updateButtonCheckPrompt: &quot;check for updates&quot;,
		updateButtonUpdateLabel: &quot;update&quot;,
		updateButtonUpdatePrompt: &quot;install available update&quot;,
		getUpdateAvailableMsg: name =&gt; `update of ${name} is available!`,
		getUpdateAvailableAndVersionsMsg: (existingTiddler, newTiddler) =&gt; {
			const getVersionString = config.macros.extensionsExplorer.getVersionString
			return `update of ${existingTiddler.title} is available ` +
				&quot;(current version: &quot; + getVersionString(existingTiddler) +
				&quot;, available version: &quot; + getVersionString(newTiddler) + &quot;)&quot;
		},
		updateNotAvailable: &quot;update is not available&quot;,
		getUpdateConfirmMsg: (title, loadedVersion, presentVersion) =&gt; {
			const loadedVersionString = loadedVersion ? formatVersion(loadedVersion) : &quot;&quot;
			const presentVersionString = presentVersion ? formatVersion(presentVersion) : &quot;&quot;
			return `Would you like to update ${title}` +
				` (new version: ${loadedVersionString || &quot;unknown&quot;}, ` +
			 	`current version: ${presentVersionString || &quot;unknown&quot;})?`
		},

		centralSourcesListAnnotation: &quot;The JSON here describes extensions so that ExtensionsExplorerPlugin can install them&quot;
	},

	// helpers specific to tiddler format
	guessExtensionType: function(tiddler) {
		if(tiddler.tags.contains('systemConfig') ||
		   tiddler.getSlice('Type', '').toLowerCase() == 'plugin' ||
		   /Plugin$/.exec(tiddler.title)
		)
			return 'plugin'
	},
	// We use the server.host field a bit different than the core does (see importing):
	// we keep #TiddlerName part which won't hurt except for the plugin https://github.com/TiddlyWiki/tiddlywiki/blob/master/plugins/Sync.js (which we kinda substitute anyway),
	// we also don't set server.type and server.page.revision fields yet (unlike import); see also server.workspace, wikiformat fields.
	sourceUrlField: 'server.host',
	getSourceUrl: function(tiddler) {
		return tiddler.fields[this.sourceUrlField] || tiddler.getSlice('Source')
		//# try also the field set by import (figure the name by experiment)
	},
	setSourceUrl: function(tiddler, url) {
		//# simple implementation, not sure if setValue should be used instead
		tiddler.fields[this.sourceUrlField] = url
	},
	getDescription: tiddler =&gt; tiddler.getSlice('Description', ''),
	getVersionString: tiddler =&gt; tiddler.getSlice('Version', ''),
	getVersion: function(tiddler) {
		const versionString = this.getVersionString(tiddler)
		//# should use a helper from core instead
		const parts = /(\d+)\.(\d+)(?:\.(\d+))?/.exec(versionString)
		return parts ? {
			major: parseInt(parts[1]),
			minor: parseInt(parts[2]),
			revision: parseInt(parts[3] || '0')
		} : {}
	},

	// helpers to get stuff from external repos
	//# start from hardcoding 1 (.oO data sctructures needed
	//  for getAvailableExtensions and various user scenarios),
	//  then several (TW/JSON, local/remote)
	availableRepositories: [],
	getAvailableRepositories: function() {
		return this.availableRepositories
	},
	// fallback used when AvailableExtensions is empty
	defaultAvailableExtensions: [
		{
			url: 'https://github.com/YakovL/TiddlyWiki_ExtensionsExplorerPlugin/blob/master/ExtensionsCollection.txt',
			description: 'A central extensions collection for ExtensionsExplorerPlugin meant to both gather collections of existing extensions and help new authors make their work more explorable',
			type: 'collection'
		},
		{
			// js file @ github - worked /# simplify url to be inserted?
			name: 'ShowUnsavedPlugin',
			sourceType: 'txt',
			url: 'https://github.com/YakovL/TiddlyWiki_ShowUnsavedPlugin/blob/master/ShowUnsavedPlugin.js',
			description: 'highlights saving button (bold red by default) and the document title (adds a leading &quot;*&quot;) when there are unsaved changes',
			type: 'plugin',
			text: ''
		},
		{
			url: 'https://github.com/YakovL/TiddlyWiki_DarkModePlugin/blob/master/DarkModePlugin.js',
			description: 'This plugin introduces &quot;dark mode&quot; (changes styles) and switching it by the {{{darkMode}}} macro and operating system settings'
		},
		{
			// in TW @ remote (CORS-enabled) – worked
			name: 'FieldsEditorPlugin',
			sourceType: 'tw',
			url: 'https://yakovl.github.io/VisualTW2/VisualTW2.html#FieldsEditorPlugin',
			description: 'adds controls (create/edit/rename/delete) to the &quot;fields&quot; toolbar dropdown',
			type: 'plugin'
		},
		{
			// txt file @ remote without CORS – worked with _
			url: 'http://yakovlitvin.pro/TW/pre-releases/Spreadsheets.html#HandsontablePlugin',
			description: 'a test plugin on a site without CORS'
		},
		{
			url: 'https://github.com/tobibeer/TiddlyWikiPlugins/blob/master/plugins/ListFiltrPlugin.js'
		}
	],
	guessNameByUrl: function(extension) {
		if(!extension.url) return undefined
		const urlParts = extension.url.split('#')

		// site.domain/path/tw.html#TiddlerName  or  site.domain/path/#TiddlerName
		if(urlParts.length &gt; 1 &amp;&amp; /(\.html|\/)$/.exec(urlParts[0])) return urlParts[1]

		// &lt;url part&gt;/TiddlerName.txt or &lt;url part&gt;/TiddlerName.js
		const textPathMatch = /\/(\w+)\.(js|txt)$/.exec(urlParts[0])
		return textPathMatch ? textPathMatch[1] : undefined
	},
	collectionTag: 'systemExtensionsCollection',
	parseCollection: function(text) {
		/* expected format:

		&lt; additional info, like |Source|...| and other metadata &gt;
		//{{{
		&lt; extensions as JSON &gt;
		//}}}

		*/
		const match = /(\/\/{{{)\s+((?:.|\n)+)\s+(\/\/}}})$/.exec(text)
		if(match) try {
			return JSON.parse(match[2])
		} catch (e) {
			console.log(`problems with parsing ${centralSourcesListName}:`, e)
			return null
		}
	},
	// checks .centralSourcesListName, .defaultAvailableExtensions, collections
	getAvailableExtensions: function() {
		const listText = store.getTiddlerText(centralSourcesListName)
		const availableExtensions = this.parseCollection(listText)
			|| this.defaultAvailableExtensions

		const otherCollections = store.filterTiddlers(&quot;[tag[&quot; + this.collectionTag + &quot;]]&quot;)
		for(const collectionTiddler of otherCollections) {
			const extensions = this.parseCollection(collectionTiddler.text)
			// for now, just merge
			if(extensions) for(const extension of extensions) {
				availableExtensions.push(extension)
			}
		}

		//# move name normalizing to the reading method
		//  once we move the list of available extensions from hardcode
		for(const extension of availableExtensions) {
			extension.name = extension.name || this.guessNameByUrl(extension)
		}
		return availableExtensions
	},
	// map by url of extension tiddlers
	// (those loaded from txt may be detected by !tiddler.creator)
	availableUpdatesCache: {},
	cacheAvailableUpdate: function(sourceUrl, tiddler) {
		this.availableUpdatesCache[sourceUrl] = { tiddler: tiddler }
	},
	// github urls like https://github.com/tobibeer/TiddlyWikiPlugins/blob/master/plugins/FiltrPlugin.js
	// are urls of user interface; to get raw code, we use the official githubusercontent.com service
	// also, we change the old urls https://raw.github.com/tobibeer/TiddlyWikiPlugins/master/plugins/FiltrPlugin.js
	getUrlOfRawIfGithub: function(url) {
		const ghUrlRE = /^https:\/\/github\.com\/(\w+?)\/(\w+?)\/blob\/(.+)$/
		const oldGhRawUrlRE = /^https:\/\/raw.github.com\/(\w+?)\/(\w+?)\/(.+)$/
//# test
		const match = ghUrlRE.exec(url) || oldGhRawUrlRE.exec(url)
		if(match) return 'https://raw.githubusercontent.com/' + match[1] + // username
			'/' + match[2] + // repository name
			'/' + match[3] // path
		return url
	},
	twsCache: {}, // map of strings
	/*
	@param sourceType: 'tw' | string | fasly (default = 'txt') -
	 of the tiddler source (a TW or a text file)
	@param url: string - either url of the text file or url#TiddlerName
	 for a TW (TiddlerName defines the title of the tiddler to load)
	@param title: string - is assigned to the loaded tiddler
	@param callback: tiddler | null =&gt; void
	 support second param of callback? (error/xhr)
	*/
	loadExternalTiddler: function(sourceType, url, title, callback, useCache) {
		sourceType = sourceType || this.guessSourceType(url)
		//# if sourceType is uknown, we can load file and guess afterwards
		if(sourceType == 'tw') {
			const tiddlerName = url.split('#')[1] || title
			const requestUrl = url.split('#')[0]
			const cache = this.twsCache
			const onTwLoad = function(success, params, responseText, url, xhr) {
				//# pass more info? outside: warn?
				if(!success) return callback(null)
				if(!useCache) cache[requestUrl] = responseText

				const externalTW = new TiddlyWiki()
				const result = externalTW.importTiddlyWiki(responseText)
				//# pass more info? outside: warn?
				if(!result) return callback(null)

				const tiddler = externalTW.fetchTiddler(tiddlerName)
				tiddler.title = title
				callback(tiddler)

				// above is a simple &quot;from scratch&quot; implementation
				//# should we reuse existing core code? (see import)
				//  currently, this only loads and passes tiddler,
				//  actual import is done in _
				const context = {
					adaptor: {},
					complete: function() {}
				}
//				FileAdaptor.loadTiddlyWikiSuccess(context, );
				//# import, see ...
				//# tiddler.title = title;
				//# callback(tiddler);
			}
			if(useCache &amp;&amp; cache[requestUrl])
				onTwLoad(true, null, cache[requestUrl])
			else
				httpReq('GET', requestUrl, onTwLoad)
		} else {
			url = this.getUrlOfRawIfGithub(url)
			httpReq('GET', url, function(success, params, responseText, url, xhr) {
				//# pass more info? outside: warn?
				if(!success) return callback(null)

				const tiddler = new Tiddler(title)
				tiddler.text = responseText
				tiddler.generatedByTextOnly = true
				callback(tiddler)
			})
		}
	},

	getInstalledExtensions: function() {
		//# instead of returning tiddlers, create extension objects,
		//  those should have ~isInstalled, ~isEnabled, ~hasUpdates flags
		//  (and change refresh accordingly)
		return store.filterTiddlers(`[tag[systemConfig]] ` +
			`[tag[${this.collectionTag}]] [[${centralSourcesListName}]]`)
		//# implement others: themes, transclusions
	},
	// for each installed extension, check for update and reports (now: displays message)
	init: function() {
		//# set delegated handlers of install, update buttons
		const extensionTiddlers = this.getInstalledExtensions()
		if(!config.options.chkSkipExtensionsUpdatesCheckOnStartup)
			for(const eTiddler of extensionTiddlers) {
				const url = this.getSourceUrl(eTiddler)
				if(!url) continue
				this.checkForUpdate(url, eTiddler, result =&gt; {
		console.log(`checkForUpdate for ${url},`, eTiddler, 'result is:', result)
					if(result.tiddler &amp;&amp; !result.noUpdateMessage) {
						displayMessage(this.lingo.getUpdateAvailableAndVersionsMsg(eTiddler, result.tiddler))
					}
					//# either report each one at once,
					//   (see onUpdateCheckResponse)
					//  create summary and report,
					//   (use availableUpdates)
					//  create summary and just show &quot;+4&quot; or alike (better something diminishing),
					//  or even update (some of) ext-s silently
					//# start with creating summary
				})
			}

		const taskName = &quot;explorePlugins&quot;
		config.backstageTasks.push(taskName)
		config.tasks[taskName] = {
			text: &quot;explore extensions&quot;,
			tooltip: &quot;see if there's any updates or install new ones&quot;,
			content: '&lt;&lt;extensionsExplorer&gt;&gt;',
		}
	},
	handler: function(place, macroName, params, wikifier, paramString) {
		const tableHeaderMarkup = &quot;|name|description|version||h&quot;
		// name is supposted to be a link to the repo; 3d row – for &quot;install&quot; button
		wikify(tableHeaderMarkup, place)
		const table = place.lastChild

		jQuery(table).attr({ refresh: 'macro', macroName: macroName })
			.addClass('extensionsExplorer').append('&lt;tbody&gt;')

		this.refresh(table)
	},
	// grabs list of available extensions and shows with buttons to install;
	// for each installed plugin, shows a button to check update or &quot;no url&quot; message,
	refresh: function(table) {
		const $tbody = jQuery(table).find('tbody')
			.empty()

		// safe method (no wikification, innerHTML etc)
		const appendRow = function(cells) {
			const row = document.createElement('tr')
			const nameCell = createTiddlyElement(row, 'td')
			if(cells.url)
				createExternalLink(nameCell, cells.url, cells.name)
			else
				createTiddlyLink(nameCell, cells.name, true)

			createTiddlyElement(row, 'td', null, null, cells.description)

			createTiddlyElement(row, 'td', null, null, cells.version)

			const actionsCell = createTiddlyElement(row, 'td')
			for(const e of cells.actionElements)
				actionsCell.appendChild(e)

			$tbody.append(row)
		}

		//# when implemented: load list of available extensions (now hardcoded)

		const installedExtensionsTiddlers = this.getInstalledExtensions()
			.sort((e1, e2) =&gt; {
				const up1 = this.availableUpdatesCache[this.getSourceUrl(e1)]
				const up2 = this.availableUpdatesCache[this.getSourceUrl(e2)]
				return	up1 &amp;&amp; up2 ? 0 :
					up1 &amp;&amp; !up2 ? -1 :
					up2 &amp;&amp; !up1 ? +1 :
					!this.getSourceUrl(e1) ? +1 :
					!this.getSourceUrl(e2) ? -1 : 0
			})

		// show extensions available to install
		const availableExtensions = this.getAvailableExtensions()

		for(const extension of availableExtensions) {
			// skip installed
			if(installedExtensionsTiddlers.some(tid =&gt; tid.title === extension.name
				&amp;&amp; this.getSourceUrl(tid) === extension.url)) continue

			if(!extension.name &amp;&amp; extension.sourceType == 'tw')
				extension.name = extension.url.split('#')[1]

			appendRow({
				name:		extension.name,
				url:		extension.url,
				description:	extension.description,
				version:	extension.version,
				actionElements: [
					createTiddlyButton(null,
						this.lingo.installButtonLabel,
						this.lingo.installButtonPrompt,
						() =&gt; this.grabAndInstall(extension) )
				]
			})
		}
		//# add link to open, update on the place of install – if installed

		// show installed ones.. # or only those having updates?
		$tbody.append(jQuery(`&lt;tr&gt;&lt;td colspan=&quot;4&quot; style=&quot;text-align: center;&quot;&gt;Installed&lt;/td&gt;&lt;/tr&gt;`))
		for(const extensionTiddler of installedExtensionsTiddlers) {
			//# limit the width of the Description column/whole table
			const updateUrl = this.getSourceUrl(extensionTiddler)
				//# check also list of extensions to install
			const onUpdateCheckResponse = (result, isAlreadyReported) =&gt; {
				if(!result.tiddler) {
					displayMessage(this.lingo.updateNotAvailable)
					//# use result.error
					return
				}
				const versionOfLoaded = this.getVersion(result.tiddler)
				const versionOfPresent = this.getVersion(extensionTiddler)
				if(compareVersions(versionOfLoaded, versionOfPresent) &gt;= 0) {
					displayMessage(this.lingo.updateNotAvailable)
					//# use result.error
					return
				}
debugger;
				if(!isAlreadyReported) displayMessage(this.lingo.getUpdateAvailableMsg(extensionTiddler.title), updateUrl)

				//# later: better than confirm? option for silent?
				if(confirm(this.lingo.getUpdateConfirmMsg(
					extensionTiddler.title,
					versionOfLoaded, versionOfPresent))
				) {
					this.updateExtension(result.tiddler, updateUrl)
//					displayMessage(this.lingo.getImportedUpdateMsg(
//						result.tiddler.title,
//						this.getVersionString(result.tiddler)
//					))
				}
			}

			const checkUpdateButton = createTiddlyButton(null,
				this.lingo.updateButtonCheckLabel,
				this.lingo.updateButtonCheckPrompt,
				() =&gt; this.checkForUpdate(updateUrl, extensionTiddler,
					onUpdateCheckResponse))

			const cachedUpdate = this.availableUpdatesCache[updateUrl]
			const installUpdateButton = createTiddlyButton(null,
				this.lingo.updateButtonUpdateLabel,
				this.lingo.updateButtonUpdatePrompt,
				() =&gt; onUpdateCheckResponse(cachedUpdate, true))

			appendRow({
				name: extensionTiddler.title,
				description: this.getDescription(extensionTiddler),
				version: this.getVersionString(extensionTiddler),
				actionElements: [
					!updateUrl ? document.createTextNode(this.lingo.noSourceUrlAvailable) :
					cachedUpdate ? installUpdateButton :
					checkUpdateButton
				]
			})
		}
	},
	grabAndInstall: function(extension) {
//# initial goal: add displayMessage on .install success
//# move ~user interaction~ (displayMessage) into callbacks? merge with checkForUpdate?
		if(!extension) return
		if(extension.text) {
//# is this ever called? do we cache extension.text on checking update? what about version?
			const extensionTiddler = new Tiddler(extension.name)
			extensionTiddler.text = extension.text
			extensionTiddler.generatedByTextOnly = true
			//# share 3 ↑ lines as ~internalize helper (with loadExternalTiddler)
			this.install(extensionTiddler, extension.type, extension.url)
			return
		}
		this.loadExternalTiddler(
			extension.sourceType,
			extension.url,
			extension.name,
			tiddler =&gt; {
				if(!tiddler) {
					displayMessage(this.lingo.getFailedToLoadMsg(extension.name))
					return
				}
				displayMessage(this.lingo.getSucceededToLoadMsg(tiddler.title))
				this.install(tiddler, extension.type ||
					this.guessExtensionType(tiddler), extension.url)
			}
		)
	},
	// evaluate if a plugin, import
	//# simple unsafe version, no dependency handling, registering as installed,
	//  _install-only-once check_, result reporting, refreshing/notifying, ..
	install: function(extensionTiddler, extensionType, sourceUrl) {
		if(!extensionTiddler) return
		//# displayMessage _

		const { text, title } = extensionTiddler
		switch(extensionType) {
			case 'plugin':
				// enable at once
				try {
					eval(text)
					displayMessage(this.lingo.getEvalSuccessMsg(title))
				} catch(e) {
					displayMessage(this.lingo.getEvalFailMsg(title, e))
					//# don't import? only on confirm?
					//# if(!confirm(title + &quot; seem to produce errors, import anyway?&quot;)) return
				}
				// plugin-specific import preparation
				extensionTiddler.tags.pushUnique('systemConfig')
			break;

			case 'collection':
				extensionTiddler.tags.pushUnique(this.collectionTag)
			break;

			default:
			//# add _ tag for themes?
			//# displayMessage _
		}

		// actually import etc
		this.updateExtension(extensionTiddler, sourceUrl)
		//# what if exists already? (by the same name; other name)
	},
	updateExtension: function(extensionTiddler, sourceUrl) {
		// import
		var existingTiddler = store.fetchTiddler(extensionTiddler.title)
		if(extensionTiddler.generatedByTextOnly &amp;&amp; existingTiddler) {
			existingTiddler.text = extensionTiddler.text
			existingTiddler.modified = new Date()
			//# update also modifier? changecount?
		} else {
			store.addTiddler(extensionTiddler)
		}
		if(sourceUrl &amp;&amp; this.getSourceUrl(extensionTiddler) !== sourceUrl) {
			this.setSourceUrl(extensionTiddler, sourceUrl)
		}

		delete this.availableUpdatesCache[sourceUrl]
		store.setDirty(true)
		//# store url for updating if slice is not present?
		// make explorer and other stuff refresh
		store.notify(extensionTiddler.title, true)
		//# .oO reloading, hot reinstalling
		displayMessage(this.lingo.getImportSuccessMsg(extensionTiddler.title,
			this.getVersionString(extensionTiddler), !!existingTiddler))
	},
	guessSourceType: function(url) {
		if(/\.(txt|js)$/.exec(url.split('#')[0])) return 'txt'
		//# guess by url instead, fall back to 'txt'
		return 'tw'
	},
//# careful: extension keyword is overloaded (extension object/tiddler)
	/*
	  tries to load update for tiddler, if succeeds calls callback with
	   argument depending on whether it has newer version than the existing one
	  @param url: _
	  @param extensionTiddler: _
	  @param callback: is called [not always yet..] with argument
		{ tiddler: Tiddler | null, error?: string, noUpdateMessage?: string }
		if update is found and it has version newer than extensionTiddler,
		it is called with { tiddler: Tiddler }
	*/
	checkForUpdate: function(url, extensionTiddler, callback) {
		if(!url) return
		const title = extensionTiddler.title
		this.loadExternalTiddler(null, url, title, loadedTiddler =&gt; {
			if(!loadedTiddler) return callback({
				tiddler: null,
				error: &quot;&quot; //# specify
			})
			if(compareVersions(this.getVersion(loadedTiddler),
					   this.getVersion(extensionTiddler)
					  ) &gt;= 0)
			//# also get and compare modified dates?
			{
				//# what about undefined?
				console.log('loaded is not newer')
				callback({
					tiddler: loadedTiddler,
					// TODO: move to lingo; may be change to noUpdate
					noUpdateMessage: &quot;current version is up-to-date&quot;
				})
			} else {
				this.cacheAvailableUpdate(url, loadedTiddler)
				callback({ tiddler: loadedTiddler })
			}
		})
	}
}

config.shadowTiddlers[centralSourcesListName] = '//{{{\n' +
	JSON.stringify(config.macros.extensionsExplorer.defaultAvailableExtensions, null, 2) +
	'\n//}}}'
config.annotations[centralSourcesListName] =
	config.macros.extensionsExplorer.lingo.centralSourcesListAnnotation
//}}}</pre>
</div>
<div title="IncludeList" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261616" changecount="1">
<pre>&lt;&lt;include &quot;demo-included/example included.html&quot; filters:&quot;[tag[external]]&quot;&gt;&gt;
&lt;&lt;include &quot;demo-included/example included.html&quot; filters:&quot;[tag[tagged to be external]]&quot; substituteShadows&gt;&gt;
&lt;&lt;include &quot;demo-included/example included.html&quot; filters:&quot;[[A tiddler to be included with substituting]]&quot; substitute&gt;&gt;
&lt;&lt;include &quot;demo-included/example second level inclusion.html&quot; filters:&quot;[[A tiddler to be included with substituting]]&quot; substitute&gt;&gt;
&quot;&quot;&quot;&lt;&lt;include &quot;demo-included/example%20included.html&quot; filters:&quot;[tag[external]]&quot;&gt;&gt;&quot;&quot;&quot;</pre>
</div>
<div title="InnerExternalLinkPlugin" creator="Yakov Litvin" modifier="Yakov Litvin" created="201305291915" modified="201305291923" tags="systemConfig" changecount="2">
<pre>/***
|''Name''|InnerExternalLinkPlugin|
|''Version''|0.9.1|
|''Comment''|This plugin (by Yakov Litvin) is not fully released yet, but will definitely be released later|
***/
//{{{
config.extensions.InnerExternalLinkPlugin_orig_createExternalLink = createExternalLink;
createExternalLink = function(place,url,label) {

	var permaLinkRegExp = /([^#]+)#(?:(?:([^%\[]+))|(?:\[\[([^\]]+)\]\])|(?:%5B%5B([^\]]+)%5D%5D))/,
		// better to use decoding
	    match = permaLinkRegExp.exec(url),
	    siteUrlText = store.getTiddlerText(&quot;SiteUrl&quot;),
	    pageLocation = window.location,
	    urlRegExp = /^(([^:\/\?#]+):)?(\/\/([^\/\?#]*))?([^\?#]*)(\?([^#]*))?(#(.*))?/,
	    matched = false;

	if(match) {
		var bareUrl = match[1],
		    tiddlerName = match[4]? match[4] : (match[3]? match[3] : match[2]);
		tiddlerName = decodeURIComponent(tiddlerName);
	} else
		return config.extensions.InnerExternalLinkPlugin_orig_createExternalLink(place,url,label);

	if(siteUrlText == bareUrl)
		matched = true;

	match = urlRegExp.exec(pageLocation.toString());
	if(match[1]+match[3]+match[5] == bareUrl)
		matched = true;

	// may be additional normalizing (stripping the protocol etc, encoding/decoding) should be added

	if(matched)
		return createTiddlyLink(place, tiddlerName, label);
	else
		return config.extensions.InnerExternalLinkPlugin_orig_createExternalLink(place,url,label);
};
//}}}</pre>
</div>
<div title="Introduction to SharedTiddlersPlugin" creator="Yakov Litvin" modifier="Yakov Litvin" created="201304231931" modified="201811251453" changecount="9">
<pre>Sometimes having multiple ~TiddlyWikis causes some problems:
* some tiddlers with content may belong to more than one TW: for instance, if you created wikis about health and about cooking, or about coding and about ~TiddlyWiki, you may desire to have some tiddlers (like &quot;Food for muscles&quot; or &quot;Interface development&quot;) in both of them
* if you constantly improve interface of your ~TWs and add new extensions, you probably wonder if you can store them in one place and share them somehow among your wikis (see also this [[discussion|https://groups.google.com/forum/#!topic/tiddlywikiclassic/ehoYOoayHTU]])
* also, it may be useful to aggregate some tiddlers (for instance, the ones tagged &quot;~ToDo&quot;) in one place
and on the other hand it's not always convenient to have one big ~TiddlyWiki, because:
* it can grow too large to use it as a web-site and you will probably need to store in a separate wiki the only content which is meant to be published
* it can make workflow worse, because separate ~TWs can be opened in separate browser tabs and changed &quot;asynchronously&quot; (in contrast to two copies of one TW opened in separate tabs)
* different ~TWs can naturally appear on different devices/storages and are needed to be &quot;merged&quot; only from time to time
etc.

And that's where ~SharedTiddlersPlugin comes forward. It's idea is to load tiddlers from one ~TiddlyWiki in another when opening it. Create your &quot;Food for muscles&quot; or &quot;Interface development&quot; in one TW and include it into the the other -- you will see it in both (although, will be able to //edit// it only in one of them which can be no problem if things are put together in a right way). Or include ~PageTemplate from one &quot;central&quot; ~TiddlyWiki to each other and get your interface common for all ones. Or for aggregating &quot;~ToDo&quot;s, &quot;problem&quot;s, &quot;question&quot;s, whatever, include all your ~TWs in another one and use {{{&lt;&lt;tag&gt;&gt;}}} or {{{&lt;&lt;tagged&gt;&gt;}}} macro. Or use autoimport for central updating of extensions including those you develope yourself from their repositories (currently only local ones) -- or even launch included plugins without importing them.

Note: ~SharedTiddlersPlugin is a fork of the [[IncludePlugin|http://tiddlywiki.abego-software.de/#IncludePlugin]] and is backward compatible with v1.0.1, except now abego plugins should be made &quot;include-aware&quot; manually as any others, see the &quot;API changes and coding with ~SharedTiddlersPlugin&quot; section.

|tcenter|k
|[[The plugin|SharedTiddlersPlugin]]|[[Documentation|SharedTiddlersPluginInfo]]|[[Source code|SharedTiddlersPluginCode]]|[[License|Yakov Litvin Public Licence]]|</pre>
</div>
<div title="MainMenu" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261505" changecount="1">
<pre>[[Intro|Introduction to SharedTiddlersPlugin]]
[[The plugin|SharedTiddlersPlugin]]
[[Docs|SharedTiddlersPluginInfo]]
[[License|Yakov Litvin Public Licence]]
[[Source|SharedTiddlersPluginCode]]</pre>
</div>
<div title="MarkupPostBody" creator="Yakov Litvin" modifier="Yakov Litvin" created="201311231552" modified="201408210923" changecount="3">
<pre>&lt;!--{{{--&gt;
&lt;div style=&quot;text-align: center; margin: 2%&quot;&gt;&lt;!-- my wrapper --&gt;
&lt;!-- Yandex.Metrika informer --&gt;
&lt;a href=&quot;https://metrika.yandex.ru/stat/?id=22899424&amp;amp;from=informer&quot;
target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;//bs.yandex.ru/informer/22899424/3_1_FFFFFFFF_EFEFEFFF_0_pageviews&quot;
style=&quot;width:88px; height:31px; border:0;&quot; alt=&quot;Яндекс.Метрика&quot; title=&quot;Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)&quot; onclick=&quot;try{Ya.Metrika.informer({i:this,id:22899424,lang:'ru'});return false}catch(e){}&quot;/&gt;&lt;/a&gt;
&lt;!-- /Yandex.Metrika informer --&gt;

&lt;!-- Yandex.Metrika counter --&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter22899424 = new Ya.Metrika({id:22899424,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    trackHash:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName(&quot;script&quot;)[0],
        s = d.createElement(&quot;script&quot;),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = &quot;text/javascript&quot;;
    s.async = true;
    s.src = (d.location.protocol == &quot;https:&quot; ? &quot;https:&quot; : &quot;http:&quot;) + &quot;//mc.yandex.ru/metrika/watch.js&quot;;

    if (w.opera == &quot;[object Opera]&quot;) {
        d.addEventListener(&quot;DOMContentLoaded&quot;, f, false);
    } else { f(); }
})(document, window, &quot;yandex_metrika_callbacks&quot;);
&lt;/script&gt;
&lt;noscript&gt;&lt;div&gt;&lt;img src=&quot;//mc.yandex.ru/watch/22899424&quot; style=&quot;position:absolute; left:-9999px;&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;&lt;/noscript&gt;
&lt;!-- /Yandex.Metrika counter --&gt;
&lt;/div&gt;&lt;!-- end of my wrapper --&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="PureStore" creator="Yakov Litvin" modifier="Yakov Litvin" created="201305021302" modified="201305122124" changecount="8">
<pre>The ~TiddlyWiki ~PureStore is a file format compatible with some ~TiddlyWiki methods which allows, for instance, to use them with [[STP|SharedTiddlersPluginInfo]]. Here's an example of a minimalistic version of ~PureStore:
{{{
&lt;html&gt;
	&lt;body&gt;
		&lt;div id=&quot;storeArea&quot;&gt;
&lt;div tiddler=&quot;SampleTiddler1&quot; modifier=&quot;UdoBorkowski&quot; modified=&quot;200702021726&quot; created=&quot;200702021136&quot; tags=&quot;And Some Tags&quot;&gt;Content of SampleTiddler1&lt;/div&gt;
&lt;div tiddler=&quot;SampleTiddler2&quot; modifier=&quot;UdoBorkowski&quot; modified=&quot;200702021257&quot; created=&quot;200702021256&quot; tags=&quot;&quot;&gt;Content of SampleTiddler2&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
}}}
Here, tiddlers are stored like in an ordinary ~TiddlyWiki: a {{{div}}} element for each tiddler (only without those {{{pre}}} elements), inside the {{{div}}} element with the {{{id=&quot;storeArea&quot;}}}, inside {{{body}}} inside {{{html}}}. Nothing but content should be present in the
{{{
		&lt;div id=&quot;storeArea&quot;&gt;
...
		&lt;/div&gt;
}}}
part. Other things are optional: for instance, one can add {{{header}}} with stylings and other things, and other content can be put to the {{{body}}} element. Also, it {{DDn{may be}}} important to set a correct encoding. To illustrate these things, here's a copy of an example [[from abego-software.de|http://www.abego-software.de/references/TiddlyWikiPureStoreFormat.html]].
{{{
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
	&lt;head&gt;
		&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;
		&lt;title&gt;TiddlyWiki PureStore File&lt;/title&gt;
		&lt;style&gt;body {font-family: arial,helvetica,sans-serif;background-color:#FFCC66;} #storeArea {display: none};&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;TiddlyWiki PureStore File&lt;/h1&gt;
		&lt;em&gt;(This page contains hidden data. 
                        For details see &lt;a href=&quot;http://www.abego-software.de/references/TiddlyWikiPureStoreFormat.html&quot; target=&quot;_blank&quot;&gt;
                        TiddlyWiki PureStore Format&lt;/a&gt;.)&lt;/em&gt;
		&lt;div id=&quot;storeArea&quot;&gt;
&lt;div tiddler=&quot;SampleTiddler1&quot; modifier=&quot;UdoBorkowski&quot; modified=&quot;200702021726&quot; created=&quot;200702021136&quot; tags=&quot;And Some Tags&quot;&gt;Content of SampleTiddler1&lt;/div&gt;
&lt;div tiddler=&quot;SampleTiddler2&quot; modifier=&quot;UdoBorkowski&quot; modified=&quot;200702021257&quot; created=&quot;200702021256&quot; tags=&quot;&quot;&gt;Content of SampleTiddler2&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
}}}
There's a number of tools out there that can generate ~PureStore: for instance, at ~TiddlyTools you can find [[ExportTiddlersPlugin, SaveAsPlugin and SaveToClipboard transclusion/bookmarklet|http://tiddlytools.com/#ExportTiddlersPlugin%20SaveAsPlugin%20SaveToClipboard]].

Here's a [[test|PureStoreTest]] of including from a ~PureStore file.</pre>
</div>
<div title="PureStoreTest" creator="Yakov Litvin" modifier="Yakov Litvin" created="201305122021" modified="201305122025" changecount="3">
<pre>&lt;&lt;describeNode pureStoreTest &quot;./demo-included/pureStoreTest.html&quot;&gt;&gt;
[[SampleTiddler1]]@pureStoreTest</pre>
</div>
<div title="SharedTiddlersPlugin" creator="Yakov Litvin" modifier="Yakov Litvin" created="201212102148" modified="201905031830" tags="systemConfig" changecount="76">
<pre>/***
|Description |Allows to use tiddlers from other ~TiddlyWikis (with or without importing them)|
|Docs        |https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginInfo|
|Source      |https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPlugin|
|Author      |Yakov Litvin|
|~CoreVersion|2.7.0|
|Version     |2.5.1|
|Forked from |[[IncludePlugin|http://tiddlywiki.abego-software.de/#IncludePlugin]], by Udo Borkowski|
|Contact     |see [[docs|SharedTiddlersPluginInfo]]|
|Licence     |[[BSD-like open source license|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#%5B%5BYakov%20Litvin%20Public%20Licence%5D%5D]] |
|Copyright   |Yakov Litvin, 2013|
|&gt;| In this tiddler, the code is minified and hidden; the full code can be found [[here|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginCode]]. |
''Config:''
***/
//{{{
config.options.STP_hijackPrettyLink = true;
config.options.STP_hijackImageFormatter = true;
//}}}
// /%
config.filters.all=function(k,t){if(&quot;with included&quot;==t[3]){var l,n=this.reverseLookup();for(l=0;l&lt;n.length;l++)k.pushUnique(n[l])}else this.forEachTiddler(function(l,n){k.pushUnique(n)});return k};config.filters.includedFrom=function(k,t){var l=twWeb.getStoreUrlById(t[3]);if(!l)return[];for(var n=0;n&lt;k.length;n++)k[n].getIncludeURL()!=l&amp;&amp;k.splice(n--,1);return k};config.filters.external=function(k,t){for(var l=0;l&lt;k.length;l++)k[l].getIncludeURL()||k.splice(l--,1);return k};
config.filters.internal=function(k,t){for(var l=0;l&lt;k.length;l++)k[l].getIncludeURL()&amp;&amp;k.splice(l--,1);return k};
(function(){function k(){var a={};this.isUsed=function(c){return a[c]?!0:!1};this.setUsed=function(c){a[c]=1};this.getUsed=function(){return jQuery.extend(!0,{},a)};this.markUnused=function(c){for(var b in c)a[b]=void 0}}function t(a){if(!a)return null;a=&quot;object&quot;!=typeof a?{mode:a}:a;if(!a.mode&amp;&amp;!a.which&amp;&amp;void 0===a.ask)return null;void 0===a.which&amp;&amp;(a.which=a.mode in{1:!0,3:!0}?&quot;all&quot;:a.mode in{2:!0,4:!0}?&quot;newer&quot;:void 0!==a.ask?&quot;all&quot;:void 0);void 0===a.ask?a.ask=a.mode in{1:!0,2:!0}?!1:a.mode in{3:!0,
4:!0}?!0:void 0!==a.which?!1:void 0:&quot;false&quot;==a.ask&amp;&amp;(a.ask=!1);return a}window.abego||(window.abego={});if(abego.TiddlyWikiIncluder)return alert(&quot;Warning: abego.TiddlyWikiIncluder already exists, so probably two copies of SharedTiddlersPlugin and/or IncludePlugin are installed and activated. It is highly recommended to deactivate all but one copy. You can find those by searching 'abego.TiddlyWikiIncluder'.&quot;);window.sharedTiddlersAPI={};var l=function(a,c){displayMessage(a,c);console.log(a)},n=function(a,
c,b){return setTimeout(a,c)},D=function(a){return 0!=a.search(/^(?:((http(s)?)|(file)):)|(.:\\)|(\\\\)|(\/)/)},z=function(a,c){if(D(a)&amp;&amp;c){var b=c.lastIndexOf(&quot;#&quot;);b=-1&lt;b?c.substr(0,b):c;var e=b.lastIndexOf(&quot;/&quot;);b=(-1&lt;e?b.substr(0,e+1):&quot;&quot;)+a}else b=a;return b},E=function(a){0!=a.search(/^((http(s)?)|(file)):/)&amp;&amp;(a=D(a)?z(a,document.location.toString()):&quot;file://&quot;+a,a=a.replace(/\\/mg,&quot;/&quot;));return a},M=function(a,c,b){a=E(a);httpReq(&quot;GET&quot;,a,function(a,b,d,g,h){return a?c(d,g,b):c(void 0,g,b,&quot;Error loading %0&quot;.format([g]))},
b)},O=function(a,c,b,e){var f=function(d,c){e&amp;&amp;e(d,&quot;stp_loadTiddlyWikiStore&quot;,c,a,b)},d=function(d){f(&quot;Error when loading %0&quot;.format([a]),&quot;Failed&quot;);c(void 0,a,b,d);return d};f(&quot;Start loading %0&quot;.format([a]),&quot;Started&quot;);M(a,function(g,e,p,r){if(void 0===g)d(r);else{f(&quot;Processing %0&quot;.format([a]),&quot;Processing&quot;);try{var h=new TiddlyWiki,F=h.importTiddlyWiki(g)?null:&quot;Problem with importing TiddlyWiki, probable reason is: &quot;+&quot;The file '%0' does not appear to be a valid TiddlyWiki file&quot;.format([a]);F?d(F):(f(&quot;Loaded %0&quot;.format([a]),
&quot;Done&quot;),c(h,a,b))}catch(N){d(exceptionText(N))}}},b)},G=function(a){var c={tiddler:a,title:a.title,log:[]},b={},e=store.slicesRE,f=&quot;Name Description Version Requires CoreVersion Date Source Author License Browsers&quot;.split(&quot; &quot;);e.lastIndex=0;for(var d;d=e.exec(a.text);)d[2]?b[d[2]]=d[3]:b[d[5]]=d[6];for(a=0;a&lt;f.length;a++)b[f[a]]&amp;&amp;(c[f[a]]=b[f[a]]);return c},A,m={},B=[],u,C=[],w,q=new function(){var a={};this.add=function(c,b,e,f){if(e||f)void 0==a[c]&amp;&amp;(a[c]={urlsSubs:[],urlsSubsSh:[]}),e&amp;&amp;a[c].urlsSubs.pushUnique(b),
f&amp;&amp;a[c].urlsSubsSh.pushUnique(b)};this.getSubsUrl=function(c){c=a[c];return null==c||0==c.urlsSubs.length?null:c.urlsSubs[0]};this.getSubsShUrl=function(c){c=a[c];if(null==c||0==c.urlsSubsSh.length)return null;var b,e;for(b=0;b&lt;c.urlsSubs.length;b++)for(e=0;b&lt;c.urlsSubsSh.length;e++)if(c.urlsSubs[b]==c.urlsSubsSh[e])return c.urlsSubs[b];return c.urlsSubsSh[0]};this.containSubsUrl=function(c,b){var e=a[c];return null==e?!1:e.urlsSubs.contains(b)};this.containSubsShUrl=function(c,b){var e=a[c];return null==
e?!1:e.urlsSubsSh.contains(b)};this.removeByUrl=function(c){var b,e;for(b in a){var f=a[b];for(e=0;e&lt;f.urlsSubs.length;e++)f.urlsSubs[e]==c&amp;&amp;f.urlsSubs.splice(e--,1);for(e=0;e&lt;f.urlsSubsSh.length;e++)f.urlsSubsSh[e]==c&amp;&amp;f.urlsSubsSh.splice(e--,1)}}};conflicts=new function(){var a={},c={};this.init=function(){void 0==config.options.chkWarnOnSharedTiddlersConflicts&amp;&amp;(config.options.chkWarnOnSharedTiddlersConflicts=!0);void 0==config.options.chkAlertOnSharedTiddlersConflicts&amp;&amp;(config.options.chkAlertOnSharedTiddlersConflicts=
!1)};this.checkNew=function(b,e,f,d){var g=function(a,d){var b=a[d.title];if(b){var c=b[d.url];c?!c.subs&amp;&amp;d.substitute&amp;&amp;(b[d.url]={subs:d.substitute,warned:!1}):b[d.url]={subs:d.substitute,warned:!1}}else b=a[d.title]={},b[d.url]={subs:d.substitute,warned:!1}},h=x(function(a,d){if(d!=e)return a.fetchTiddler(b)})||window.sharedTiddlersAPI.orig_fetchTiddler(b);h&amp;&amp;(h=h.getIncludeURL(),a[b]||g(a,{title:b,url:h||&quot;main store&quot;,substitute:h?q.containSubsUrl(b,h):void 0}),g(a,{title:b,url:e,substitute:f}),
d&amp;&amp;(d=x(function(a,d){if(d!=e&amp;&amp;q.containSubsShUrl(b,d))return a.fetchTiddler(b)})||window.sharedTiddlersAPI.orig_fetchTiddler(b)))&amp;&amp;(d=d.getIncludeURL(),c[b]||g(c,{title:b,url:d||&quot;main store&quot;,substitute:d?q.containSubsShUrl(b,d):void 0}),g(c,{title:b,url:e,substitute:f}))};this.markNodeUnloaded=function(b){for(var e in a)a[e][b]&amp;&amp;delete a[e][b];for(e in c)c[e][b]&amp;&amp;delete c[e][b]};this.notify=function(){var b=config.options.chkWarnOnSharedTiddlersConflicts,e=config.options.chkAlertOnSharedTiddlersConflicts;
if(e||b){var f=function(d,a,b){var c=&quot;&quot;,g=function(d){c+=&quot;\n&quot;+d;a&amp;&amp;l(d)},e,h;for(e in d){var f=d[e];var p=!1;for(h in f)f[h].subs&amp;&amp;(p=!0);var k=0;for(h in f)f[h].subs==p&amp;&amp;k++;if(2&gt;k)break;k=!1;for(h in f)f[h].subs!=p||f[h].warned||(k=!0);if(k){g(&quot;* &quot;+e+&quot; in:&quot;);for(h in f)f[h].subs!=p||f[h].warned||(g(&quot;** &quot;+h),b&amp;&amp;(f[h].warned=!0));p&amp;&amp;g(&quot;  (with the subsitute priority)&quot;)}}return c},d=&quot;&quot;;f(a,!1,!1)&amp;&amp;(d+=&quot;New conflicts:&quot;,b&amp;&amp;l(d),d+=f(a,b,!0));f(c,!1,!1)&amp;&amp;(d&amp;&amp;(d+=&quot;\n&quot;),d+=&quot;New conflicts among tiddlers competing for substituting shadows:&quot;,
b&amp;&amp;l(&quot;New conflicts among tiddlers competing for substituting shadows:&quot;),d+=f(c,b,!0));e&amp;&amp;d&amp;&amp;alert(d)}}};conflicts.init();var P=function(){var a=B;B=[];if(a.length)for(var c=0;c&lt;C.length;c++)C[c](a)},y,H=function(){void 0!==u&amp;&amp;clearInterval(u);y=0;var a=function(){twWeb.sendProgress(&quot;&quot;,&quot;&quot;,&quot;Done&quot;)};u=setInterval(function(){y++;10&gt;=y||(clearInterval(u),u=void 0,twWeb.sendProgress(&quot;Refreshing...&quot;,&quot;&quot;,&quot;&quot;),refreshDisplay(),setTimeout(a,0))},1)},x=function(a){var c,b;for(b in m){var e=twWeb.getStore(b);
if(e&amp;&amp;(c=a(e,b)))return c}},I=function(){if(!window.store)return setTimeout(I,100);var a=store.fetchTiddler;window.sharedTiddlersAPI.orig_fetchTiddler=a;store.fetchTiddler=function(b){var c;if(c=q.getSubsUrl(b))return m[c].fetchTiddler(b);if(c=a.apply(this,arguments))return c;if(void 0!==config.shadowTiddlers[b]){if(c=q.getSubsShUrl(b))return m[c].fetchTiddler(b)}else if(b!=config.macros.newTiddler.title)return x(function(a,d){return a.fetchTiddler(b)})};var c=store.forEachTiddler;window.sharedTiddlersAPI.orig_forEachTiddler=
c;store.forEachTiddler=function(a){var b={},f=function(d,c){b[d]||q.getSubsUrl(d)&amp;&amp;q.getSubsUrl(d)!=c.getIncludeURL()||(b[d]=1,a.apply(this,arguments))};c.call(store,f);for(var d in config.shadowTiddlers)q.getSubsShUrl(d)||(b[d]=1);b[config.macros.newTiddler.title]=1;x(function(d,a){d.forEachTiddler(f)})};twWeb.getIncludedStoresUrls().length&amp;&amp;H()},J=function(){if(!window.store)return setTimeout(J,100);var a=store.fetchTiddler(&quot;IncludeList&quot;),c=a.text;c&amp;&amp;wikify(c,document.createElement(&quot;div&quot;),void 0,
a)};config.extensions.SharedTiddlersPlugin={getFunctionUsingForReallyEachTiddler:function(a){return a},useForReallyEachTiddler:function(a,c){return a[c]},addListener:function(a){C.push(a)}};config.extensions.SharedTiddlersPlugin.addListener(H);config.shadowTiddlers.AdvancedOptions+=&quot;\n~IncludePlugin settings:\n&lt;&lt;option chkUseInclude&gt;&gt; Include ~TiddlyWikis\n&lt;&lt;option chkAlertOnSharedTiddlersConflicts&gt;&gt; Alert on tiddler name conflicts\n&lt;&lt;option chkWarnOnSharedTiddlersConflicts&gt;&gt; Display messages and write log in the browser console on conflicts\nIncludeList | IncludeState | ImportIncluded | [[help|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginInfo]]\n^^(Reload this ~TiddlyWiki to make changes become effective)^^&quot;;
config.shadowTiddlers.IncludeState=&quot;&lt;&lt;includeState&gt;&gt;&quot;;config.shadowTiddlers.ImportIncluded='|               &lt;&lt;option txtStoreUrl&gt;&gt;|url of the document to import from |\n| &lt;&lt;option txtFilterTiddlersToImport&gt;&gt;|filter of tiddlers to import |\n|            &lt;&lt;option chkImportNewer&gt;&gt;|import only newer tiddlers (if those with same title already present) |\n|              &lt;&lt;option chkImportAsk&gt;&gt;|interactive import (ask whether to import each tiddler) |\n&lt;html&gt;&lt;a href=\'javascript:;\' onclick=\'\n\tvar storeUrl = config.options.txtStoreUrl,\n\t    params = {\n\t\tfilterLine: config.options.txtFilterTiddlersToImport,\n\t\timportOptions: {\n\t\t\twhich: config.options.chkImportNewer ? &quot;newer&quot; : &quot;all&quot;,\n\t\t\task: config.options.chkImportAsk\n\t\t},\n\t\tnoRefresh: true,\n\t};\n\tif(!storeUrl)\n\t\treturn displayMessage(&quot;please specify the url to import from&quot;);\n\tif(!params.filterLine)\n\t\treturn displayMessage(&quot;please specify the filter of tiddlers to import&quot;);\n\tif(!sharedTiddlersAPI.getStore(storeUrl))\n\t\tdisplayMessage(&quot;warning: no store was loaded from &quot;+storeUrl+&quot; previously, trying now&quot;);\n\ttwWeb.include(storeUrl,params);\n\'&gt;import (without saving)&lt;a/&gt;&lt;/html&gt;';
Tiddler.prototype.isIncluded=function(){return void 0!=this.includeURL};Tiddler.prototype.getIncludeURL=function(){return this.includeURL};Tiddler.prototype.setIncludeURL=function(a){this.includeURL=a};Tiddler.prototype.deleteIncludeURL=function(){delete this.includeURL};config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly||(config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly=Tiddler.prototype.isReadOnly,Tiddler.prototype.isReadOnly=function(){return config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly.apply(this,
arguments)||this.isIncluded()});config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave||(config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave=Tiddler.prototype.doNotSave,Tiddler.prototype.doNotSave=function(){return config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave.apply(this,arguments)||this.isIncluded()});twWeb=new function(){var a={},c={},b={},e,f=this;this.includeUsages=new k;this.setSelfNodeName=function(d){e=d};this.getSelfNodeName=function(){return e};this.setNodeDesc=
function(d,b){this.getNodeDesc(d)?this.addConflict(d,b):a[d]=b;this.callWaitingTasks(d)};this.getNodeDesc=function(d){return a[d]};this.deleteNodeDesc=function(d){a[d]=null};this.addNodeDesc=function(d,a){this.setNodeDesc(d,{url:a})};this.compareNodeDesc=function(d,a){return d.url==a.url?d:null};this.getNodeUrl=function(d){return(d=this.getNodeDesc(d))?d.url:null};this.getStoreUrlById=function(d){var a=f.checkNodeNotation(d);return a?f.getNodeUrl(a):d};this.setNodeNotation=function(a){return&quot;node: &quot;+
a};this.checkNodeNotation=function(a){return(a=/node: (.*)/.exec(a))?a[1]:null};this.addConflict=function(a,b){var d=this.compareNodeDesc(b,this.getNodeDesc(a));d?(this.deleteNodeDesc(a),this.setNodeDesc(a,d)):(c[a]?c[a].push(b):c[a]=[b],alert(&quot;Warning: more than one description of the &quot;+a+&quot; node was pushed. The earlier version is kept.&quot;))};this.setWaitingTask=function(a,c,e){c={action:c,self:e};b[a]?b[a].push(c):b[a]=[c];this.getNodeUrl(a)&amp;&amp;this.callWaitingTasks(a)};this.callWaitingTasks=function(a){var d=
b[a];if(d)for(var c=0;c&lt;d.length;c++)d[c].action.call(d[c].self);b[a]=null};this.setProgressFunction=function(a){w=a};this.sendProgress=function(a,b,c){w&amp;&amp;w.apply(this,arguments)};this.hasPendingIncludes=function(){var a;for(a in m){var b=this.getState(a);if(&quot;waiting&quot;==b||&quot;loading&quot;==b)return!0}return!1};this.onError=function(a,b){l(&quot;Error when including '%0':\n%1&quot;.format([a,b]))};this.importIncluded=function(a,b){var d,c={tiddler:null};if(a instanceof Tiddler){c.tiddler=window.sharedTiddlersAPI.orig_fetchTiddler(a.title);
var e=jQuery.extend(!0,new Tiddler,a)}else return c.status=-1,c.errorText=&quot;not a Tiddler instance&quot;,c;var f=e.getIncludeURL();null===b&amp;&amp;(b={which:&quot;all&quot;,ask:!1});if(&quot;newer&quot;==b.which&amp;&amp;(d=window.sharedTiddlersAPI.orig_fetchTiddler(e.title))&amp;&amp;d.modified&gt;=e.modified)return c;if(&quot;newerVersion&quot;==b.which&amp;&amp;(d=window.sharedTiddlersAPI.orig_fetchTiddler(e.title))){var g=e.getSlice(&quot;Version&quot;),k=d.getSlice(&quot;Version&quot;);if(g&amp;&amp;k){if(0&gt;=compareVersions(g,k))return c}else if(!confirm(&quot;%0 from %1 of %2 is available, import to substitute current one (%3)?&quot;.format(e.title,
f,g?&quot;unknown version&quot;:&quot;version&quot;+g,k?&quot;unknown version&quot;:&quot;version&quot;+k)))return c}if(b.ask&amp;&amp;(d=&quot;newer&quot;==b.which?&quot;Up-to-date &quot;+e.title+&quot; from &quot;+f+&quot; is availabe, import?&quot;:&quot;newerVersion&quot;==b.which?&quot;%0 from %1 of %2 is available, import to substitute current one (%3)?&quot;.format(e.title,f,&quot;version &quot;+g,&quot;version &quot;+k):e.title+&quot; from &quot;+f+&quot; is availabe, import?&quot;,!confirm(d)))return c;if(b.mode&amp;&amp;!(b.mode in{1:!0,2:!0,3:!0,4:!0}))return c.status=-1,c.errorText=&quot;unknown import mode&quot;,c;f&amp;&amp;e.deleteIncludeURL();store.addTiddler(e);
store.setDirty(!0);c.status=0;c.tiddler=e;c.from=f;return c};this.importAndLog=function(a,c){var b=t(c);b=twWeb.importIncluded(a,b);var d=a.title;switch(b.status){case 0:console.log(&quot;imported: &quot;+d+&quot; from &quot;+b.from);break;case -1:console.log(&quot;error importing &quot;+d+&quot;: &quot;+b.errorText)}return b};this.include=function(a,b){void 0===A&amp;&amp;(A=void 0===config.options.chkUseInclude||config.options.chkUseInclude);if(A){var c=this,d=function(a){var d=function(b,d,f,g){void 0===b?(m[a]=g,c.onError(a,g)):(m[a]=b,m[a].orig_store=
new TiddlyWiki,m[a].forEachTiddler(function(b,c){c.setIncludeURL(a);m[a].orig_store.addTiddler(c)}),m[a].clear(),e())},e=function(){var c=b.substitute,d=b.substituteShadows,f=b.importOptions;if(null===twWeb.getStore(a))return setTimeout(e,100);var g,h=m[a].orig_store.filterTiddlers(b.filterLine);for(g=0;g&lt;h.length;g++){var k=jQuery.extend(!0,new Tiddler,h[g]);if(m[a].orig_store.fetchTiddler(k.title)){f?twWeb.importAndLog(k,f):(conflicts.checkNew(k.title,a,c,d),m[a].addTiddler(k));if(b.evalTiddlers){var r=
k,p=G(r).Name||r.title;b:{for(var l=0;l&lt;installedPlugins.length;l++)if(installedPlugins[l].title==p||installedPlugins[l].Name==p){p=!0;break b}p=!1}if(!p){p=G(r);r.getIncludeURL()&amp;&amp;p.log.push(&quot;Included via SharedTiddlersPlugin from &quot;+r.getIncludeURL());p.executed=!0;l=new Date;try{window.eval(r.text)}catch(K){p.log.push(config.messages.pluginError.format([exceptionText(K)])),p.error=!0,console.log(&quot;error evaluating &quot;+r.title,K),story.displayTiddler(null,&quot;PluginManager&quot;),displayMessage(config.messages.customConfigError)}p.startupTime=
String(new Date-l)+&quot;ms&quot;;installedPlugins.push(p)}}b.wikifyTiddlers&amp;&amp;wikify(k.text,document.createElement(&quot;div&quot;),void 0,k)}}if(!f&amp;&amp;(c||d))for(g=0;g&lt;h.length;g++)q.add(h[g].title,a,c,d);conflicts.notify();store.slices={};b.noRefresh||(refreshAll(),story.refreshAllTiddlers());B.push(a);setTimeout(P,void 0)},f=function(){m[a]=&quot;loading&quot;;O(a,d,null,w)};m[a]?e():(m[a]=&quot;waiting&quot;,b.delayMilliSeconds?setTimeout(f,b.delayMilliSeconds):f())},e=this.checkNodeNotation(a);e?e!=this.getSelfNodeName()&amp;&amp;this.setWaitingTask(e,
function(){var a=this.getNodeUrl(e);d(a)},this):d(a)}};this.getIncludedStoresUrls=function(){var a=[],b;for(b in m)a.push(b);return a};this.getStore=function(a){a=f.getStoreUrlById(a);return a?(a=m[a])&amp;&amp;a instanceof TiddlyWiki?a:null:null};this.getState=function(a){var b=f.getStoreUrlById(a);return b?(a=m[b])?&quot;string&quot;==typeof a?a:null:&quot;No include specified for %0&quot;.format([b]):&quot;the node &quot;+f.checkNodeNotation(a)+&quot; is not described yet, the address is unknown&quot;};this.reload=function(a){var b,c=a.urlOrNodeParam;
if(c)for(b=0;b&lt;c.length;b++){var d=this.checkNodeNotation(c[b]);c[b]=d?this.getNodeUrl(d):c[b];c[b]||c.splice(b--,1)}if(void 0===a[&quot;import&quot;]||null===a[&quot;import&quot;])a[&quot;import&quot;]=!0;if(void 0===a.wikify||null===a.wikify)a.wikify=!0;var e,f=this.includeUsages.getUsed();for(e in f){b=e.substring(10,e.length-2);var k=b.readMacroParams();var l=b.parseParams(&quot;url&quot;,null,!0,!1,!0);var n=l[0].url[0];n=(d=this.checkNodeNotation(n))?this.getNodeUrl(d):n;d=!0;if(c)for(b=0;b&lt;c.length;b++)n==c[b]&amp;&amp;(d=!1);else d=!1;
if(!a[&quot;import&quot;]&amp;&amp;getParam(l,&quot;import&quot;,void 0)||!a.eval&amp;&amp;k.contains(&quot;eval&quot;)||!a.wikify&amp;&amp;k.contains(&quot;wikify&quot;))d=!0;d?delete f[e]:(m[n]=void 0,q.removeByUrl(n),conflicts.markNodeUnloaded(n))}this.includeUsages.markUnused(f);for(e in f)wikify(e,document.createElement(&quot;div&quot;),void 0,null)}};config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction=function(){setStylesheet(&quot;.includeProgressState{\nbackground-color:#FFCC00;\nposition:absolute;\nright:0.2em;\ntop:0.2em;\nwidth:7em;\npadding-left:0.2em;\npadding-right:0.2em\n}\n&quot;,
&quot;stp_Include&quot;);var a=function(){var a=document.createElement(&quot;div&quot;);a.className=&quot;includeProgressState&quot;;a.style.display=&quot;none&quot;;document.body.appendChild(a);return a}(),c=function(){n(function(){a.style.display=&quot;none&quot;},100,-100)};return function(b,e,f,d,g){&quot;Done&quot;==f||&quot;Failed&quot;==f?c():&quot;stp_loadTiddlyWikiStore&quot;==e?(y=0,&quot;Processing&quot;==f&amp;&amp;(removeChildren(a),createTiddlyText(a,&quot;Including...&quot;),a.style.display=&quot;block&quot;)):(removeChildren(a),createTiddlyText(a,b),a.style.display=&quot;block&quot;)}};twWeb.setProgressFunction(config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction());
var v=function(a){for(var c=0;c&lt;config.formatters.length;c++)if(config.formatters[c].name==a)return c;return null};if(config.options.STP_hijackPrettyLink){var L=v(&quot;prettyLink&quot;);config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter=config.formatters[L];config.formatters[L]={name:&quot;prettyLink&quot;,match:&quot;\\[\\[&quot;,lookaheadRegExp:/\[\[(.*?)(?:\|(~)?(.*?))?\]\](?:(?:@(\w+))(?:@([\w\s:]+)@)?)?/mg,handler:function(a){this.lookaheadRegExp.lastIndex=a.matchStart;var c=this.lookaheadRegExp.exec(a.source);
if(c&amp;&amp;c.index==a.matchStart){config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter.handler(a);var b=c[4]?c[4]:void 0,e=a.tiddler?a.tiddler.getIncludeURL():null;b=b?twWeb.setNodeNotation(b):e?e:void 0;e=&quot;{{&quot;+JSON.stringify(&quot;[[&quot;+(c[3]?c[3]:c[1])+&quot;]]&quot;)+&quot;}}&quot;;e='&quot;'+b+'&quot; filters:'+e+&quot; hide noRefresh &quot;;c[5]&amp;&amp;(e+=c[5]);b&amp;&amp;config.macros.include.handler(a.output,&quot;include&quot;,e.readMacroParams(!0),a,e,a.tiddler);a.nextMatch=this.lookaheadRegExp.lastIndex}}}}config.options.STP_hijackImageFormatter&amp;&amp;(v=
v(&quot;image&quot;),config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler=config.formatters[v].handler,config.formatters[v].handler=function(a){var c=a.output.lastChild;config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler.apply(this,arguments);if(a.output.lastChild!=c){c=a.output.lastChild;c=&quot;img&quot;==c.tagName.toLowerCase()?c:jQuery(c).find(&quot;img&quot;)[0];var b=a.tiddler?a.tiddler.getIncludeURL():&quot;&quot;,e=jQuery(c).attr(&quot;src&quot;);c.src=z(e,b)}});config.extensions.SharedTiddlersPlugin.orig_editHandler=
config.macros.edit.handler;config.macros.edit.handler=function(a,c,b,e,f,d){var g=d.getIncludeURL();if(&quot;text&quot;==b[0]&amp;&amp;g){var h=createTiddlyElement(null,&quot;div&quot;);h.className=&quot;manageIncludedPanel&quot;;createTiddlyText(h,&quot;manage the included tiddler: &quot;);var k=g+&quot;#[[&quot;+d.title+&quot;]]&quot;;createExternalLink(h,k,&quot;open in the source TiddlyWiki&quot;);createTiddlyText(h,&quot; (&quot;);createTiddlyButton(h,&quot;view link&quot;,&quot;view the link to the source&quot;,function(a){var b=Popup.create(this);createTiddlyText(createTiddlyElement(b,&quot;li&quot;,&quot;&quot;,&quot;disabled&quot;),
k);Popup.show();a=a||window.event;a.cancelBubble=!0;a.stopPropagation&amp;&amp;a.stopPropagation();return!1},&quot; &quot;);createTiddlyText(h,&quot;)&quot;);readOnly||(createTiddlyText(h,&quot; | &quot;),createTiddlyButton(h,&quot;import&quot;,&quot;import this tiddler&quot;,function(){var a=twWeb.importAndLog(d,1);switch(a.status){case 0:displayMessage('imported &quot;'+d.title+'&quot; from '+a.from);break;case -1:displayMessage('error importing &quot;'+d.title+'&quot;: '+a.errorText)}},&quot; &quot;));createTiddlyText(h,&quot; | &quot;);config.macros.reloadIncluded.handler(h,&quot;&quot;,null,null,&quot;urls:'[\&quot;&quot;+
g+&quot;\&quot;]'&quot;,d);a.appendChild(h)}return config.extensions.SharedTiddlersPlugin.orig_editHandler(a,c,b,e,f,d)};config.macros.describeNode={};config.macros.describeNode.handler=function(a,c,b,e,f,d){c=e.source.substring(e.matchStart,e.nextMatch);createTiddlyText(createTiddlyElement(a,&quot;code&quot;),c);d=d.getIncludeURL();a=b[0];b=b[1];if(&quot;self&quot;==b){if((b=twWeb.getSelfNodeName())&amp;&amp;b!=a)return alert(&quot;The '&quot;+b+&quot;' alias is already assigned as the name of the current TiddlyWiki; the new attempt to assign '&quot;+a+&quot;' is ignored.&quot;);
twWeb.setSelfNodeName(a)}else b=z(b,d),b=E(b),twWeb.addNodeDesc(a,b)};config.macros.include={};config.macros.include.handler=function(a,c,b,e,f,d){e=e.source.substring(e.matchStart,e.nextMatch);c=f.parseParams(&quot;url&quot;,null,!0,!1,!0);getFlag(c,&quot;hide&quot;,!1)||b.contains(&quot;hide&quot;)||createTiddlyText(createTiddlyElement(a,&quot;code&quot;),e);if(!twWeb.includeUsages.isUsed(e)){twWeb.includeUsages.setUsed(e);f=c[0].url;e=t({mode:getParam(c,&quot;import&quot;,void 0),which:getParam(c,&quot;importOnly&quot;,void 0),ask:getParam(c,&quot;askBeforeImport&quot;,
void 0)});b={delayMilliSeconds:parseInt(getParam(c,&quot;delay&quot;,&quot;0&quot;)),filterLine:getParam(c,&quot;filter&quot;)||getParam(c,&quot;filters&quot;,&quot;[all[-]]&quot;),substitute:b.contains(&quot;substitute&quot;),substituteShadows:b.contains(&quot;substituteShadows&quot;),noRefresh:b.contains(&quot;noRefresh&quot;),importOptions:e,evalTiddlers:b.contains(&quot;eval&quot;),wikifyTiddlers:b.contains(&quot;wikify&quot;)};c=a.parentElement;for(e=0;f&amp;&amp;e&lt;f.length;e++)d=f[e],&quot;hide&quot;!=d&amp;&amp;&quot;substituteShadows&quot;!=d&amp;&amp;&quot;substitute&quot;!=d&amp;&amp;&quot;eval&quot;!=d&amp;&amp;&quot;wikify&quot;!=d&amp;&amp;&quot;noRefresh&quot;!=d&amp;&amp;twWeb.include(d,b);c&amp;&amp;
c.appendChild(a)}};config.macros.reloadIncluded={};config.macros.reloadIncluded.handler=function(a,c,b,e,f,d){var g=f.parseParams(&quot;url&quot;,null,!0,!1,!0);c=getParam(g,&quot;label&quot;,&quot;refresh&quot;);b=getParam(g,&quot;tooltip&quot;,void 0);e=getParam(g,&quot;class&quot;,&quot; &quot;);f=getParam(g,&quot;urls&quot;,void 0);g=getParam(g,&quot;reloadParams&quot;,&quot;{}&quot;);var h=JSON&amp;&amp;JSON.parse(g)||jQuery.parseJSON(g);h.urlOrNodeList=f?JSON&amp;&amp;JSON.parse(f)||jQuery.parseJSON(f):void 0;if(!b)if(h.urlOrNodeList){b=&quot;refresh '&quot;+h.urlOrNodeList[0]+&quot;'&quot;;for(f=1;f&lt;h.urlOrNodeList.length;f++)b+=
&quot;, '&quot;+h.urlOrNodeList[f]+&quot;'&quot;;b+=0&lt;f?&quot; nodes&quot;:&quot; node&quot;}else b=&quot;refresh all included nodes&quot;;createTiddlyButton(a,c,b,function(){var a=function(){if(twWeb.hasPendingIncludes())setTimeout(a,100);else{var b=d.title;story.displayTiddler(this,b,story.chooseTemplateForTiddler(b,DEFAULT_VIEW_TEMPLATE))}};twWeb.reload(h);setTimeout(a,100)},e)};config.macros.includeState={};config.macros.includeState.handler=function(a,c,b,e,f,d){var g=function(){removeChildren(h);var a=wikify;var b=&quot;&quot;;var c=twWeb.getIncludedStoresUrls();
if(c.length){b+=&quot;|!Address|!State|\n&quot;;for(var d=0;d&lt;c.length;d++){var e=c[d];b+=&quot;|{{{&quot;+e+&quot;}}}|&quot;;e=twWeb.getState(e);b+=e?&quot;{{{&quot;+e+&quot;}}}&quot;:&quot;included&quot;;b+=&quot;|\n&quot;}b+=&quot;|includeState|k\n&quot;}else b=&quot;{{noIncludes{\nNo TiddlyWiki is included or including is disabled (see AdvancedOptions)\n}}}\n&quot;;a(b,h);twWeb.hasPendingIncludes()&amp;&amp;setTimeout(g,500)},h=createTiddlyElement(a,&quot;div&quot;);setTimeout(g,0)};I();setTimeout(J,100);window.sharedTiddlersAPI.getIncludes=twWeb.getIncludedStoresUrls;window.sharedTiddlersAPI.getState=
twWeb.getState;window.sharedTiddlersAPI.getStore=twWeb.getStore;window.sharedTiddlersAPI.importAndLog=twWeb.importAndLog;window.sharedTiddlersAPI.forReallyEachTiddler=function(a){store.forEachTiddler(a)};abego.TiddlyWikiIncluder={getIncludes:twWeb.getIncludedStoresUrls,getState:twWeb.getState,getStore:twWeb.getStore}})();
//%/ //</pre>
</div>
<div title="SharedTiddlersPluginCode" creator="Yakov Litvin" modifier="Yakov Litvin" created="201208170958" modified="201905031830" tags="code" changecount="73">
<pre>/***
|Description |Allows to use tiddlers from other ~TiddlyWikis (with or without importing them)|
|Docs        |https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginInfo|
|Source      |https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginCode|
|Author      |Yakov Litvin|
|~CoreVersion|2.7.0|
|Version     |2.5.1|
|Forked from |[[IncludePlugin|http://tiddlywiki.abego-software.de/#IncludePlugin]], by Udo Borkowski|
|Contact     |see [[docs|SharedTiddlersPluginInfo]]|
|Licence     |[[BSD-like open source license|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#%5B%5BYakov%20Litvin%20Public%20Licence%5D%5D]] |
|Copyright   |Yakov Litvin, 2013|
***/
// // ''Config:''
//{{{
config.options.STP_hijackPrettyLink = true;
config.options.STP_hijackImageFormatter = true;
//}}}
// // ''Code:''
//{{{
config.filters.all = function(results,match) {
	if(match[3] == &quot;with included&quot;) { // brings included tiddlers as well
		var m,matched = this.reverseLookup();
		for(m = 0; m &lt; matched.length; m++)
			results.pushUnique(matched[m]);
	} else
		this.forEachTiddler(function(tName,tiddler){
			results.pushUnique(tiddler);
		});
	return results;
};
config.filters.includedFrom = function(results,match) {

	var url = twWeb.getStoreUrlById(match[3]);
	if(!url)
		return [];

	for(var i = 0; i &lt; results.length; i++)
		if(results[i].getIncludeURL() != url)
			results.splice(i--,1);
	return results;
};
config.filters.external = function(results,match) {

	for(var i = 0; i &lt; results.length; i++)
		if(!results[i].getIncludeURL())
			results.splice(i--,1);
	return results;
};
config.filters.internal = function(results,match) {

	for(var i = 0; i &lt; results.length; i++)
		if(results[i].getIncludeURL())
			results.splice(i--,1);
	return results;
};
(function(){ // install only once wrapper

// Ensure the global abego namespace is set up.
if (!window.abego) window.abego = {};

// Install only once (don't install if abego.IncludePlugin is installed as well)
if (abego.TiddlyWikiIncluder)
	return alert(&quot;Warning: abego.TiddlyWikiIncluder already exists, so probably two copies of SharedTiddlersPlugin and/or IncludePlugin are installed and activated. It is highly recommended to deactivate all but one copy. You can find those by searching 'abego.TiddlyWikiIncluder'.&quot;);

// abego.TiddlyWikiIncluder is defined near the end of the code

// Define the API namespace:
window.sharedTiddlersAPI = {};

//==============================================================================
// Helpers

// This is used instead of displayMessage, because the latter sometimes doesn't show the messages
var displayAndLogMessage = function(text,linkText) {
	displayMessage(text,linkText);
	console.log(text);
};

var invokeLater = function(func, delay, priority) {
	return setTimeout(func,delay);
};

//------------------------------------------------------------------------------
// url helpers

var isRelativeURL = function(url) {
// as Unix filesystem root is &quot;/&quot;, urls starting with it are not considered as relative

	return (url.search(/^(?:((http(s)?)|(file)):)|(.\:\\)|(\\\\)|(\/)/) != 0);
};

var getPathFromURL = function(url) {

	// cut off hash first to handle a FF issue
	var hashPos  = url.lastIndexOf(&quot;#&quot;),
	    bareUrl  = (hashPos &gt; -1) ? url.substr(0, hashPos) : url,
	// then all but path
	    slashPos = bareUrl.lastIndexOf(&quot;/&quot;);
	return (slashPos &gt; -1) ? bareUrl.substr(0, slashPos + 1) : &quot;&quot;;
};

var resolveUrlFrom = function(urlToResolve, sourceUrl) {

	return (isRelativeURL(urlToResolve) &amp;&amp; sourceUrl) ?
		getPathFromURL(sourceUrl) + urlToResolve : urlToResolve;
};

// limitedly turns URI (URL) reference into an absolute URI (URL) and windows paths into URL
var stp_resolveURL = function(url) {

	if (url.search(/^((http(s)?)|(file)):/) != 0) {
	// no protocol prefix..

		if (isRelativeURL(url))

			url = resolveUrlFrom(url, document.location.toString());
		else
		// &quot;url&quot; is an &quot;absolute&quot; path to a local file. Prefix it with file://

			url = &quot;file://&quot; + url;

		// replace every \ by a /, to cover Windows style pathes
		url = url.replace(/\\/mg,&quot;/&quot;);
	}
	return url;
};

//------------------------------------------------------------------------------
// file/tw loading functions

// Asynchronously load the given (local or remote) file.
// 
// @param	url
// value:	either an URL or a local file path to a file
//
//	Examples:
//	* http://www.abego-software.de/index.html
//	* file:///C:/abegoWebSite-Copy/index.html
//	* C:\abegoWebSite-Copy\index.html    (for Windows machines)
//
//	Notice: backslashes in JavaScript string constants must be escaped, 
//	i.e. the last example must be written as: &quot;C:\\abegoWebSite-Copy\\index.html&quot;
//	when &quot;hardcoded&quot; in JavaScript source code.
// 
// @param	callback
// value:	function(content,url,params,errorMessage) 
//		called at the end of the operation. 
//		On success content holds the content of the loaded file. 
//		On error content is undefined and errorMessage holds an error message. 
//		params is the params passed into stp_LoadFile.
//
// @param	params
//		passed through to the callback function
// 
var stp_LoadFile = function(url,callback,params) {

	var onLoad = function(status,params,responseText,url,xhr) {
		return status 
				? callback(responseText, url, params)
				: callback(undefined, url, params, &quot;Error loading %0&quot;.format([url]));
	};

	// Make sure the URL is a real URL, with protocol prefix etc.
	url = stp_resolveURL(url);
	
	httpReq(&quot;GET&quot;,url,onLoad,params);
};

// Asynchronously load the given (local or remote) TiddlyWiki store.
// 
// @param	url
// value:	either an URL or a local file path to a TiddlyWiki file (absolute or relative)
//
//	Examples:
//	* http://www.abego-software.de/index.html
//	* file:///C:/abegoWebSite-Copy/index.html
//	* include/beta.html
//	* C:\abegoWebSite-Copy\index.html    (for Windows machines)
//
//	Notice: backslashes in JavaScript string constants must be escaped, 
//	i.e. the last example must be written as: &quot;C:\\abegoWebSite-Copy\\index.html&quot;
//	when &quot;hardcoded&quot; in JavaScript source code.
// 
// @param	callbackWithStore
// value:	function(theStore,url,params,errorMessage) 
//			called at the end of the operation. 
//			On success theStore holds the loaded store (a TiddlyWiki object). 
//			On error theStore is undefined and errorMessage holds an error message. 
//			params is the params passed into stp_loadTiddlyWikiStore
//
// @param	params
//		passed through to the callbackWithStore
//
// @param	progress	[optional]
// value:	function(message, sender, state, url, params)
//		called in various situations during the operation,
//		typically used to show &quot;the progress&quot; of the operation.
//		sender: the constant &quot;stp_loadTiddlyWikiStore&quot;
//		state: one of these: &quot;Started&quot;, &quot;Processing&quot;, &quot;Done&quot;, &quot;Failed&quot;
//		&quot;Processing&quot; means the data has been received and in now processed.
// 
var stp_loadTiddlyWikiStore = function(url,callbackWithStore,params,progress) {
	
	var sendProgress = function(message, state) {
		if (progress)
			progress(message,&quot;stp_loadTiddlyWikiStore&quot;,state,url,params);
	};
	
	var sendError = function(message) {
		sendProgress(&quot;Error when loading %0&quot;.format([url]),&quot;Failed&quot;);
		callbackWithStore(undefined, url, params, message);
		return message;
	};

	var sendStore = function(store) {
		sendProgress(&quot;Loaded %0&quot;.format([url]),&quot;Done&quot;);
		callbackWithStore(store, url, params);
		return null;
	};
	
	
	var callback = function(content,theURL,params,errorMessage) {
		if (content === undefined) {
			sendError(errorMessage);
			return;
		};
		
		sendProgress(&quot;Processing %0&quot;.format([url]),&quot;Processing&quot;);
		var invalidFileErrorMsg = &quot;The file '%0' does not appear to be a valid TiddlyWiki file&quot;;
		try {
			// Load the content from the &quot;content&quot; string into a TiddlyWiki() object
			var importStore = new TiddlyWiki();
			var errorText = importStore.importTiddlyWiki(content) ? null :
				&quot;Problem with importing TiddlyWiki, probable reason is: &quot;+
				invalidFileErrorMsg.format([url]);
			if(errorText)
				sendError(errorText);
			else
				sendStore(importStore);
		} catch (ex) {
			sendError(exceptionText(ex));
		};
	};
	
	sendProgress(&quot;Start loading %0&quot;.format([url]),&quot;Started&quot;);
	stp_LoadFile(url,callback,params);
};

//------------------------------------------------------------------------------
// plugin installation helpers

var getArbitraryPluginInfo = function(tiddler) {
// getPluginInfo can't be used (for included tids) due to the ugly slice handling of the core
	var pluginInfo = {
		tiddler: tiddler,
		title: tiddler.title,
		log: []
	};

	var slices = {}, slicesRE = store.slicesRE;
	var requiredInfo = [&quot;Name&quot;, &quot;Description&quot;, &quot;Version&quot;, &quot;Requires&quot;, &quot;CoreVersion&quot;, &quot;Date&quot;, &quot;Source&quot;, &quot;Author&quot;, &quot;License&quot;, &quot;Browsers&quot;];
	slicesRE.lastIndex = 0;
	var match;
	while(match = slicesRE.exec(tiddler.text)) {
		if(match[2])
			slices[match[2]] = match[3];
		else
			slices[match[5]] = match[6];
	}

	for(var i = 0; i &lt; requiredInfo.length; i++)
		if(slices[requiredInfo[i]])
			pluginInfo[requiredInfo[i]] = slices[requiredInfo[i]];

	return pluginInfo;
}

var checkPluginInstalled = function(pluginName) {
	for(var i = 0; i &lt; installedPlugins.length; i++)
		if(installedPlugins[i].title == pluginName || installedPlugins[i].Name == pluginName)
			return true;
	return false;
}

var installPlugin = function(tiddler,force) {

	var pluginName = getArbitraryPluginInfo(tiddler).Name || tiddler.title;
	// check if such a plugin was installed previously, return if so
	if(!force) // two layers to improve the speed in the &quot;force == true&quot; case
		if(checkPluginInstalled(pluginName))
			return;

	// get the plugin info
	var pluginInfo = getArbitraryPluginInfo(tiddler);
	if(tiddler.getIncludeURL())
		pluginInfo.log.push(&quot;Included via SharedTiddlersPlugin from &quot;+tiddler.getIncludeURL());

	// install the plugin
	pluginInfo.executed = true;
	var startTime = new Date();

	try {
		window.eval(tiddler.text);
	} catch(ex) {
		pluginInfo.log.push(config.messages.pluginError.format([exceptionText(ex)]));
		pluginInfo.error = true;
		console.log(&quot;error evaluating &quot; + tiddler.title, ex);
		story.displayTiddler(null,&quot;PluginManager&quot;);
		displayMessage(config.messages.customConfigError);
	}
	pluginInfo.startupTime = String((new Date()) - startTime) + &quot;ms&quot;;

	// register the plugin
	installedPlugins.push(pluginInfo);
}


//==============================================================================
// Shared Tiddlers Plugin

// Constants

var WAITING = &quot;waiting&quot;;
var LOADING = &quot;loading&quot;;

var ANI_DURATION_HIDE_STATE = 1000;

var REFRESH_PRIORITY = -200;
var ANIMATION_PRIORITY = -100;
var UPDATE_STATE_PRIORITY = -300;

// --------------------------------------------------
// Variables

var useInclude;         // this variable can be used to control include enabling by other things than cookies
var includedStores = {};  // url(String) -&gt; TiddlyWiki or String; if not (yet) loaded a status or an error string
var pendingOnLoadURLs = []; // [] of String: a list of urls that should be passed with the next &quot;notifyListeners&quot;
var refreshTiddlyWikiTimerID; // for delayed refresh
var listeners = [];
var progress;

// rules pointing which stores tiddlers with conflicting names should be fetched from
function FetchPreferences() {
	var prefs = {};
	
	this.add = function(tiddlerName,sourceUrl,substitute,substituteShadow) {
		if(!substitute &amp;&amp; !substituteShadow)
			return;
		if(prefs[tiddlerName] == undefined)
			prefs[tiddlerName] = {urlsSubs: [], urlsSubsSh: []};
		if(substitute)
			prefs[tiddlerName].urlsSubs.pushUnique(sourceUrl);
		if(substituteShadow)
			prefs[tiddlerName].urlsSubsSh.pushUnique(sourceUrl);
	};
/*	this.getPrefs = function(tiddlerName) {
		return jQuery.extend(true, {}, prefs[tiddlerName]);
	};
*/	this.getSubsUrl = function(tiddlerName) {
		var pref = prefs[tiddlerName];
		if(pref == null)
			return null;
		if(pref.urlsSubs.length == 0)
			return null;
		return pref.urlsSubs[0];
	};
	this.getSubsShUrl = function(tiddlerName) {
		var pref = prefs[tiddlerName];
		if(pref == null)
			return null;
		if(pref.urlsSubsSh.length == 0)
			return null;

		// check if there's a tiddler with both preferences
		var i, j;
		for(i = 0; i &lt; pref.urlsSubs.length; i++)
			for(j = 0; i &lt; pref.urlsSubsSh.length; j++)
				if(pref.urlsSubs[i] == pref.urlsSubsSh[j])
					return pref.urlsSubs[i];

		return pref.urlsSubsSh[0];
	};
	this.containSubsUrl = function(tName,url) {
		var pref = prefs[tName];
		if(pref == null)
			return false;
		return pref.urlsSubs.contains(url);
	};
	this.containSubsShUrl = function(tName,url) {
		var pref = prefs[tName];
		if(pref == null)
			return false;
		return pref.urlsSubsSh.contains(url);
	};
	// removes all priorities of tiddlers, included from the url
	this.removeByUrl = function(url) {

		var tName, pref, i;

		for(tName in prefs) {
			pref = prefs[tName]
			for(i = 0; i &lt; pref.urlsSubs.length; i++)
				if(pref.urlsSubs[i] == url)
					pref.urlsSubs.splice(i--, 1);
			for(i = 0; i &lt; pref.urlsSubsSh.length; i++)
				if(pref.urlsSubsSh[i] == url)
					pref.urlsSubsSh.splice(i--, 1);
		}
	};
};
var fetchPreferences = new FetchPreferences();

function Conflicts() {

	// hashmaps by tiddler name of potentially conflicting tiddlers with that name;
	// each element is a hashmap by url of tiddlers with such names
	var pConfs = {},  // doesn't contain info about tiddlers in the main store
	    pSConfs = {}; // for tiddlers that may conflict when substituting a shadow

	this.init = function() {
		// notify of name conflicts in the whole set of initial and included tiddlers?
		if(config.options.chkWarnOnSharedTiddlersConflicts == undefined) config.options.chkWarnOnSharedTiddlersConflicts = true;
		// use alert() for notifications?
		if(config.options.chkAlertOnSharedTiddlersConflicts == undefined) config.options.chkAlertOnSharedTiddlersConflicts = false;
	};
	// check whether a new tiddler (not included yet) may cause a conflict (now or in the future)
	this.checkNew = function(tName, url, subs, subsSh) {

		// use to add when a tiddler with such name is already present
		var addData = function(confsMap, tidParams) {

			var includeData = function(tidParams) {		// better to create a separate class
				return { subs: tidParams.substitute, warned: false };
			};
			var getSubsPriority = function(data) {
				return data.subs;
			}

			var conf = confsMap[tidParams.title];
			if(!conf) {
				conf = confsMap[tidParams.title] = {};
				conf[tidParams.url] = includeData(tidParams);
			} else {
				var confPart = conf[tidParams.url];
				if(!confPart)
					conf[tidParams.url] = includeData(tidParams);
				else {
					if(!getSubsPriority(confPart) &amp;&amp; tidParams.substitute)
						conf[tidParams.url] = includeData(tidParams);
						// better to set subs to true and warned to false
				}
			}
		}

		// check if there's a tiddler with such a name..
		// ..in included stores
		var existingTid = forEachLoadedStore(function(theStore, storeUrl) {

			if(storeUrl != url) return theStore.fetchTiddler(tName);
		}) ||
		// ..or in the main one
		      window.sharedTiddlersAPI.orig_fetchTiddler(tName);

		// if the tiddler is added to the main store after exactly one tiddler is
		// included, no conflict is detected by this algorithm;
		// also, it doesn't account deleting the tiddler from the main store

		if(!existingTid)
			return;
		var mainStoreId = &quot;main store&quot;,
		    existingTidUrl = existingTid.getIncludeURL();

		// check conflicts among all included tiddlers (important when no shadow with such name exists)
		if(!pConfs[tName])
			addData(pConfs, {
				title: tName,
				url: existingTidUrl || mainStoreId,
				substitute: existingTidUrl ? fetchPreferences.containSubsUrl(tName,existingTidUrl) : undefined
			});
		addData(pConfs, { title: tName, url: url, substitute: subs });

		// check conflicts among tiddlers that substitute a shadow
		if(subsSh) {
			var existingTidSubsSh = forEachLoadedStore(function(theStore, storeUrl) {
				if(storeUrl != url &amp;&amp; fetchPreferences.containSubsShUrl(tName,storeUrl))
					return theStore.fetchTiddler(tName);
			}) || window.sharedTiddlersAPI.orig_fetchTiddler(tName);
			// same problems
			
			if(!existingTidSubsSh)
				return;
			var existingTidSubsShUrl = existingTidSubsSh.getIncludeURL();

			// conflicts among substituting tiddlers are important when a shadow with such name exists
			if(!pSConfs[tName])
				addData(pSConfs, {
					title: tName,
					url: existingTidSubsShUrl || mainStoreId,
					substitute: existingTidSubsShUrl ? fetchPreferences.containSubsShUrl(tName,existingTidSubsShUrl) : undefined
				});
			addData(pSConfs, { title: tName, url: url, substitute: subs });
		}
	};
	this.markNodeUnloaded = function(url) {
		
		for(var t in pConfs)
			if(pConfs[t][url])
				delete pConfs[t][url];
		for(t in pSConfs)
			if(pSConfs[t][url])
				delete pSConfs[t][url];
	};
	this.notify = function() {
		var msgAndLog = config.options.chkWarnOnSharedTiddlersConflicts;
		var doAlert   = config.options.chkAlertOnSharedTiddlersConflicts;
		if(!doAlert &amp;&amp; !msgAndLog)
			return; // no conflict is marked as &quot;warned&quot; - this is by intent
		var tName, tUrl;

		var checkOrDisplayConflicts = function(map,msgAndLog,markWarned) {
			var msg = &quot;&quot;; // message to return (for alerting etc)
			var addM = function(m) { // pushes all notification messages
				msg += (&quot;\n&quot; + m);
				if(msgAndLog)
					displayAndLogMessage(m);
			};
			var tName, tSources, tUrl, subs, nOfConflicting, newPresent,
				subsMsg = &quot;  (with the subsitute priority)&quot;;
				// mark conflicts among tiddlers with the substitute priority

			// find out where necessary, notify
			for(tName in map) {
				tSources = map[tName];

				// find out which priority is of interest
				subs = false;
				for(tUrl in tSources)
					if(tSources[tUrl].subs)
						subs = true;

				// if there's only one tiddler with &quot;substitute&quot;, there's no conflict
				nOfConflicting = 0;
				for(tUrl in tSources)
					if(tSources[tUrl].subs == subs)
						nOfConflicting++;
				if(nOfConflicting &lt; 2)
					break;

				// find out if new conflicting tiddlers are present
				newPresent = false;
				for(tUrl in tSources)
					if(tSources[tUrl].subs == subs &amp;&amp; !tSources[tUrl].warned)
						newPresent = true;

				// start notification
				if(newPresent) {
					addM(&quot;* &quot;+tName+&quot; in:&quot;);
					for(tUrl in tSources)
						if(tSources[tUrl].subs == subs &amp;&amp; !tSources[tUrl].warned) {
							addM(&quot;** &quot;+tUrl);
							if(markWarned)
								tSources[tUrl].warned = true;
						}
					if(subs)
						addM(subsMsg);
				}
			}
			return msg;
		};

		var msg = &quot;&quot;;
		if(checkOrDisplayConflicts(pConfs,false,false)) { // new conflicts present
			msg += &quot;New conflicts:&quot;;
			if(msgAndLog) displayAndLogMessage(msg);
			msg += checkOrDisplayConflicts(pConfs,msgAndLog,true);
		};
		if(checkOrDisplayConflicts(pSConfs,false,false)) { // new conflicts among tiddlers substituting shadows present
			if(msg) msg += &quot;\n&quot;;
			var m = &quot;New conflicts among tiddlers competing for substituting shadows:&quot;;
			msg += m;
			if(msgAndLog) displayAndLogMessage(m);
			msg += checkOrDisplayConflicts(pSConfs,msgAndLog,true);
		};
		if(doAlert &amp;&amp; msg)
			alert(msg);
	};
//	this.state = // return current state as a string (for includeState)
};
conflicts = new Conflicts();
conflicts.init();

// --------------------------------------------------
// Helper functions

var isIncludeEnabled = function() {
	if (useInclude === undefined)
		useInclude = config.options.chkUseInclude === undefined || config.options.chkUseInclude;
	return useInclude;
};

var getMissingIncludeMsg = function(url) {
	return &quot;No include specified for %0&quot;.format([url])
};

// Called after one or more included TiddlyWikis are loaded
//
var notifyListeners = function() {
	var urls = pendingOnLoadURLs;
	pendingOnLoadURLs = [];
	if (urls.length)
		for (var i = 0; i &lt; listeners.length; i++)
			listeners[i](urls);
};

var idleCount; // Reset to 0 when the system is &quot;not idle&quot;, incremented inside refreshTiddlyWiki

var refreshTiddlyWiki = function() {
	// To avoid to much refreshing/flickering don't refresh immediately 
	// but wait until the system was idle for a certain time.

	if (refreshTiddlyWikiTimerID !== undefined) clearInterval(refreshTiddlyWikiTimerID);

	idleCount = 0;

	var sendDone = function() {
		twWeb.sendProgress(&quot;&quot;,&quot;&quot;,&quot;Done&quot;);
	};

	refreshTiddlyWikiTimerID = setInterval(function() {
		idleCount++;
		if (idleCount &lt;= 10)
			return;

		clearInterval(refreshTiddlyWikiTimerID);
		refreshTiddlyWikiTimerID = undefined;

		twWeb.sendProgress(&quot;Refreshing...&quot;,&quot;&quot;,&quot;&quot;);
		refreshDisplay();
		invokeLater(sendDone,0,REFRESH_PRIORITY);
	},1);
};

// Calls callback for every loaded store and returns the first non-false/null.. value returned by callback.
//
// @param	callback
// value:	function(store, url)
//
var forEachLoadedStore = function(callback) {
	var result;
	for(var url in includedStores) {
		var theStore = twWeb.getStore(url);
		if (theStore &amp;&amp; (result = callback(theStore, url)))
			return result;
	}
};

// hijack fetchTiddler and store.forEachTiddler to make them work with tiddlers from included stores as well
var attachToStore = function() {

	if (!window.store) return invokeLater(attachToStore,100);

	var orig_fetchTiddler = store.fetchTiddler;
	// add API to be able to fetch substituted tiddlers in the main store:
	window.sharedTiddlersAPI.orig_fetchTiddler = orig_fetchTiddler;

	store.fetchTiddler = function(title) {

		var t, subsUrl = fetchPreferences.getSubsUrl(title), subsShUrl;

		// first, look for the tiddler in the main store, unless there's nothing to substitute with
		if(!subsUrl) {
			t = orig_fetchTiddler.apply(this,arguments);
			if(t) return t;
		} else
			return includedStores[subsUrl].fetchTiddler(title);
		
		// then, look for shadowed tiddlers in main store and external ones to substitute those
		if(config.shadowTiddlers[title] !== undefined) {
			if(subsShUrl = fetchPreferences.getSubsShUrl(title))
				return includedStores[subsShUrl].fetchTiddler(title);
			else
				return undefined;
		};

		// Including &quot;New Tiddler&quot; tiddler would prevent creating new tiddlers
		// via standart &quot;new tiddler&quot; button, so don't look for such
		if (title == config.macros.newTiddler.title) return undefined;

		// finally, look for an external one without &quot;substitute&quot; preference
		return forEachLoadedStore(function(theStore, url) {
			return theStore.fetchTiddler(title);
		});
	};

	var orig_forEachTiddler = store.forEachTiddler;
	window.sharedTiddlersAPI.orig_forEachTiddler = orig_forEachTiddler;
	store.forEachTiddler = function(callback) {

		var done = {};

		var callbackWrapper = function(title, tiddler) {
			// ensure every title is only processed once
			if(done[title]) 
				return;
			
			// do and set done for appropriate tiddlers
			if(!fetchPreferences.getSubsUrl(title)||
			   (fetchPreferences.getSubsUrl(title) == tiddler.getIncludeURL())) {
				done[title] = 1;
				callback.apply(this,arguments);
			};
		};
		
		// first, forEachTiddler over the original tiddlers
		orig_forEachTiddler.call(store, callbackWrapper);

		// add nonsubstituted shadowTiddler titles to done 
		// (to avoid an included store hide a shadow tiddler)
		for (var n in config.shadowTiddlers)
			if(!fetchPreferences.getSubsShUrl(n))
				done[n] = 1;

		// add the &quot;New Tiddler&quot; tiddler to done
		// to avoid an included store (with such tiddler) prevent creating new tiddlers
		done[config.macros.newTiddler.title] = 1;

		// forEachTiddler over every included store
		forEachLoadedStore(function(theStore, url) {
			theStore.forEachTiddler(callbackWrapper);
		});
	};

	// refresh TiddlyWiki to reflect the new included Tiddlers (if we have any).
	if(twWeb.getIncludedStoresUrls().length)
		refreshTiddlyWiki();
};

var includeFromIncludeList = function() {
	if (!window.store)
		return invokeLater(includeFromIncludeList,100);

	var includeList = store.fetchTiddler(&quot;IncludeList&quot;),
	    includeListText = includeList.text;
	if (includeListText)
		wikify(includeListText,document.createElement(&quot;div&quot;),undefined, includeList);
};


//================================================================================
// config.extensions.SharedTiddlersPlugin (the &quot;includer&quot; engine)

config.extensions.SharedTiddlersPlugin = {

	// function config.extensions.SharedTiddlersPlugin.getFunctionUsingForReallyEachTiddler(func)
	//
	// Deprecated: returned a function that behaved as func, but every call
	// to store.forEachTiddler was actually a call to forReallyEachTiddler
	// (see below). Now forEachTiddler is changed globally and this method
	// returns the function without changes
	//
	// @return the patched function
	//
	getFunctionUsingForReallyEachTiddler: function(func) { return func; },
	
	// function config.extensions.SharedTiddlersPlugin.useForReallyEachTiddler(object,methodName)
	//
	// Deprecated: used for patching the object's method so that a call
	// to store.forEachTiddler was actually a call to forReallyEachTiddler
	// (iterating over the tiddlers of the main store and included ones)
	// Now store.forEachTiddler is changed globally and patching is not needed
	// and the method is returned unchanged
	//
	// @param  object
	// @param  methodName the name of the object' method to be patched
	// @return the method
	//
	useForReallyEachTiddler: function(object,methodName) {
		return object[methodName];
	},
	
	// Add a listener function to the TiddlyWikiIncluder.
	//
	// @param  listener  function(urls)
	//	urls: [] of Strings, containing the urls of the TiddlyWiki just included
	//	(see url@config.extensions.SharedTiddlersPlugin.include)
	//	called whenever one or more TiddlyWiki store are successfully included.
	//
	addListener: function(listener) {
		listeners.push(listener);
	}
};


// -------------------------------------------------------------------------------
// TiddlyWikiIncluder initialization code

config.extensions.SharedTiddlersPlugin.addListener(refreshTiddlyWiki);

config.shadowTiddlers.AdvancedOptions +=
	(&quot;\n~IncludePlugin settings:&quot;+
	 &quot;\n&lt;&lt;option chkUseInclude&gt;&gt; Include ~TiddlyWikis&quot;+
	 &quot;\n&lt;&lt;option chkAlertOnSharedTiddlersConflicts&gt;&gt; Alert on tiddler name conflicts&quot;+
	 &quot;\n&lt;&lt;option chkWarnOnSharedTiddlersConflicts&gt;&gt; Display messages and write log in the browser console on conflicts&quot;+
	 &quot;\nIncludeList | IncludeState | ImportIncluded | [[help|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginInfo]]&quot;+
	 &quot;\n^^(Reload this ~TiddlyWiki to make changes become effective)^^&quot;);
config.shadowTiddlers.IncludeState = &quot;&lt;&lt;includeState&gt;&gt;&quot;;

// add the &quot;importer&quot; engine
config.shadowTiddlers.ImportIncluded =
&quot;|               &lt;&lt;option txtStoreUrl&gt;&gt;|url of the document to import from |\n&quot;+
&quot;| &lt;&lt;option txtFilterTiddlersToImport&gt;&gt;|filter of tiddlers to import |\n&quot;+
&quot;|            &lt;&lt;option chkImportNewer&gt;&gt;|import only newer tiddlers (if those with same title already present) |\n&quot;+
&quot;|              &lt;&lt;option chkImportAsk&gt;&gt;|interactive import (ask whether to import each tiddler) |\n&quot;+
&quot;&lt;html&gt;&lt;a href='javascript:;' onclick='\n&quot;+
&quot;	var storeUrl = config.options.txtStoreUrl,\n&quot;+
&quot;	    params = {\n&quot;+
&quot;		filterLine: config.options.txtFilterTiddlersToImport,\n&quot;+
&quot;		importOptions: {\n&quot;+
&quot;			which: config.options.chkImportNewer ? \&quot;newer\&quot; : \&quot;all\&quot;,\n&quot;+
&quot;			ask: config.options.chkImportAsk\n&quot;+
&quot;		},\n&quot;+
&quot;		noRefresh: true,\n&quot;+
&quot;	};\n&quot;+
&quot;	if(!storeUrl)\n&quot;+
&quot;		return displayMessage(\&quot;please specify the url to import from\&quot;);\n&quot;+
&quot;	if(!params.filterLine)\n&quot;+
&quot;		return displayMessage(\&quot;please specify the filter of tiddlers to import\&quot;);\n&quot;+
&quot;	if(!sharedTiddlersAPI.getStore(storeUrl))\n&quot;+
&quot;		displayMessage(\&quot;warning: no store was loaded from \&quot;+storeUrl+\&quot; previously, trying now\&quot;);\n&quot;+

&quot;	twWeb.include(storeUrl,params);\n&quot;+
&quot;'&gt;import (without saving)&lt;a/&gt;&lt;/html&gt;&quot;;

//================================================================================
// Tiddler extension/modification

Tiddler.prototype.isIncluded = function() {
	return this.includeURL != undefined;
};

Tiddler.prototype.getIncludeURL = function() {
	return this.includeURL;
};

Tiddler.prototype.setIncludeURL = function(url) {
	this.includeURL = url;
};

Tiddler.prototype.deleteIncludeURL = function() {
	delete this.includeURL;
};

// make included tiddlers readonly and non-savable
if(!config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly) {
  config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly = Tiddler.prototype.isReadOnly;

  Tiddler.prototype.isReadOnly = function() {
	return config.extensions.SharedTiddlersPlugin.orig_Tiddler_isReadOnly.apply(this,arguments) || this.isIncluded();
  };
}
if(!config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave) {
  config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave = Tiddler.prototype.doNotSave;

  Tiddler.prototype.doNotSave = function() {
	return config.extensions.SharedTiddlersPlugin.orig_Tiddler_doNotSave.apply(this,arguments) || this.isIncluded();
  };
}

//================================================================================
// Web of TiddlyWikis

function IncludingMemorizer() { // the structure to store info about already handled include macros
	var used = {};
	this.isUsed  = function(line) { return used[line]? true : false; };
	this.setUsed = function(line) { used[line] = 1; };
	this.getUsed = function() { return jQuery.extend(true, {}, used) };
	this.markUnused = function(usedMap) {

		for(var u in usedMap)
			// don't delete to keep the order of inclusion (for reloading)
			used[u] = undefined;
	};
};

function TwWeb() {

	var nodes = {};			// hashmap by node name of nodes' metadata
	var nodeConflicts = {};		// hashmap by node name of arrays of conflicts
	var nodeWaitingTasks = {};	// hashmap by node name of arrays of Waiting Tasks
	var nodeDescription = function(url) { // PoG: can be turned into a separated &quot;class&quot;
		return { url : url };
	};
	var selfNodeName;
	var self = this;

	this.includeUsages = new IncludingMemorizer();

// ----- Nodes desctiptions part ---------------------------------------------------------

	// set/get the name of &quot;main&quot; (including) node
	this.setSelfNodeName = function(name) {
		selfNodeName = name;
	};
	this.getSelfNodeName = function() {
		return selfNodeName;
	};

	// set/get/delete node description
	this.setNodeDesc = function(nodeName, desc) {

		var existing = this.getNodeDesc(nodeName);

		// currently, doesn't change metadata on conflict
		if(existing)
			this.addConflict(nodeName, desc);
		else
			nodes[nodeName] = desc;

		this.callWaitingTasks(nodeName);
	};
	this.getNodeDesc = function(nodeName) {
		return nodes[nodeName];
	};
	this.deleteNodeDesc = function(nodeName) {
		nodes[nodeName] = null;
	};

	// &quot;API&quot; method to be used in the macro
	this.addNodeDesc = function(nodeName, url) {
		this.setNodeDesc(nodeName, nodeDescription(url));
	};

	// returns &quot;better&quot; description if one is &quot;strictly better&quot; than the other or &quot;even&quot; and null otherwise
	this.compareNodeDesc = function(desc1, desc2) {

// looks like here's a mistake: probably &quot;: desc2&quot; (?)
		return (desc1.url == desc2.url)? desc1 : null;
	};

	this.getNodeUrl = function(nodeName) {

		var desc = this.getNodeDesc(nodeName);
		return desc? desc.url : null;
	};

	// @param	nodeId
	//		url or &quot;node: nodeName&quot; id of the node
	// @return	url of the node (if it is defined) or null
	//
	this.getStoreUrlById = function(nodeId) {

		var node = self.checkNodeNotation(nodeId),
		    url  = node ? self.getNodeUrl(node) : nodeId;
		return url;
	}

	this.setNodeNotation = function(nodeName) {

		return &quot;node: &quot; + nodeName;
	};
	this.checkNodeNotation = function(urlParam) {

		var nodeCalcRE = /node: (.*)/,
		    nodeCalcMatch = nodeCalcRE.exec(urlParam);

		return nodeCalcMatch ? nodeCalcMatch[1] : null;
	};

	this.addConflict = function(nodeName, nodeDesciption) {

		var betterDesc = this.compareNodeDesc(nodeDesciption,this.getNodeDesc(nodeName));
		if(betterDesc) {
			this.deleteNodeDesc(nodeName);
			this.setNodeDesc(nodeName, betterDesc);
			return;
		}

		if(nodeConflicts[nodeName])
			nodeConflicts[nodeName].push(nodeDesciption);
		else
			nodeConflicts[nodeName] = [ nodeDesciption ];

		alert(  &quot;Warning: more than one description of the &quot;+nodeName+&quot; node was pushed. &quot;+
			&quot;The earlier version is kept.&quot;  );
	};

// ----- Waiting tasks part --------------------------------------------------------------

	this.setWaitingTask = function(nodeName, waitingTaskFunc, waitingTaskSelf) {

		var waitingTask = { action: waitingTaskFunc, self: waitingTaskSelf };

		if(nodeWaitingTasks[nodeName])
			nodeWaitingTasks[nodeName].push(waitingTask);
		else
			nodeWaitingTasks[nodeName] = [ waitingTask ];

		if(this.getNodeUrl(nodeName))
			this.callWaitingTasks(nodeName);
	};
	this.callWaitingTasks = function(nodeName) {

		var toDo = nodeWaitingTasks[nodeName];

		if(toDo)
			for(var i = 0; i &lt; toDo.length; i++)
				toDo[i].action.call(toDo[i].self);

		nodeWaitingTasks[nodeName] = null; // remove called Waiting Tasks
	};

// ----- Including stuff part ------------------------------------------------------------

	// ---- helpers ----

	this.setProgressFunction = function(func) {
		progress = func;
	};
/*	this.getProgressFunction = function() {	// is not in use
		return progress;
	};
*/	this.sendProgress = function(message, sender, state) {
		if (progress)
			progress.apply(this,arguments);
	};

	// Returns true when there are &quot;pending&quot; includes, i.e. TiddlyWiki that are not yet loaded.
	// A TiddlyWiki that failed loading is not pending.
	//
	this.hasPendingIncludes = function() {
		var state;
		for(var url in includedStores) {
			state = this.getState(url);
			if (state == WAITING || state == LOADING)
				return true;
		};
		return false;
	};

	// Called when an included TiddlyWiki could not be loaded.
	// By default an error message is displayed.
	//
	this.onError = function(url, errorMessage) {
		displayAndLogMessage(&quot;Error when including '%0':\n%1&quot;.format([url, errorMessage]));
	};

	// import a tiddler from an included store
	//
	// @param  tiddler - a tiddler to import
	// @param  options: ...
//# update doc: options.mode: undefined or 1 - import anyway (other modes, like &quot;don't substitute&quot; will be supported)
	// @return the result object:
	//  .status means: -1 = error, 0 = tiddler is imported, &gt;0 - reserved for other situations
	//  .errorText is not empty on error
	//  .tiddler is the tiddler with /the title/ which is in the store after &quot;it is over&quot; (may be null)
	//  .from is the url line equal to the includeURL of the imported tiddler
	//
	this.importIncluded = function(tiddler, options) {

		var t, tInMain, result = { tiddler: null };

		if(tiddler instanceof Tiddler) {
			// see return value, this is for the case when the import is not done
			result.tiddler = window.sharedTiddlersAPI.orig_fetchTiddler(tiddler.title);
			t = jQuery.extend(true, new Tiddler(), tiddler);
		} else {
			result.status = -1;
			result.errorText = &quot;not a Tiddler instance&quot;;
			return result;
		};
		var url = t.getIncludeURL();

		if(options === null) options = { which: 'all', ask: false };
		if(options.which == 'newer') {
			tInMain = window.sharedTiddlersAPI.orig_fetchTiddler(t.title);
			if(tInMain &amp;&amp; tInMain.modified &gt;= t.modified) return result;
		}
		var importAnotherVersionConfirmation = &quot;%0 from %1 of %2 is available, &quot;+
			&quot;import to substitute current one (%3)?&quot;;
		if(options.which == 'newerVersion') {
			var parseVersion = function(versionString) {
				var parts = /(\d+)\.(\d+)\.(\d+)/.exec(versionString);
				return parts ? {
					major: parts[1],
					minor: parts[2],
					revision: parts[3]
				} : null;
			};
			tInMain = window.sharedTiddlersAPI.orig_fetchTiddler(t.title);
			if(tInMain) {
				var version = t.getSlice('Version'),
				    versionInMain = tInMain.getSlice('Version');
				if(version &amp;&amp; versionInMain) {
					if(compareVersions(version, versionInMain) &lt;= 0)
						return result;
				} else {
					var getVersionString = function(v) {
						return v ? &quot;unknown version&quot; :
							(&quot;version&quot; + v);
					}
					
					if(!confirm(importAnotherVersionConfirmation
						.format(t.title, url,
						 getVersionString(version),
						 getVersionString(versionInMain)))
					) return result;
				}
			}
		}

		if(options.ask) {
			var confirmMessage = options.which == 'newer' ?
				&quot;Up-to-date &quot;+ t.title +&quot; from &quot;+ url +&quot; is availabe, import?&quot; :
					options.which == 'newerVersion' ?
				importAnotherVersionConfirmation.format(t.title, url,
					&quot;version &quot;+ version, &quot;version &quot;+ versionInMain) :
				t.title +&quot; from &quot;+ url +&quot; is availabe, import?&quot;
			if(!confirm(confirmMessage))
				return result;
		}

		// report unsupported mode
		if(options.mode &amp;&amp; !(options.mode in { 1: true, 2:true, 3:true, 4:true }))
		{
			result.status = -1;
			result.errorText = &quot;unknown import mode&quot;;
			return result;
		}

		var doImport = function(t) {
			if(url) t.deleteIncludeURL();
			store.addTiddler(t);
			store.setDirty(true);
			result.status = 0;
			result.tiddler = t;
			result.from = url;
		};
		doImport(t);

		return result;
	};
	this.importAndLog = function(tiddler, modeOrOptions) {

		var options = calcImportOptions(modeOrOptions),
		    result  = twWeb.importIncluded(tiddler, options),
		    name    = tiddler.title;
		// this.importIncluded is not used to be able to pass the method to the API

		switch(result.status) {
			case 0:	 console.log(&quot;imported: &quot;+name+&quot; from &quot;+result.from);
				 break
			case -1: console.log(&quot;error importing &quot;+name+&quot;: &quot;+result.errorText);
				 break
		}
		return result;
	};

	// ---- main ----

	// Includes the (local or remote) TiddlyWiki store with the given url.
	//
	// @param url		see url@stp_loadTiddlyWikiStore
	// @param includeParams	a set of the following params for including:
	//	filterLine		a filter expression defining a set of tiddlers to include
	//	substituting		points whether an included tiddler should sustitute
	//				one in the main document if there's a conflict of names
	//	substituteShadows	points whether shadowed tiddlers of the main document with names equal to
	//				those of included ones should be substituted (in cases of conflicts);
	//				works only with (substituting == true)
	//	delayMilliSeconds	addition delay of loading
	//	noRefresh
	//	importOptions
	//	evalTiddlers
	//	wikifyTiddlers
	//
	this.include = function(urlOrNodeParam, includeParams) {

		if (!isIncludeEnabled())
			return;
		var self = this;

		var includeOrHandleUrl = function(url) {

			var loadStoreCallback = function(theStore,urlInCallback,params,errorMessage) {

				if(theStore === undefined) {
				
					includedStores[url] = errorMessage;
					self.onError(url, errorMessage);
					return;
				} else
					includedStores[url] = theStore;

				// keep orig_store not to load tw-documents multiple times
				// because of multiple include macros:
				includedStores[url].orig_store = new TiddlyWiki();
				includedStores[url].forEachTiddler(function(tName,tiddler){
					tiddler.setIncludeURL(url);
					includedStores[url].orig_store.addTiddler(tiddler);
				});
				includedStores[url].clear();

				// include, create fetchPreferences and notify of conflicts; or import
				addFromLoadedStore();
			};

			var addFromLoadedStore = function() {
			// uses url and includeParams exploiting closure

				var substituting = includeParams.substitute,
				    substituteShadows = includeParams.substituteShadows,
				    importOptions = includeParams.importOptions;

				// new tiddlers can be added *when the store is loaded*
				if(twWeb.getStore(url) === null)
					return invokeLater(addFromLoadedStore, 100);

				// add tiddlers to included stores and check new conflicts (among non-subs. tids)
				var i, t,
				    new_tiddlers = includedStores[url].orig_store.filterTiddlers(includeParams.filterLine);

				for(i = 0; i &lt; new_tiddlers.length; i++) {

					t = jQuery.extend(true, new Tiddler(), new_tiddlers[i]); //copy (by value)

					if(includedStores[url].orig_store.fetchTiddler(t.title)) {
					// ignore empty tiddlers created by the &quot;tiddler&quot; filter
					    if(importOptions) {
					        twWeb.importAndLog(t, importOptions);
					    } else {
					        // check for upcoming conflicts first
					        conflicts.checkNew(t.title, url, substituting, substituteShadows);
					        // then include
					        includedStores[url].addTiddler(t);
					    };
					    if(includeParams.evalTiddlers)
					        installPlugin(t);
					    if(includeParams.wikifyTiddlers)
					        wikify(t.text,document.createElement(&quot;div&quot;),undefined,t);
					};
				};

				// add items to fetchPreferences if have to
				if(!importOptions &amp;&amp; (substituting || substituteShadows))
					for(i = 0; i &lt; new_tiddlers.length; i++)
						fetchPreferences.add(new_tiddlers[i].title,url,substituting, substituteShadows);
				conflicts.notify();

				// &quot;recalc&quot; slices
				store.slices = {};
				// refresh things to get included stylesheets, PageTemplate and ViewTemplate applied
				if(!includeParams.noRefresh) {
					refreshAll();
					story.refreshAllTiddlers();
				}

				pendingOnLoadURLs.push(url);
				invokeLater(notifyListeners);
			};

			var loadStore = function() {
				includedStores[url] = LOADING;
				stp_loadTiddlyWikiStore(url,loadStoreCallback,null,progress);
				// {includeParams:includeParams} can be used instead of null so that
				// loadStoreCallback will have access to the includeParams
			};

			var urlIsNew = !(includedStores[url]);

			if(urlIsNew) {

				includedStores[url] = WAITING;

				if (includeParams.delayMilliSeconds)
					invokeLater(loadStore, includeParams.delayMilliSeconds);
				else
					loadStore();
			} else
				addFromLoadedStore();
		};

		var nodeName = this.checkNodeNotation(urlOrNodeParam);

		if(nodeName) {
			if(nodeName == this.getSelfNodeName()) // don't include from the main (self) TiddlyWiki
				return;

			this.setWaitingTask(nodeName,function(){
				var url = this.getNodeUrl(nodeName);
				includeOrHandleUrl(url);
			},this);
		} else
			includeOrHandleUrl(urlOrNodeParam);
	};
	
// ----- Methods for dealing with included stuff -----------------------------------------

	// @return [] of Strings, the URLs of the includes
	//
	this.getIncludedStoresUrls = function() { // in a form of an array

		var includes = [];
		for(var url in includedStores)
			includes.push(url);
		return includes;
	};
	// @return the (TiddlyWiki) store with the given URL or &quot;node: nodeName&quot;, or null if not (yet) loaded.
	//
	this.getStore = function(nodeId) {

		var url = self.getStoreUrlById(nodeId)
		if(!url)
			return null;

		var s = includedStores[url];
		if(s &amp;&amp; s instanceof TiddlyWiki)
			return s;
		return null;
	};
	// @return a state/error text of the store with the given URL, or null when the store is already loaded
	//
	this.getState = function(nodeId) {

		var url = self.getStoreUrlById(nodeId)
		if(!url)
			return &quot;the node &quot;+self.checkNodeNotation(nodeId)+&quot; is not described yet, the address is unknown&quot;;

		var s = includedStores[url];
		if (!s)
			return getMissingIncludeMsg(url);
		return typeof s == &quot;string&quot; ? s : null;
	};
	// reload one included store or all of them
	// previous inclusions are done again, by default only those without eval and import
	// important: reload doesn't work correctly with &lt;&lt;include&gt;&gt; usages with multiple urls
	//
	// @param  reloadParams  an object containing some of these configuration properties:
	//	urlOrNodeList	an array of TWs' IDs (url or &quot;node: nodeName&quot;) to reload;
	//			if undefined, all TWs are reloaded
	//	eval		points whether to redo inclusions with the &quot;eval&quot; parameter (undefined == false)
	//	import		same for the &quot;import&quot; parameter, but undefined/null -&gt; true
	//	wikify		same for the &quot;wikify&quot; parameter
	this.reload = function(reloadParams) {

		// determine a TW(s) to reload (undefined =&gt; all)
		var i, twsToReload = reloadParams.urlOrNodeParam;

		// turn &quot;IDs&quot; into actual urls; filter out node names for which urls are not defined
		// so waiting tasks are not doubled
		if(twsToReload)
			for(i = 0; i &lt; twsToReload.length; i++){ 
				nodeName = this.checkNodeNotation(twsToReload[i]);
				twsToReload[i] = nodeName ? this.getNodeUrl(nodeName) : twsToReload[i];
				if(!twsToReload[i])
					twsToReload.splice(i--,1);
			}

		if(reloadParams.import === undefined || reloadParams.import === null)
			reloadParams.import = true;
		if(reloadParams.wikify === undefined || reloadParams.wikify === null)
			reloadParams.wikify = true;

		// collect macro expressions to reload
			// may the order of including be important?
		var usage, usages = this.includeUsages.getUsed(),
		    paramString, params, pParams, urlParam, nodeName,
			dontReload, i;

		for(usage in usages) {

			// parsing copied from config.macros.include.handler (to get macro params)
			paramString = usage.substring(10,usage.length - 2);
			params = paramString.readMacroParams();
			pParams = paramString.parseParams(&quot;url&quot;,null,true,false,true);
			urlParam = pParams[0][&quot;url&quot;][0];
			nodeName = this.checkNodeNotation(urlParam);
			urlParam = nodeName ? this.getNodeUrl(nodeName) : urlParam;

			// keep only inclusions that contain IDs corresponding to urls from twsToReload
			dontReload = true;
			if(twsToReload) {
				for(i = 0; i &lt; twsToReload.length; i++)
					if(urlParam == twsToReload[i])
						dontReload = false;
			} else
				dontReload = false;

			// exclude inclusions with import and eval, if necessary
			if(!reloadParams.import &amp;&amp; getParam(pParams,&quot;import&quot;,undefined) ||
			   !reloadParams.eval &amp;&amp; params.contains('eval') ||
			   !reloadParams.wikify &amp;&amp; params.contains('wikify'))
				dontReload = true;

			if(dontReload) {
				delete usages[usage];
				continue;
			}

			// clean stuff: unload included store, clear priorities, remove conflicts;
			// deleting &quot;used&quot; marks is outside this loop
			includedStores[urlParam] = undefined;
			fetchPreferences.removeByUrl(urlParam);
			conflicts.markNodeUnloaded(urlParam);
		}
		// delete &quot;used&quot; marks
		this.includeUsages.markUnused(usages);
		
		// include again
		for(usage in usages)
			wikify(usage,document.createElement(&quot;div&quot;),undefined,null);
	};
};
twWeb = new TwWeb();

//================================================================================
// Default Progress Handling for config.extensions.SharedTiddlersPlugin

var showAnimated = function(e, showing, duration) {
//	if (!anim || !abego.ShowAnimation) {
		e.style.display = showing ? &quot;block&quot; : &quot;none&quot;;
		return;
//	}
	
//	anim.startAnimating(new abego.ShowAnimation(e,showing,duration));
};

config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction = function() {

	setStylesheet(
		&quot;.includeProgressState{\n&quot;+
		&quot;background-color:#FFCC00;\n&quot;+
		&quot;position:absolute;\n&quot;+
		&quot;right:0.2em;\n&quot;+
		&quot;top:0.2em;\n&quot;+
		&quot;width:7em;\n&quot;+
		&quot;padding-left:0.2em;\n&quot;+
		&quot;padding-right:0.2em\n&quot;+
		&quot;}\n&quot;,
		&quot;stp_Include&quot;);

	var createStateElem = function() {
		var e = document.createElement(&quot;div&quot;);
		e.className = &quot;includeProgressState&quot;;
		e.style.display = &quot;none&quot;;
		document.body.appendChild(e);
		return e;
	};
	
	var stateElem = createStateElem();


	var showState = function(message) {
		removeChildren(stateElem);
		createTiddlyText(stateElem,message);
		showAnimated(stateElem,true,0);
	};

	var hideState = function() {
		// hide the state the next idle time 
		invokeLater(function() {
			showAnimated(stateElem,false,ANI_DURATION_HIDE_STATE);
		},100,ANIMATION_PRIORITY);
	};
	
	var myProgressFunction = function(message, sender, state, url, params) {
		
		if (state == &quot;Done&quot; || state == &quot;Failed&quot;) {
			hideState();
			return;
		}
		
		if (sender == &quot;stp_loadTiddlyWikiStore&quot;) {
			idleCount = 0;
			if (state == &quot;Processing&quot;)
				showState(&quot;Including...&quot;);
		} else {
			showState(message);
		}
	};
	return myProgressFunction;
};

twWeb.setProgressFunction(config.extensions.SharedTiddlersPlugin.getDefaultProgressFunction());


//================================================================================
// Change standart formatters

var getFormatterIndex = function(formatterName) {
	for(var i = 0; i &lt; config.formatters.length; i++)
		if(config.formatters[i].name == formatterName)
			return i;
	return null;
}

//--------------------------------------------------------------------------------
// Change the prettyLink formatter so that it
// * recognizes [[text|target]]@nodeName and [[target]]@nodeName syntax
// * takes into account includeURL of the tiddler and propagates inclusion

if(config.options.STP_hijackPrettyLink) {
	var prettyLinkFormatterIndex = getFormatterIndex(&quot;prettyLink&quot;);
	config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter = config.formatters[prettyLinkFormatterIndex];
	config.formatters[prettyLinkFormatterIndex] = {

		name:  &quot;prettyLink&quot;,
		match: &quot;\\[\\[&quot;,
		lookaheadRegExp: /\[\[(.*?)(?:\|(~)?(.*?))?\]\](?:(?:@(\w+))(?:@([\w\s\:]+)@)?)?/mg,
		handler: function(w) {

			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch &amp;&amp; lookaheadMatch.index == w.matchStart) {

				// call the formatter
				config.extensions.SharedTiddlersPlugin.orig_prettyLinkFormatter.handler(w);

				// call the include.handler, if necessary
				var node = lookaheadMatch[4]? lookaheadMatch[4] : undefined,
				    includeURL = w.tiddler? w.tiddler.getIncludeURL() : null,
				    urlParam = node? twWeb.setNodeNotation(node) : (includeURL? includeURL : undefined),
				    target = lookaheadMatch[3]? lookaheadMatch[3] : lookaheadMatch[1],
				    // use a eval'ed filter expression to deal with titles containing ', &quot; etc
				    filter = &quot;{{&quot;+JSON.stringify('[['+target+']]')+&quot;}}&quot;,
				    paramString = '&quot;'+urlParam+'&quot; filters:'+filter+' hide noRefresh ';
				if(lookaheadMatch[5])
					paramString += lookaheadMatch[5];
				if(urlParam)
					config.macros.include.handler(w.output,&quot;include&quot;,
						paramString.readMacroParams(true),w,paramString,w.tiddler);

				// move nextMatch according to this.lookaheadRegExp, not original prettyLink
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	};
}

//--------------------------------------------------------------------------------
// Change the image formatter so that it
// * takes into account includeURL of the tiddler and recalcs relative urls

if(config.options.STP_hijackImageFormatter) {
	var imageFormatterIndex = getFormatterIndex(&quot;image&quot;);
	config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler = config.formatters[imageFormatterIndex].handler;
	config.formatters[imageFormatterIndex].handler = function(w) {

		var lastChildBeforeHandling = w.output.lastChild;
		config.extensions.SharedTiddlersPlugin.orig_imageFormatterHandler.apply(this,arguments);

		if(w.output.lastChild != lastChildBeforeHandling) {

			var elem = w.output.lastChild,
			    // sometimes elem is not the image itself, but a wrapper (&lt;a&gt;)
			    img = elem.tagName.toLowerCase() == &quot;img&quot; ? elem : jQuery(elem).find(&quot;img&quot;)[0],
			    includeURL = w.tiddler ? w.tiddler.getIncludeURL() : &quot;&quot;,
			    imgSrc = jQuery(img).attr(&quot;src&quot;);

			// take includeURL into account:
			img.src = resolveUrlFrom(imgSrc, includeURL);
		}
	}
}

//================================================================================
// Add inline-management tools by hijacking .edit.handler

config.extensions.SharedTiddlersPlugin.orig_editHandler = config.macros.edit.handler;
config.macros.edit.handler = function(place,macroName,params,wikifier,paramString,tiddler) {
	var includeUrl = tiddler.getIncludeURL();
	if(params[0] == &quot;text&quot; &amp;&amp; includeUrl){ // only for &quot;text&quot;, not other fields
		var e = createTiddlyElement(null,&quot;div&quot;);
		e.className = &quot;manageIncludedPanel&quot;;
		createTiddlyText(e,&quot;manage the included tiddler: &quot;);

		// go to the source
		var sourceUrl = includeUrl + &quot;#[[&quot;+tiddler.title+&quot;]]&quot;;
		createExternalLink(e, sourceUrl, &quot;open in the source TiddlyWiki&quot;);
		// view the link to the source
		createTiddlyText(e,&quot; (&quot;);
		createTiddlyButton(e, &quot;view link&quot;, &quot;view the link to the source&quot;, function(e){
			var popup = Popup.create(this);
			createTiddlyText(createTiddlyElement(popup, 'li', '', 'disabled'), sourceUrl);
			Popup.show();
			var ev = e || window.event;
			ev.cancelBubble = true;
			if(ev.stopPropagation)
				ev.stopPropagation();
			return false;
		},&quot; &quot;);
		createTiddlyText(e,&quot;)&quot;);

		// import
		if(!readOnly) {
			createTiddlyText(e,&quot; | &quot;);
			createTiddlyButton(e,&quot;import&quot;,&quot;import this tiddler&quot;,function(){
				var result = twWeb.importAndLog(tiddler, 1);
				switch(result.status) {
					case 0:	 displayMessage(&quot;imported \&quot;&quot;+tiddler.title+&quot;\&quot; from &quot;+result.from);
				 		break
					case -1: displayMessage(&quot;error importing \&quot;&quot;+tiddler.title+&quot;\&quot;: &quot;+result.errorText);
						 break
				}
			},&quot; &quot;);
		}

		// reload
		createTiddlyText(e,&quot; | &quot;);
		config.macros.reloadIncluded.handler(e,&quot;&quot;,null,null,'urls:\'[&quot;'+includeUrl+'&quot;]\'',tiddler);

		// other actions

		// if the read only mode is not set, display all tools otherwise ...
		place.appendChild(e);
	}
	return config.extensions.SharedTiddlersPlugin.orig_editHandler(place,macroName,params,wikifier,paramString,tiddler);
};
//============================================================================
// The &quot;describeNode&quot; macro
//
// Syntax: &lt;&lt;describeNode nodeName {nodeUrl|self}&gt;&gt;
//
config.macros.describeNode = {};
config.macros.describeNode.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	var macroTWcode = wikifier.source.substring(wikifier.matchStart, wikifier.nextMatch);
	createTiddlyText(createTiddlyElement(place,&quot;code&quot;), macroTWcode);

	// node description duplicates are handled when adding, no &quot;handle only once&quot; here

	var includeURL = tiddler.getIncludeURL(),
	    nodeName = params[0],
	    urlParam = params[1],
	    self = (urlParam == &quot;self&quot;);

	if(self) {
		var oldSelf = twWeb.getSelfNodeName();
		if(oldSelf &amp;&amp; (oldSelf != nodeName))
			return alert(&quot;The \'&quot;+oldSelf+&quot;\' alias is already assigned as &quot;+
					&quot;the name of the current TiddlyWiki; the new &quot;+
					&quot;attempt to assign \'&quot;+nodeName+&quot;\' is ignored.&quot;);
		twWeb.setSelfNodeName(nodeName);
		return;
	}

	var url = resolveUrlFrom(urlParam, includeURL);
	url = stp_resolveURL(url); // if no includeURL

	twWeb.addNodeDesc(nodeName,url);
};

function calcImportOptions(modeOrOptions) {

	if(!modeOrOptions) return null;
	var options = typeof modeOrOptions != &quot;object&quot; ? // string or number
			{ mode: modeOrOptions } : modeOrOptions;
	if(!options.mode &amp;&amp; !options.which &amp;&amp; options.ask === undefined) return null;

	// other import options take precedence over mode, so one may go more specific
	if(options.which === undefined)
		options.which =
			options.mode in { 1:true, 3:true } ? 'all' :
			options.mode in { 2:true, 4:true } ? 'newer' :
			options.ask !== undefined ? 'all' : undefined
	if(options.ask === undefined)
		options.ask =
			options.mode in { 1:true, 2:true } ? false :
			options.mode in { 3:true, 4:true } ? true :
			options.which !== undefined ? false : undefined;
	else if(options.ask == 'false')
		options.ask = false;

	return options;
}

//============================================================================
// The &quot;include&quot; macro
//
// Syntax:	&lt;&lt;include [url:]url [filters:filterLine] [substitute]
//			  [substituteShadows] [hide:hideFlag] [delay:delayDuration]&gt;&gt;
//
config.macros.include = {};
config.macros.include.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	var macroTWcode = wikifier.source.substring(wikifier.matchStart, wikifier.nextMatch),
	    pParams = paramString.parseParams('url',null,true,false,true); // allowEval, cascadeDefaults, names allowed

	var hide = getFlag(pParams, 'hide', false) || params.contains('hide');
	if(!hide) createTiddlyText(createTiddlyElement(place, 'code'), macroTWcode);

	if (twWeb.includeUsages.isUsed(macroTWcode)) return;
	twWeb.includeUsages.setUsed(macroTWcode);

	var urls = pParams[0]['url'];

	var importOptions = calcImportOptions({
		mode:  getParam(pParams, 'import', undefined),
		which: getParam(pParams, 'importOnly', undefined),
		ask:   getParam(pParams, 'askBeforeImport', undefined)
	});

	var includeParams = {
		delayMilliSeconds:	parseInt(getParam(pParams,'delay',&quot;0&quot;)),
		filterLine:		getParam(pParams,'filter') ||
					getParam(pParams,'filters','[all[-]]'),
		substitute:		params.contains('substitute'),
		substituteShadows:	params.contains('substituteShadows'),
		noRefresh:		params.contains('noRefresh'),
		importOptions:		importOptions,
		evalTiddlers:		params.contains('eval'),
		wikifyTiddlers:		params.contains('wikify')
	};

	var checkUrlAndInclude = function(url)
	{
		if(url == 'hide' || url == 'substituteShadows' || url == 'substitute' ||
		   url == 'eval' || url == 'wikify' || url == 'noRefresh')
			return;

		twWeb.include(url,includeParams);
	};

	var placeParentHolder = place.parentElement;

	for (var i = 0; urls &amp;&amp; i &lt; urls.length; i++)
		checkUrlAndInclude(urls[i]);
	// here's a fix for the mysterious loss of the &quot;place&quot; of being a child of .. (kept in placeParentHolder)
	// reattach place to the placeParentHolder:
	if(placeParentHolder)
		placeParentHolder.appendChild(place);
		//placeParentHolder.getElementsByClassName('viewer')[0] = place;
};

//============================================================================
// The &quot;reloadIncluded&quot; macro
//
// Syntax: &lt;&lt;reloadIncluded [urls:urlsJSON] [reloadParams:otherReloadParamsJSON]
//		[label:labelText] [tooltip:tooltipText] [class:className]&gt;&gt;
// (for reloadParams, see twWeb.reload)
//
config.macros.reloadIncluded = {};
config.macros.reloadIncluded.handler = function(place,macroName,params,wikifier,paramString,tiddler) {

	// parse params
	var pParams = paramString.parseParams('url', null, true, false, true),
	    label    = getParam(pParams, 'label', &quot;refresh&quot;),
	    tooltip  = getParam(pParams, 'tooltip', undefined),
	    elClass  = getParam(pParams, 'class', ' '), // ' ' overwrites the default 'button' class
	    urlsText = getParam(pParams, 'urls', undefined),
	    otherReloadParamsText = getParam(pParams, 'reloadParams', '{}'),
	    reloadParams = JSON &amp;&amp; JSON.parse(otherReloadParamsText) || jQuery.parseJSON(otherReloadParamsText);
	reloadParams.urlOrNodeList = !urlsText ? undefined :
			(JSON &amp;&amp; JSON.parse(urlsText) || jQuery.parseJSON(urlsText));
	if(!tooltip) {
		if(reloadParams.urlOrNodeList) {
			tooltip = &quot;refresh '&quot;+reloadParams.urlOrNodeList[0]+&quot;'&quot;;
			for(var i = 1; i &lt; reloadParams.urlOrNodeList.length; i++)
				tooltip += &quot;, '&quot;+reloadParams.urlOrNodeList[i]+&quot;'&quot;;
			tooltip += (i &gt; 0) ? &quot; nodes&quot; : &quot; node&quot;;
		} else
			tooltip = &quot;refresh all included nodes&quot;;
	}

	// create button, add handler
	createTiddlyButton(place,label,tooltip,function() {
		var returnHere = function() {
			if(twWeb.hasPendingIncludes()) {
				invokeLater(returnHere,100);
				return;
			} // wait until all the stores are loaded and the page is refreshed
			var t = tiddler.title, te = DEFAULT_VIEW_TEMPLATE;
			story.displayTiddler(this,t,story.chooseTemplateForTiddler(t,te));
		}
		twWeb.reload(reloadParams);
		invokeLater(returnHere, 100); // wait a bit for the nodes to unload
	},elClass);
};

//============================================================================
// The &quot;includeState&quot; macro
//
// Syntax: &lt;&lt;includeState&gt;&gt;
//
config.macros.includeState = {};
config.macros.includeState.handler = function(place,macroName,params,wikifier,paramString,tiddler) {
	var getFullState = function () {
		var s = &quot;&quot;;
		var includes = twWeb.getIncludedStoresUrls();
		if (!includes.length)
			return &quot;{{noIncludes{\nNo TiddlyWiki is included or including is disabled (see AdvancedOptions)\n}}}\n&quot;;
			
		s += &quot;|!Address|!State|\n&quot;;
		for (var i = 0; i &lt; includes.length; i++) {
			var inc = includes[i];
			s += &quot;|{{{&quot;+inc+&quot;}}}|&quot;;
			var t = twWeb.getState(inc);
			s += t ? &quot;{{{&quot;+t+&quot;}}}&quot; : &quot;included&quot;;
			s += &quot;|\n&quot;
		}
		s += &quot;|includeState|k\n&quot;;
		return s;
	};
	
	var updateState = function() {
		removeChildren(div);
		wikify(getFullState(),div);
		if (twWeb.hasPendingIncludes())
			invokeLater(updateState,500,UPDATE_STATE_PRIORITY);
	};

	var div = createTiddlyElement(place, 'div');
	
	invokeLater(updateState,0,UPDATE_STATE_PRIORITY);
};
// Perform plugin startup tasks
attachToStore();
invokeLater(includeFromIncludeList,100);

// add several more methods to the &quot;API namespace&quot;
window.sharedTiddlersAPI.getIncludes  = twWeb.getIncludedStoresUrls;
window.sharedTiddlersAPI.getState     = twWeb.getState;
window.sharedTiddlersAPI.getStore     = twWeb.getStore;
window.sharedTiddlersAPI.importAndLog = twWeb.importAndLog;

// Deprecated: now is same as store.forEachTiddler (iterates over all tiddlers
// of &quot;the store&quot; and all tiddlers of included [and loaded] stores)
//
window.sharedTiddlersAPI.forReallyEachTiddler = function(callback) {
	store.forEachTiddler(callback);
};

// for the &quot;install only once&quot; check, prevents conflicts with abego.IncludePlugin as well
// (this is also deprecated API for backward compability)
abego.TiddlyWikiIncluder = {
	getIncludes:	twWeb.getIncludedStoresUrls,
	getState:	twWeb.getState,
	getStore:	twWeb.getStore
};
})();
//}}}</pre>
</div>
<div title="SharedTiddlersPluginInfo" creator="Yakov Litvin" modifier="Yakov Litvin" created="201208151641" modified="201905031858" changecount="313">
<pre>|Description|Documentation for [[SharedTiddlersPlugin|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPlugin]]|
|Source     |https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#SharedTiddlersPluginInfo|
|Author     |Yakov Litvin|
|Version    |2.5.1|
|Contact    |Create an [[issue|https://github.com/YakovL/TiddlyWiki_SharedTiddlersPlugin/issues]] or start a new thread in the [[Google Group|https://groups.google.com/g/tiddlywikiclassic/]] (please read docs, esp. &quot;Installation, configuring and troubleshooting&quot; section before asking)|
|License    |[[BSD-like open source license|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#%5B%5BYakov%20Litvin%20Public%20Licence%5D%5D]]|
&lt;&lt;tabs txtSharedTiddlersPluginInfoTab
	&quot;Installation, configuring and troubleshooting&quot; &quot;&quot; [[SharedTiddlersPluginInfo##Installation, configuring and troubleshooting]]
	&quot;Functionality and examples&quot; &quot;&quot; [[SharedTiddlersPluginInfo##Functionality and examples]]
	&quot;Detailed reference&quot; &quot;&quot; [[SharedTiddlersPluginInfo##Detailed reference]]
	&quot;More details on possible applications&quot; &quot;&quot; [[SharedTiddlersPluginInfo##More details on possible applications]]
	&quot;API changes and coding with SharedTiddlersPlugin&quot; &quot;&quot; [[SharedTiddlersPluginInfo##API changes and coding with SharedTiddlersPlugin]]
	{{&quot;Making other plugins \&quot;include-(un)aware\&quot;&quot;}} &quot;&quot; [[SharedTiddlersPluginInfo##Making other plugins include-(un)aware]]
	&quot;Versions history and quality issues&quot; &quot;&quot; [[SharedTiddlersPluginInfo##Versions history and quality issues]]
&gt;&gt;/%
!Functionality and examples
&lt;html&gt;&lt;h1&gt;Including and include macro&lt;/h1&gt;
&lt;h2&gt;Simple including&lt;/h2&gt;
&lt;/html&gt;Including is done via the {{{include}}} macro. For instance, a ~TiddlyWiki you'd like to include from is named {{{references.html}}} and is put in the same folder that another one, {{{main.html}}}, you'd like to include to. To include all the tiddlers from {{{references.html}}}, put the following macro in {{{main.html}}}:
{{{
&lt;&lt;include &quot;./references.html&quot;&gt;&gt;
}}}
Where exactly should you write the macro? Usually, {{{include}}} macros are written in IncludeList: all the macros in there are wikified at startup, so the secondary TW is included each time the main one is opened. Alternatively, you can put {{{include}}} macro in an arbitrary tiddler, in that case including will be done when the tiddler is displayed (wikified). If you want to avoid it being visible, write it as
{{{
&lt;&lt;include &quot;./references.html&quot; hide&gt;&gt;
}}}

&lt;html&gt;&lt;h2&gt;Partial including&lt;/h2&gt;
&lt;/html&gt;There are various reasons why you may prefer to include only a subset of tiddlers from another TW. For instance, you want to include only tiddlers tagged {{{ToDo}}} to your GTD thing and don't want the timeline to get crowded by other tiddlers from outside. For that case {{{include}}} macro supports core filter engine:
{{{
&lt;&lt;include &quot;./projects/myProject.html&quot; filters:&quot;[tag[ToDo]] [[Summary]]&quot;&gt;&gt;
}}}
For more details about filters, see the &quot;Detailed reference&quot; part of the docs.

&lt;html&gt;&lt;h2&gt;Substituting tiddlers in main TiddlyWiki&lt;/h2&gt;
&lt;/html&gt;By default, if the including and an included TW both have a tiddler named &quot;A&quot;, the tiddler from the main ~TiddlyWiki will be displayed/fetched in all the situations; even if in the main TW only a shadowed tiddler &quot;A&quot; is present. As sometimes this is not a desirable behaviour, there's {{{substitute}}} and {{{substituteShadows}}} options in the {{{include}}} macro:
{{{
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[[PageTemplate]] [[ViewTemplate]]&quot; substituteShadows&gt;&gt;
}}}
will bring PageTemplate and ViewTemplate instead of the shadowed ones; and
{{{
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[[PageTemplate]] [[ViewTemplate]]&quot; substituteShadows substitute&gt;&gt;
}}}
will do so even if custom PageTemplate or ViewTemplate are created. Note: included tiddlers are not saved in the including TW, unless the import options are used (see below).

&lt;html&gt;&lt;h2&gt;Import and autoimport of included tiddlers&lt;/h2&gt;
&lt;/html&gt;For some tiddlers, you may prefer importing instead of just including -- in this case you may use a &quot;manual&quot; tool ImportIncluded or autoimport via the {{{include}}} macro:
{{{
&lt;&lt;include &quot;./local_repositories/STP.html&quot; filters:&quot;[[SharedTiddlersPlugin]]&quot;
  importOnly:newer askBeforeImport:true&gt;&gt;
}}}
where {{{importOnly}}} may also be {{{all}}}. For details, see the &quot;Detailed reference&quot; part.

&lt;html&gt;&lt;h2&gt;Launching (wikifying) macros from included tiddlers&lt;/h2&gt;
&lt;/html&gt;This feature was designed primarily for centralized system of customization of ~TiddlyWikis. Imagine a TW called &quot;commons.html&quot; which has different parts of interface (like PageTemplate or ToolbarCommands), some evaluated transclusions etc. The idea is do changes to that TW so that they are applied in all your ~TWs. You can include all the elements in other ~TWs but the problem is you still have to make changes in all the ~IncludeLists. The solution is brought by introducing the {{{wikify}}} parameter to the {{{include}}} macro. Consider this: IncludeList in each of your ~TWs contains just
{{{
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[[IncludeHub]]&quot; wikify&gt;&gt;
}}}
and all the changes are done in the {{{IncludeHub}}} tiddler in your commons.html like these:
{{{
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[[PageTemplate]]&quot; substituteShadows&gt;&gt;
&lt;&lt;include &quot;./local_repositories/STP.html&quot; filters:&quot;[[SharedTiddlersPlugin]]&quot; import:4&gt;&gt;
 // you can remove, change or add macros in here so that they are applied in each of your TWs
}}}
The only issue is as long as you use relative addresses, you have to place all your ~TWs in the same folder as &quot;commons.html&quot; (how to pass around this limitation, see below).

&lt;html&gt;&lt;h2&gt;Launching plugins from included TiddlyWikis&lt;/h2&gt;
&lt;/html&gt;Plugin launching is done on startup, so just including external plugins is &quot;too late&quot; and they won't actually work. To launch a plugin from an included tiddler, use {{{eval}}} parameter of the {{{include}}} macro:
{{{
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[[RearrangeTiddlersPlugin]]&quot; eval&gt;&gt;
}}}
For many plugins, most likely, you will use both {{{improt:4}}} and {{{eval}}} parameters.

&lt;html&gt;&lt;h2&gt;Reloading included stuff&lt;/h2&gt;
&lt;/html&gt;Sometimes it's desirable to reload included tiddlers without reloading the whole TW document. For this case, the {{{reloadIncluded}}} macro was introduced. It generates a link/button which reloads tiddlers from certain ~TWs on click:
{{{
&lt;&lt;reloadIncluded urls:'[&quot;node: node1&quot;, &quot;included test nodes/node 2.html&quot;]' reloadParams:'{&quot;import&quot;:false}'&gt;&gt;
}}}
Also, this link can be found in the toolbar of included tiddlers (in the edit mode).

&lt;html&gt;&lt;h2&gt;Avoiding excessive refreshing&lt;/h2&gt;
&lt;/html&gt;After including, the {{{include}}} macro refreshes your TW -- this is done for things like ~StyleSheets or ~ViewTemplate to get applied. However, multiple refreshing on startup can take a second or more, so it can be desirable to avoid refreshing. It is recommended to use the corresponding {{{noRefresh}}} parameter with all {{{include}}} macros that don't need it (usually those including content tiddlers, but not elements of themes, like ~ViewTemplate):
{{{
&lt;&lt;include &quot;./references/holy writ.html&quot; filters:&quot;[[contents]] [tag[chapter]] [tag[verse]]&quot; noRefresh&gt;&gt;
&lt;&lt;include &quot;./references/Feuerbach.html&quot; filters:&quot;[[list of publications]] [tag[publication]]&quot; noRefresh&gt;&gt;
&lt;&lt;include &quot;./commons.html&quot; filters:&quot;[tag[theme parts]]&quot; substitute substituteShadows&gt;&gt;
}}}

&lt;html&gt;&lt;h1&gt;TwWeb&lt;/h1&gt;
&lt;/html&gt;Sometimes it is desirable to rename or move ~TiddlyWikis, and such changes can break many links/includes. Also, using relative paths in {{{include}}} macros can cause errors in the path calculation when the macro itself is contained in an tiddler included from &quot;path/A.html&quot;, where &quot;path&quot; is not &quot;.&quot;. To avoid these pesky issues and to enable further &quot;merging&quot; of ~TWs, ~TwWeb system was introduced.

&lt;html&gt;&lt;h2&gt;Describing a node&lt;/h2&gt;
&lt;/html&gt;The idea is to describe &quot;nodes&quot; -- ~TWs with certain addresses and then use node names instead of addresses. The {{{describeNode}}} does the first part of the job:
{{{
&lt;&lt;describeNode &quot;commons&quot; &quot;./commons.html&quot;&gt;&gt;
}}}
where the first argument is the name of the node and the second one is its address. It is recommended to give your nodes names without spaces (for compability with future features). Note that you can use {{{include}}} macro with {{{wikify}}} parameter to take node descriptions from another TW. This means that you can create a central TW with all node descriptions, include it, and use in all other ~TWs node names instead of addresses. After that, renaming a TW should be backed up by only changing the description in the central node.

&lt;html&gt;&lt;h2&gt;Support of node names&lt;/h2&gt;
&lt;/html&gt;Node names are supported in the following mechanisms:
# {{{include}}} macro can get a special form of the url parameter:{{jD{
{{{
&lt;&lt;include &quot;node: node_name&quot; ...&gt;&gt;
&lt;&lt;include &quot;node: commons&quot; filters:&quot;[tag[theme parts]]&quot; substitute substituteShadows&gt;&gt;
}}}
}}} If the macro is wikified before the node was described, it &quot;waits&quot; for the description to appear.
# ImportIncluded allows this &quot;form of url&quot; too
# the {{{includedFrom}}} filter supports the {{{[includedFrom[node: nodeName]]}}} notation
# extended prettyLinks now work in the following syntaxes:
## {{{[[link text|target tiddler]]@nodeName}}} -- which includes the {{{target tiddler}}} and creates an ordinary {{{[[link text|target tiddler]]}}} prettyLink
## {{{[[link text|target tiddler]]@nodeName@options line@}}} which does the same but uses options from the {{{options line}}} as well: for instance, to substitute an existing tiddler {{{target tiddler}}}, just add the options line {{{substitute}}}.
** if the included TW is large so you're delayed waiting when the link get enabled, it can be an option to include the node with an empty filter ({{{filters:&quot;&quot;}}}) using IncludeList (may be with the delay option, too)
* @@font-size:smaller;In the future versions of STP, some other engines may be supported: for instance, {{{&lt;&lt;tiddler [[tiddler name]]@nodeName&gt;&gt;}}}.@@

&lt;html&gt;&lt;h2&gt;Describing self&lt;/h2&gt;
&lt;/html&gt;To avoid different side effects of transitive inclusion (like including a tiddler by TW &quot;A&quot; from the same TW &quot;A&quot; with substituting which makes it impossible to edit the tiddler) you can mark one nodeName as &quot;self&quot;:
{{{
&lt;&lt;describeNode nodeName self&gt;&gt;
}}}
This prevents from including from {{{nodeName}}} at all; such self-description should be put into the IncludeList.

&lt;html&gt;&lt;h2&gt;Propagation&lt;/h2&gt;
&lt;/html&gt;As included tiddlers can contain links, images, transclusions etc, STP takes care of those so that they are not broken (to some extent). See details in the &quot;Detailed reference&quot; section.

&lt;html&gt;&lt;h2&gt;Inline management of included tiddlers&lt;/h2&gt;
&lt;/html&gt;In the edit mode an included (but not imported) tiddler has an additional panel with a link to its &quot;original&quot; in the included TW, a link which imports it and a refresh link that reloads the included TW. This is added by default, no changes to EditTemplate are needed.

!Detailed reference
&lt;html&gt;&lt;h2&gt;IncludeList tiddler&lt;/h2&gt;
&lt;/html&gt;Special tiddler IncludeList is used to wikify macros within it on the startup of ~TiddlyWiki: it's implied that you write {{{&lt;&lt;include&gt;&gt;}}} and {{{&lt;&lt;describeNode&gt;&gt;}}} macros that you need to lauch (each time) there. For instance, if you write
{{{
&lt;&lt;include &quot;./common TW elements.html&quot; filters:&quot;[[PageTemplate]]&quot; substituteShadows&gt;&gt;
}}}
in there, the including will be done each time the TW is opened.

&lt;html&gt;&lt;h2&gt;The &quot;include&quot; macro&lt;/h2&gt;
&lt;/html&gt;The {{{&lt;&lt;include&gt;&gt;}}} macro has the following syntax (@@font-size:smaller;[...] parts are optional@@):
{{{
&lt;&lt;include [url:]url [{filter|filters}:filterLine] [substitute] [substituteShadows]
  [import:importMode] [importOnly:checkType] [askBeforeImport:askFlag] [eval] [wikify] [noRefresh] [hide[:hideFlag]] [delay:delayDuration]&gt;&gt;
}}}
|The parameters of the {{{&lt;&lt;include&gt;&gt;}}} macro|c
| name			 | demanded?	 | value | effect | comments |h
| ''url''			 | demanded	 | a url line in quotes | defines the path to the ~TiddlyWiki from which stuff is included | by &quot;url line&quot; a relative path, an absolute local file path, or a &quot;file:&quot; URL is meant |
| ''filter'' or ''filters''	 | optional	 | a line of TW filters in quotes | defines the set of tiddlers included from the TW;&lt;br&gt;if omitted, means &quot;include all&quot; (the ''filter'' variant was introduced in 2.5.0) | see &quot;Filters&quot; below |
| ''substitute''		 | optional	 | none | adds &quot;substitute&quot; priority to the included tiddlers | see &quot;Name conflicts and priorities&quot; below |
| ''substituteShadows''	 | optional	 | none | adds &quot;substituteShadows&quot; priority to the included tiddlers |~|
| ''import''			 | optional	 | an id of an import mode to use | tiddlers are imported instead of including | see &quot;Import tools&quot; below |
| ''importOnly''		 | optional	 | &quot;all&quot; or &quot;newer&quot; | when a tiddler with the same title is already present in current TW, import or not? |~|
| ''askBeforeImport''	 | optional	 | boolean | ask per tiddler whether to import |~|
| ''eval''			 | optional	 | none | treats tiddlers as plugins | see &quot;Evaluating tiddlers&quot; below |
| ''wikify''			 | optional	 | none | wikifies tiddlers after loading/importing | can be used to wikify {{{include}}} and other macros;&lt;br&gt;may also be useful with evaluated transclusions |
| ''noRefresh''		 | optional	 | none | prevents refreshing of TW after tiddlers are loaded | refreshing is used to apply included style sheets, elements of interface etc, but multiple refreshing can slow down the startup time; to avoid such effects, this option is to be used in macros that include only content (not parts of the interface) |
| ''hide''			 | optional	 | boolean | by default the macro is displayed as written; when {{{hideFlag}}} is {{{true}}}, it's hidden | can be useful when the macro is used outside ~IncludeList |
| ''delay''			 | optional	 | number (integer) | defines the number of milliseconds (thousands of a second) to wait before actually including the ~TiddlyWiki ||
Some examples of how the ''url'' line can be written:
{{{
&lt;&lt;include &quot;C:\TiddlyWiki\shared\TiddlyWikiHelp.html&quot; hide:true&gt;&gt;
&lt;&lt;include &quot;file://C:/Private/journals/2006-12.html&quot; delay:8000&gt;&gt;
&lt;&lt;include &quot;../tests/STP/sample33.html&quot; hide&gt;&gt;
&lt;&lt;include &quot;tests/main_sample.html&quot;&gt;&gt;
}}}
__Note__: some browsers forbid including from outside the folder where the including TW is placed. See details in the &quot;Installation, configuring and troubleshooting&quot; section.

&lt;html&gt;&lt;h2&gt;Filters&lt;/h2&gt;
&lt;/html&gt;See main documentation [[at tiddlywiki.org|http://tiddlywiki.org/#Filters]]. Note: when the {{{tiddler}}} filter is used, if tiddler with {{{tiddlerName}}} doesn't exist, the filter creates a new empty tiddler and adds it to the set. To avoid problems like blank ~PageTemplate etc, tiddlers which don't exist are not included (or imported) even if the {{{tiddler}}} filter would cause otherwise.

STP introduces 4 new filters:
* {{{all}}} (mostly for inner purposes) which brings all the tiddlers of a store. Usage:
** {{{[all[with included]]}}} fetches ordinary and included tiddlers (with regard to &quot;substituting&quot;)
** {{{[all[-]]}}} (with any non-empty argument other than &quot;with included&quot;) fetches only ordinary tiddlers (without regard to &quot;substituting&quot;)
** Example: {{{[all[-]] [sort[modified]]}}}.
* {{{includedFrom}}} which retains only tiddlers from a certain included store. Examples: {{{[tag[ToDo]] [includedFrom[project.html]], [tag[ToDo]] [includedFrom[node: project]]}}}.
* {{{internal}}} which filters out included tiddlers. Example: {{{[tag[ToDo]] [internal[-]]}}}.
* {{{external}}} which leaves only included tiddlers. Example: {{{[all[with included]] [external[-]]}}}.

Example of usage with the {{{include}}} macro:
{{{
&lt;&lt;include &quot;./biology.html&quot; filters:&quot;[tag[Mammals]] [[Mammals]]&quot;&gt;&gt;
}}}

&lt;html&gt;&lt;h2&gt;Name conflicts and priorities&lt;/h2&gt;
&lt;/html&gt;Sometimes there are tiddlers with a common name in the main and an included or multiple included ~TiddlyWikis -- this may occur &quot;accidentally&quot; or because one needs to substitute a tiddler in the main ~TiddlyWiki by an included one (like shared ~PageTemplate). In such cases the following rules work:

* each tiddler in each store has or doesn't have some priorities which is defined when the tiddler is included
* shadowed tiddlers are substituted only by tiddlers with the &quot;substituteShadows&quot; priority
* tiddlers inside the main ~TiddlyWiki substitute those in included ones, unless those have &quot;substitute&quot; priority, in which case it is otherwise
* ({{{sh ambiguity}}}) if there are multiple tiddlers with &quot;substituteShadows&quot; and the shadow presents, there's no specific rule that defines which one would be fetched instead of the shadow; if the shadow with such name doesn't exist, those are treated as included tiddlers without &quot;substituteShadows&quot;
* ({{{s ambiguity}}}) if there are multiple tiddlers with &quot;substitute&quot;, the same thing applies: a &quot;random&quot; one is chosen (this actually depends on the order of the handling of {{{&lt;&lt;include&gt;&gt;}}} macros)
* ({{{ambiguity}}}) the same is true for tiddlers included with no added priorities

For tracking conflicts, a notification system is present:

* notifications appear if at least one of these parameters is set to {{{true}}} (see the &quot;tweak&quot; panel in the sidebar):
** {{{chkWarnOnSharedTiddlersConflicts}}} -- displays messages (this is usually interrupted by refreshing engines) and writes them to the browser console
** {{{chkAlertOnSharedTiddlersConflicts}}} -- alerts (in contrast to displaying messages, you won't lose this ones, but you have to click &quot;ok&quot; after each one, so this is to be used when setting up)
* for some reason (probably some page-refreshing called from out of the plugin) notifications are not displayed each time conflicts appear, or are removed too fast (when displaying fails logs and alerts can help)
* notifications are displayed in each case: {{{sh ambiguity}}}, {{{s ambiguity}}}, {{{ambiguity}}} and when there's a tiddler T in the main store and one tiddler with the same name in an included store without the &quot;substitute&quot; priority (in the last two cases the tiddler in the main store is also described as &quot;conflicting&quot; for the ease of understanding what's going on, despite the fact it is fetched for sure, not any included one)
* it is implied that shadows are not added after {{{&lt;&lt;include&gt;&gt;}}} macros are handled (otherwise some notifications will appear as in the {{{ambiguity}}} case while after a shadow is added it can become the {{{sh ambiguity}}})

&lt;html&gt;&lt;h2&gt;The &quot;reloadIncluded&quot; macro and reloading&lt;/h2&gt;
&lt;/html&gt;The {{{reloadIncluded}}} macro creates a &quot;link&quot; which causes reloading of the corresponding ~TWs: the content is unloaded and then previously wikified {{{include}}} macros are handled again. Syntax:
{{{
&lt;&lt;reloadIncluded [urls:urlsJSON] [reloadParams:otherReloadParamsJSON]
		[label:labelText] [tooltip:tooltipText] [class:className]&gt;&gt;
}}}
The {{{label}}} and {{{tooltip}}} parameters are sefl-explaining; {{{class}}} is html class added to the link (it's worth mentioning the {{{button}}} class which is used in macros like {{{tag}}} and {{{slider}}}). The other two parameters should be in the JSON format, like this (note the double quotes, esp. around {{{import}}}):
{{{
urls:'[&quot;node: node1&quot;, &quot;included test nodes/node 2.html&quot;]' reloadParams:'{&quot;import&quot;:false}'
}}}
The {{{urls}}} defines the ~TWs to reload (if not present, means &quot;reload all&quot;). The {{{reloadParams}}} part defines whether to wikify again {{{include}}} macros with the {{{import}}}/{{{wikify}}}/{{{eval}}} params, by default only {{{eval}}} is set to false to avoid repeated evaluation of shared plugins (and in this example {{{import}}} is set to {{{false}}} as well).

&lt;html&gt;&lt;h2&gt;The &quot;includeState&quot; macro&lt;/h2&gt;
&lt;/html&gt;The {{{&lt;&lt;includeState&gt;&gt;}}} macro can be used to see the progress of inclusion of ~TiddlyWikis (e.g. &quot;included&quot; for those already loaded, or a text of an error for others etc). There's a shadow IncludeState where you can see it in work.

&lt;html&gt;&lt;h2&gt;Import tools&lt;/h2&gt;
&lt;/html&gt;As some plugins and other tiddlers should be present inside each TW rather than be &quot;shared&quot; (like [[NestedSlidersPlugin|http://www.TiddlyTools.com/#NestedSlidersPlugin]], without which some content will be &quot;spoiled&quot;), STP provides tools to import/autoimport tiddlers from other ~TiddlyWikis.

{{{&lt;&lt;include&gt;&gt;}}} macro has the following params to support importing in different ways:
* {{{importOnly}}}: when a tiddler with the same title is already present in current TW, import or not? {{{all}}} = always import, {{{newer}}} = import only if the included one is newer than the present one ('modified' dates are compared)
* {{{askBeforeImport}}}: ask per tiddler whether to import (or import silently)? ({{{true}}} or {{{false}}})
* {{{import}}} [mode]: a short notation for the above options, one number to set both:
|{{{askBeforeImport}}} →	|{{{false}}}	 |{{{true}}}	 |
|{{{importOnly = all}}}	| 	1	 | 	3	 |
|{{{importOnly = newer}}}	| 	2	 | 	4	 |
* all params are optional, import is done if at least one of these params is used; default for {{{importOnly}}} is {{{all}}}, for {{{askBeforeImport}}} – {{{false}}}; if specified, {{{importOnly}}} and {{{askBeforeImport}}} overwrite their value defined by import mode
* mode {{{4}}} may be useful for autoupdating plugins from a central TW
The results of import are currently logged only in browser's console.

There are 3 ways to import:
* autoimport via the {{{include}}} macro (with one of the params above, import is done instead of including)
* to import a single included tiddler manually, press &quot;view&quot; in toolbar and then press &quot;import&quot;
* ImportIncluded shadow is a tool for manual batch import (allows to set a filter and import params)
Note: import doesn't cause autosaving, so you may want to save changes afterwards.

An example:
{{{
&lt;&lt;include &quot;./commons/plugins.html&quot; filter:&quot;[tag[commonInPlacePlugins]]&quot; import:4&gt;&gt;
}}}

&lt;html&gt;&lt;h2&gt;Evaluating tiddlers&lt;/h2&gt;
&lt;/html&gt;The {{{eval}}} parameter of the {{{&lt;&lt;include&gt;&gt;}}} macro allows to use plugins included from other ~TWs. For instance,
{{{
&lt;&lt;include &quot;commonPlugins.html&quot; filters:&quot;[[CollapseTiddlersPlugin]] [[RearrangeTiddlersPlugin]]&quot; eval&gt;&gt;
}}}
will load two plugins and evaluate them as ~JavaScript (they can be without {{{systemConfig}}} tag). In current implementation, some differences from the conventional way to launch plugins are present: plugins are not registered (no entries in the backstage), no dedicated reaction on errors; also, there's no check preventing some plugin to launch twice or more. Note: if evaluated, tiddlers still will be included or imported.

&lt;html&gt;&lt;h2&gt;&quot;include&quot; macros outside the IncludeList and transitive inclusion&lt;/h2&gt;
&lt;/html&gt;While {{{&lt;&lt;include&gt;&gt;}}} macros inside the ~IncludeList tiddler are handled at the startup, one can also place them in other tiddlers so that new parts are included when the tiddlers are displayed (the ''hide'' option can be useful here). This can save some time at startup; {{{&lt;&lt;include&gt;&gt;}}} macros outside ~IncludeList also provide the possibility of transitive inclusion (see below). However, sometimes opening a tiddler with an {{{&lt;&lt;include&gt;&gt;}}} macro can take several (mili)seconds.

When ~TiddlyWiki B is included to ~TiddlyWiki A, even if ~IncludeList is included with substitution, this won't bring tiddlers included to B in A, because the startup action is already done (see {{{wikifyIncluded}}} macro, though). However, it's possible to get &quot;transitive inclusion&quot; in the following meaning: add some tiddler with {{{&lt;&lt;include&gt;&gt;}}} in B (for instance, a tiddler &quot;Fruits&quot; with the follwing content:
{{{
All fruits: &lt;&lt;include &quot;./food.html&quot; filters:&quot;[tag[Fruit]]&quot; hide&gt;&gt;
&lt;&lt;tag [[Fruit]]&gt;&gt;
}}}
where &quot;./food.html&quot; is a third ~TiddlyWiki), then if you include this tiddler to A, you will get all the &quot;Fruit&quot;-tagged tiddlers included in A and the tiddler &quot;Fruits&quot; will be displayed as in B (*if* A and B are in the same directory -- otherwise the &quot;./food.html&quot; path will be incorrect in A).

&lt;html&gt;&lt;h2&gt;Including remote TiddlyWikis&lt;/h2&gt;
&lt;/html&gt;Although the documentation of the ~IncludePlugin sais that it's possible to include some remote ~TiddlyWikis into a local one, in modern browsers this seemingly no longer works (tested in IP 1.0.1 and STP 1.3 + Opera 12.0-16.0 and ~FireFox 13.0.1). On the other hand, when running a ~TiddlyWiki on a webserver, one can include ~TWs from the same domain, but can't include any TW from a different website (because of so-called &quot;~Cross-Site Scripting&quot; security issue). @@font-size:smaller;Including remote ~TiddlyWikis into a local one may be reintroduced in the future, but this requires changing the load engine which means some extensive search. Any feedback or ideas regarding this issue are particularly appreciated.@@

&lt;html&gt;&lt;h2&gt;Making secondary TiddlyWikis smaller&lt;/h2&gt;
&lt;/html&gt;In some cases included ~TWs can be supposed not to get changed (like archived pieces of journal or news) and be desired to be smaller (especially when placed at a web-site) at the same time. In such cases included ~TiddlyWikis can be reduced to the [[PureStore|https://yakovl.github.io/TiddlyWiki_SharedTiddlersPlugin/#PureStore]] format.

&lt;html&gt;&lt;h2&gt;The TwWeb and the describeNode macro&lt;/h2&gt;
&lt;/html&gt;The {{{describeNode}}} macro addes a description of a node (a ~TiddlyWiki) to the ~TwWeb. Minimal description consists of the name of the node and its address:
{{{
&lt;&lt;describeNode &quot;nodeName&quot; &quot;path to the node/file.html&quot;&gt;&gt;
}}}
Once a node is described, its name can be used instead of its url. This is supported in the {{{include}}} macro:
{{{
&lt;&lt;include &quot;node: nodeName&quot; ...&gt;&gt;
}}}
If such macro is wikified before the node was described, it &quot;waits&quot; for the description to appear. This syntax also can be used in the ImportIncluded.

Also, this is supported in the extended form of prettyLinks:
{{{
[[link text|target tiddler]]@nodeName
}}}
where {{{nodeName}}} contains alphanumeric symbols (latin letters, numbers and {{{_}}} symbols), is equivalent to
{{{
&lt;&lt;include &quot;node: nodeName&quot; filters:&quot;[[target tiddler]]&quot; hide noRefresh&gt;&gt;
[[link text|target tiddler]]
}}}
(except no linebreak is added) and
{{{
[[link text|target tiddler]]@nodeName@param string@
}}}
is equivalent to
{{{
&lt;&lt;include &quot;node: nodeName&quot; filters:&quot;[[target tiddler]]&quot; hide noRefresh param string&gt;&gt;
[[link text|target tiddler]]
}}}
where {{{param string}}} is copied &quot;as is&quot; (to get {{{import:4}}} option of the macro, write param string {{{import:4}}} etc). There's a limitation: {{{param string}}} is only recognized when consists of alphanumeric symbols, space symbols and {{{:}}} (so evaluated parameters are not allowed).

There's another function of the {{{describeNode}}} macro: when used like this
{{{
&lt;&lt;describeNode nodeName self&gt;&gt;
}}}
it sets the name {{{nodeName}}} as the name of the main ~TiddlyWiki. Any including from the node {{{nodeName}}} (which may be caused by an included tiddler) won't work. This only works once meaning that the following markup
{{{
&lt;&lt;describeNode nodeName1 self&gt;&gt;
&lt;&lt;describeNode nodeName2 self&gt;&gt;
}}}
will result in setting {{{nodeName1}}} as the name of the main TW and the second macro will alert about itseft but do nothing else.
----
By ~TwWeb a system that handles all the nodes stuff is meant (not to confuse with ~TiddlyWeb). ~TwWeb is a part of STP.

&lt;html&gt;&lt;h2&gt;Propagation&lt;/h2&gt;
&lt;/html&gt;STP prevents some parts of included tiddlers to get broken because they are in the context of the including TW, not the included one. What currently STP does:

* pretty links without {{{@nodeName}}} in included tiddlers, when displayed, cause including of corresponding tiddlers (so links are not broken). This is another part of the hijacking the &quot;prettyLink&quot; formatter and is optional (see &quot;Installation, configuring and troubleshooting&quot; section)
* image formatter ({{{[img[path][link]]}}} syntax) now takes care of relative links ({{{path}}} part is recalced from the including path). This is also optional, &quot;Installation, configuring and troubleshooting&quot; section.

What is not currently implemented:

* no macros are taken care of -- even a transclusion won't work if the corresponding tiddler is not explicitly included (and, of course, more complex macros like {{{tag}}} or {{{list}}})
* name conflicts are not handled: pretty links just cause including, and if there's a tiddler with the same name inside including TW, the priority system applies (deciding which one will be displayed on click)
* (auto)import doesn't account any of these things, including pretty links

Within these docs, such mechanisms are called &quot;propagation&quot; (of links, images etc).

&lt;html&gt;&lt;h2&gt;Inline management of included tiddlers&lt;/h2&gt;
&lt;/html&gt;In the edit mode an included tiddler has an additional panel to manage it. This is implemented by hijacking the {{{edit}}} macro, no changes to EditTemplate are needed. The panel has {{{manageIncludedPanel}}} that can be used for style settings.

!Installation, configuring and troubleshooting
&lt;html&gt;&lt;h2&gt;Installation&lt;/h2&gt;
&lt;/html&gt;First, put the plugin inside your ~TiddlyWiki. This is done as always: import the SharedTiddlersPlugin tiddler (using ImportTiddlers or another engine) or copy it (don't forget the {{{systemConfig}}} tag). You'll need to restart your ~TiddlyWiki (refresh the page) to get it working -- then you may check if it's installed properly in the PluginManager. You can also import or copy this documentation to have it at hand when needed.

If your TW has version below 2.6.2, you also have to install [[UpToDateFiltersPlugin|https://yakovl.github.io/TiddlyWiki_ExtraFilters/#UpToDateFiltersPlugin]] in the same fashion. Open TW source or use the {{{&lt;&lt;version&gt;&gt;}}} macro to reveal the version of your TW.

Second, add {{{&lt;&lt;include&gt;&gt;}}} macros to IncludeList and wherever you need them. As IncludeList is wikified when you view it, you don't need to restart the &quot;main&quot; ~TiddlyWiki, despite the fact that IncludeList is processed on startup. Add links, transclusions and other &quot;connections&quot; with included tiddlers, if necessary. Search, timeline, {{{&lt;&lt;tag&gt;&gt;}}} and other macros can be used as well.

Now you're ready to go. Remember that included tiddlers are readonly in the &quot;main&quot; ~TiddlyWiki, so you have to go to &quot;original&quot; ~TiddlyWikis to edit them.

&lt;html&gt;&lt;h2&gt;Settings&lt;/h2&gt;
&lt;/html&gt;You may need to change one of these settings:
* &lt;&lt;option chkUseInclude&gt;&gt; {{{chkUseInclude}}} option -- uncheck this and reload your ~TiddlyWiki to stop all inclusions
* &lt;&lt;option chkWarnOnSharedTiddlersConflicts&gt;&gt; {{{chkWarnOnSharedTiddlersConflicts}}} option -- defines whether notifications of conflicts should be displayed and logged
* &lt;&lt;option chkAlertOnSharedTiddlersConflicts&gt;&gt; {{{chkAlertOnSharedTiddlersConflicts}}} option -- defines whether alerting shoud be used for notifying about conflicts
* extending prettyLinks is optional, too; because the hijacking is done at startup, the option is hardcoded: to change it, go to SharedTiddlersPlugin and in the {{{config.options.STP_hijackPrettyLink = true;}}} set {{{false}}} instead
* such is extending of the image formatter ({{{[img[path][link]]}}}): it's governed by the {{{config.options.STP_hijackImageFormatter = ...}}} line in SharedTiddlersPlugin
These along with links to IncludeList, IncludeState and these documentation in the web can be found in AdvancedOptions.

&lt;html&gt;&lt;h2&gt;Troubleshooting&lt;/h2&gt;
&lt;/html&gt;If something goes wrong, you should check:
* core version of your TW: it must be no less than the ~CoreVersion value in the [[SharedTiddlersPlugin]]'s header. You can check it using the {{{&lt;&lt;version&gt;&gt;}}} macro. Also, if [[UpToDateFiltersPlugin|https://yakovl.github.io/TiddlyWiki_ExtraFilters/#UpToDateFiltersPlugin]] is not installed, it must be 2.6.2 or greater
* the PluginManager -- ~SharedTiddlersPlugin should be present there, be not Disabled, have no error log (if all of these is true, than the plugin is installed correctly); also, only one copy of ~SharedTiddlersPlugin or ~IncludePlugin should be installed
* if the plugin is installed correctly, inspect the {{{chkUseInclude}}} option -- should be checked for the plugin to work
* if the problem is not because of {{{chkUseInclude}}}, go to the IncludeState and see if any problems are reported there
** in some browsers there are additional security settings which can forbid loading other ~TWs, see [[Known Problems with Importing in TiddlyWiki|http://classic.tiddlywiki.com/#%5B%5BTiddlyWiki%20Browser%20Compatibility%5D%5D]] section at classic.tiddlywiki.com (it is about importing, but applies to &quot;including&quot; as well). Problems with ~FireFox seem to be solved by either updating to STP v1.5.0+ or TW v2.7.0+
* some browsers forbid including from outside the folder where the including TW is placed. According to tests, addresses containing &quot;..&quot; (container folder) work in Opera (12.15), Safari (5.0.3), IE (10.0) and don't work in ~FireFox (20.0), Chrome (26.0). In ~FireFox, this can be &quot;fixed&quot; by changing a security option: to do this, in the address bar type {{{about:config}}}, press enter, search for the {{{security.fileuri.strict_origin_policy}}} option and set it to {{{false}}} (fortunately, this works even in Android).
If the problem remains, you can search or post your issue in the [[community newsgroup|http://groups.google.com/group/tiddlywiki]] and if it's not solved, you can also notify the maintainer by email (don't forget to add the link to the thread).

!More details on possible applications
In general, ~SharedTiddlersPlugin can help with the following:
* reducing sizes of ~TiddlyWikis which can speed up saving TW and loading from the web, when used as a web-page/site
** examples: old journal/news tiddlers can &quot;archived&quot; into a separate TW monthly so that your diary/blog/site remains approximately the same size but old entries are easily accessible
* using common content in several ~TiddlyWikis
** like some glossary, or help texts about ~TiddlyWiki or some plugins (like ~SharedTiddlersPlugin which has this extensive documentation)
** in this case it's usually easy to avoid name conflicts -- just try to make sure that in the shared document tiddler names are specific enough
* using common interface
** ~PageTemplate, style sheets and other parts of ~TiddlyWiki theme can be shared (don't forget &quot;substitute&quot;/&quot;substituteShadows&quot; priorities, depending on what is present in a document you include those into)
*** all ~PageTemplate, ~StyleSheet, ~ViewTemplate, ~EditTemplate and ~ToolbarCommands are applied as expected; however, it is done by extra refreshing which causes already displayed messages to disappear (on handling of the {{{&lt;&lt;include&gt;&gt;}}} macro)
** included elements can also be used as parts of a custom theme (instead of substituting the default ones); style sheets can be included in the StyleSheet tiddler as well (by adding lines like {{{[[IncludedStyleSheet]]}}} into it)
** evaluated transclusions can be shared as well (and other stuff which is rendered as it shows, like {{{&lt;html&gt;}}}-insertions)
** finally, included plugins can be evaluated (see the &quot;Detailed reference&quot; part of this docs)
*** keep in mind that for some plugins it's more suitable to import them rather than include and evaluate
* aggregating content from other ~TWs
** ~SharedTiddlersPlugin can be used to get all tiddlers with &quot;~ToDo&quot; tag from all ~TiddlyWikis in a separate TW and other things like that
** usually this wouldn't require extra efforts, but if you expect name conflicts and need to get access to all the tiddlers (including different ones with the same name), check &quot;API changes and coding with ~SharedTiddlersPlugin&quot; section for details
** @@font-size:smaller;[currently unavailable, see &quot;Detailed reference&quot; section for details]@@ it's also can be useful to aggregate tiddlers from web (from online ~TiddlyWikis, like http://classic.tiddlywiki.com/index.html), which can bring you news from tiddly world or just from people you know who use ~TiddlyWiki; but remember the cross-site restriction
* finally, ~SharedTiddlersPlugin can be used to &quot;merge&quot; content of several ~TWs
** for instance, if you have a TW dedicated to science you're doing and a TW created for learning (at university or anyhow else), there definitely can appear some topics that belong to both wikis; it's rather weird thing to create new ~TiddlyWikis for each such topic, so you can keep tiddlers in one of them and include them to another for smoother workflow
** however, because included tiddlers are read-only, &quot;default&quot; workflow is not absolutely smooth as you'll need to go to the wiki containing tiddlers &quot;originally&quot; to change them

!API changes and coding with SharedTiddlersPlugin
&lt;html&gt;&lt;h2&gt;Accessing stores&lt;/h2&gt;
&lt;/html&gt;Each included ~TiddlyWiki is represented as a {{{TiddlyWiki}}} object, like the main one is. While for main ~TiddlyWiki it's the global {{{store}}} instance of {{{TiddlyWiki}}}, included ones can be accessed as following:
{{{
  var includedStore = window.sharedTiddlersAPI.getStore(tiddyWikiURL);
}}}
@@font-size:smaller;For backward compability, there's still {{{abego.TiddlyWikiIncluder.getStore(tiddyWikiURL)}}} method which is not recomended to use (see below).@@
Those included stores have only those tiddlers which are included (taking account of the ''filter'' parameters of {{{&lt;&lt;include&gt;&gt;}}} macros). Each of them has an additional property,
{{{
  var fullStore = includedStore.orig_store;
}}}
which is another {{{TiddlyWiki}}} that contains ''all'' the tiddlers of the included TW document.

The list of urls of all included ~TiddlyWikis can be accessed using the
{{{
  window.sharedTiddlersAPI.getIncludes()
}}}
method (it returns an array of strings – urls). Currently, this array contains urls exactly as they were written in {{{&lt;&lt;include&gt;&gt;}}} macros and, for instance, two macros with &quot;example included.html&quot; and &quot;example%20included.html&quot; urls create two different included stores.
@@font-size:smaller;For backward compability, there's also {{{abego.TiddlyWikiIncluder.getIncludes()}}} method which is not recomended to use (see below).@@

To get the state of a {{{store}}} (loaded, or some error occured when loading, etc), the
{{{
  window.sharedTiddlersAPI.getState(tiddyWikiURL)
}}}
method can be used. It returns {{{null}}} when the store is already loaded or a a state/error text otherwise.
@@font-size:smaller;For backward compability, there's also {{{abego.TiddlyWikiIncluder.getState(tiddyWikiURL)}}} method which is not recomended to use (see below).@@

&lt;html&gt;&lt;h2&gt;Accessing tiddlers&lt;/h2&gt;
&lt;/html&gt;As {{{TiddlyWiki}}} instances, both {{{includedStore}}} and {{{fullStore}}} in these examples have corresponding methods, like {{{fetchTiddler}}} etc.

Normally, however, one wouldn't use these direct methods. Instead, there's hijacked
{{{
  store.fetchTiddler(title)
}}}
which fetches a tiddler from the set of &quot;original&quot; and &quot;included&quot; ones taking into account the &quot;substituting&quot;. There's also
{{{
  window.sharedTiddlersAPI.forReallyEachTiddler(callback)
}}}
method which does the same thing as {{{store.forEachTiddler}}}, but &quot;iterates&quot; all the tiddlers taking into account the &quot;substituting&quot;. Main {{{store}}} methods {{{reverseLookup}}}, {{{updateTiddlers}}}, {{{getTags}}}, {{{getMissingLinks}}}, {{{getOrphans}}} are hijacked in the same way. Finally, already existing functions that use {{{store.forEachTiddler}}} can be modified so that it works as {{{sharedTiddlersAPI.forReallyEachTiddler}}} (see the &quot;Making other plugins &quot;include-aware&quot;&quot; section of these docs).

All original tiddlers from the main store can be accessed via the
{{{
  window.sharedTiddlersAPI.orig_fetchTiddler(title)
}}}
and the original (not hijacked)
{{{
  store.forEachTiddler(callback)
}}}

Notes:
* normally, the {{{window.}}} prefix can be omitted
* methods of {{{abego.TiddlyWikiIncluder}}} are retained so that users of ~IncludePlugin don't need to change their scripts if moving to ~SharedTiddlersPlugin. However, it is recomended that those methods are substituted with those from the {{{sharedTiddlersAPI}}} &quot;namespace&quot;.

&lt;html&gt;&lt;h2&gt;Included tiddlers&lt;/h2&gt;
&lt;/html&gt;With SharedTiddlersPlugin, tiddlers get a new property, the url of the store they were included from. It can be got by the {{{getIncludeURL()}}} method of the {{{Tiddler}}} object: it returns the url if the tiddler was included and {{{null}}} otherwise (if it's from the main {{{store}}}).

&lt;html&gt;&lt;h2&gt;Importing included tiddlers&lt;/h2&gt;
&lt;/html&gt;To easily import included tiddlers, the following function can be used:
{{{
window.sharedTiddlersAPI.importAndLog(tiddler, modeOrOptions)
}}}
It strips {{{includeURL}}} from the {{{tiddler}}}, imports it according to the mode/options (in the latter case {{{modeOrOptions.which}}} corresponds to {{{importOnly}}} param of {{{&lt;&lt;include&gt;&gt;}}}, {{{modeOrOptions.ask}}} – to {{{askBeforeImport}}}, also {{{modeOrOptions.mode}}} can be set) and logs the results in the browser console. If {{{modeOrOptions}}} is not passed, it defaults to {{{ { which: 'all', ask: false } }}}; other defaults and precedence are described in &quot;Detailed reference&quot; (&quot;Import tools&quot;).

&lt;html&gt;&lt;h2&gt;Examples&lt;/h2&gt;
&lt;/html&gt;(require &quot;demo-included/example included.html&quot; ~TiddlyWiki included):
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	url = &quot;demo-included/example included.html&quot;;
	var twStore = sharedTiddlersAPI.getStore(url);
	if(!twStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}

	displayMessage(&quot;Tiddlers:&quot;);
	twStore.forEachTiddler(function(title,tiddler) {
		usedTiddler = store.fetchTiddler(title);
		if(usedTiddler.getIncludeURL() == url)
	        	displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers included from the &quot;demo-included/example included.html&quot; store (with regard to priorities)&lt;/a&gt;&lt;/html&gt;
{{{
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	url = &quot;demo-included/example included.html&quot;;
	var twStore = sharedTiddlersAPI.getStore(url);
	if(!twStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}

	displayMessage(&quot;Tiddlers:&quot;);
	twStore.forEachTiddler(function(title,tiddler) {
		usedTiddler = store.fetchTiddler(title);
		if(usedTiddler.getIncludeURL() == url)
	        	displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers included from the &quot;demo-included/example included.html&quot; store (with regard to priorities)&lt;/a&gt;&lt;/html&gt;
}}}

&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var twStore = sharedTiddlersAPI.getStore(&quot;demo-included/example included.html&quot;);
	if(!twStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}
	displayMessage(&quot;Tiddlers:&quot;);
	twStore.forEachTiddler(function(title,tiddler) {
		displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers included from the &quot;demo-included/example included.html&quot; store, without regard to priorities&lt;/a&gt;&lt;/html&gt;
{{{
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var twStore = sharedTiddlersAPI.getStore(&quot;demo-included/example included.html&quot;);
	if(!twStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}
	displayMessage(&quot;Tiddlers:&quot;);
	twStore.forEachTiddler(function(title,tiddler) {
		displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers included from the &quot;demo-included/example included.html&quot; store, without regard to priorities&lt;/a&gt;&lt;/html&gt;
}}}

&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var includedStore = sharedTiddlersAPI.getStore(&quot;demo-included/example included.html&quot;);
	if(!includedStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}
	var realStore = includedStore.orig_store;
	var list = [];
	realStore.forEachTiddler(function(title,tiddler) {
		if(tiddler.modified &gt; new Date(&quot;July 1, 2007&quot;))
        		list.push(title);
	});
	if(list.length &gt; 0) {
		displayMessage(&quot;Tiddlers:&quot;);
		for(var i = 0; i &lt; list.length; i++)
			displayMessage(&quot;- &quot;+list[i]);
	} else
		displayMessage(&quot;No tiddlers changed after July 1st, 2007 were found&quot;);
'&gt;Show all tiddlers in the &quot;demo-included/example included.html&quot; store changed after July 1st, 2007&lt;/a&gt;&lt;/html&gt;
{{{
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var includedStore = sharedTiddlersAPI.getStore(&quot;demo-included/example included.html&quot;);
	if(!includedStore) {
		displayMessage(&quot;The store is not loaded&quot;);
		return;
	}
	var realStore = includedStore.orig_store;
	var list = [];
	realStore.forEachTiddler(function(title,tiddler) {
		if(tiddler.modified &gt; new Date(&quot;July 1, 2007&quot;))
        		list.push(title);
	});
	if(list.length &gt; 0) {
		displayMessage(&quot;Tiddlers:&quot;);
		for(var i = 0; i &lt; list.length; i++)
			displayMessage(&quot;- &quot;+list[i]);
	} else
		displayMessage(&quot;No tiddlers changed after July 1st, 2007 were found&quot;);
'&gt;Show all tiddlers in the &quot;demo-included/example included.html&quot; store changed after July 1st, 2007&lt;/a&gt;&lt;/html&gt;
}}}

&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	displayMessage(&quot;Tiddlers:&quot;);
	store.forEachTiddler(function(title,tiddler) {
		displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers in the main store (including substituted ones)&lt;/a&gt;&lt;/html&gt;
{{{
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	displayMessage(&quot;Tiddlers:&quot;);
	store.forEachTiddler(function(title,tiddler) {
		displayMessage(&quot;- &quot;+title);
	});
'&gt;Show all tiddlers in the main store (including substituted ones)&lt;/a&gt;&lt;/html&gt;
}}}

[[Check an included tiddler|Example of a tiddler in the included tw-document]], &lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var mode = 4,
	    tiddler = store.fetchTiddler(&quot;Example of a tiddler in the included tw-document&quot;);
	// the tiddler is supposed to be included already
	sharedTiddlersAPI.importAndLog(tiddler, mode);
'&gt;import it&lt;/a&gt;&lt;/html&gt;, then check it again.
{{{
&lt;html&gt;&lt;a href=&quot;javascript:;&quot; onclick='
	var mode = 4,
	    tiddler = store.fetchTiddler(&quot;Example of a tiddler in the included tw-document&quot;);
	// the tiddler is supposed to be included already
	sharedTiddlersAPI.importAndLog(tiddler, mode);
'&gt;import it&lt;/a&gt;&lt;/html&gt;
}}}
See also ImportIncluded tiddler for another example of &quot;importing&quot; included tiddlers.

!Making other plugins include-(un)aware
In versions before 2.5.0, ~SharedTiddlersPlugin made some core methods &quot;aware&quot; of included stores while plugins that use {{{store.forEachTiddler}}} directly had to get certain patches to be &quot;aware&quot;. ''Since 2.5.0, this is no longer needed'', {{{store.forEachTiddler}}} is changed globally. Old patches won't break anything since

* {{{config.extensions.SharedTiddlersPlugin.getFunctionUsingForReallyEachTiddler(myFunction)}}} now returns {{{myFunction}}} without changes
* {{{config.extensions.SharedTiddlersPlugin.useForReallyEachTiddler(myObject,method)}}} now just returns {{{myObject[method]}}} (doesn't modify anything)

If, for some reason, you need a function behave like there's no included tiddlers/stores (most likely you won't need this), you can apply a patch to implement this.

To understand the implementation, let's note that to make external tiddlers usable, STP basically does 3 things:

* hijackes the {{{fetchTiddler}}} method of the main {{{store}}} object
* hijackes the {{{forEachTiddler}}} method of the main {{{store}}} object
* &quot;recalcs&quot; slices by deleting them

So, you can provide a &quot;context&quot; to a function where the first 2 are undone:
{{{
var orig_myFunction = myFunction;
myFunction = function() {
	// undo changes by STP
	var updated_forEachTiddler = store.forEachTiddler;
	var updated_fetchTiddler = store.fetchTiddler;
	store.forEachTiddler = window.sharedTiddlersAPI.orig_forEachTiddler;
	store.fetchTiddler = window.sharedTiddlersAPI.orig_fetchTiddler;

	var result = orig_myFunction.apply(this,arguments);

	// restore changes by STP
	store.forEachTiddler = updated_forEachTiddler;
	store.fetchTiddler = updated_fetchTiddler;
}
}}}
Recalcing the slices is also possible (you can manipulate {{{store.slices}}} before and after calling {{{orig_myFunction}}}), but is rarely needed.

Finally, the patch will work correctly only if it is used after STP is launched and {{{myFunction}}} is defined, so you have to add it into your plugin after {{{myFunction}}} and add a {{{|Requires|SharedTiddlersPlugin|}}} slice.

!Versions history and quality issues
&lt;html&gt;&lt;h2&gt;Version history&lt;/h2&gt;&lt;/html&gt;
* 2.5.0 (1.05.2019)
** improved plugin installation (checks if already installed, shows in PluginManager/sidebar etc)
** removed the necessity of making plugins &quot;include-aware&quot;
** {{{include}}} macro: introduced {{{importOnly}}}, {{{askBeforeImport}}} params; {{{filter}}} param which is the same as {{{filters}}}
** added a button to show link to included tiddler in its origianl location (in the no-edit mode of the tiddler)
** dropped support of TW below 2.7.0, reduced code size using up-to-date helpers
** various fixes (including handling images wrapped into a link like {{{[img[path][link]]}}}, handling prettyLinks to tiddlers with {{{'}}} or {{{&quot;}}} in title from other ~TWs like {{{[[tiddler having &quot;]]@someNode}}}) and refactoring
* 2.4.0 (10.09.2013)
** introduced the {{{reloadIncluded}}} macro
** filters: added {{{external}}}, added {{{node: nodeName}}} syntax support to {{{includedFrom}}}, fixed a bug in {{{includedFrom}}} and {{{internal}}}
** fixed {{{hijackImageFormatter}}} for cases when the image is not inside a tiddler
** some code refactoring, including &quot;internal&quot; interfaces
** some minor quality issues in the conflict notification system are introduced (like doubling messages in rare cases), to be fixed in the next versions
** {{{wikifyIncluded}}} macro is ''completely removed'' (no notifications are now provided)
* 2.3.0 (15.06.2013)
** implemented new modes of import (2, 3)
** ImportIncluded now supports modes, &quot;node: nodeName&quot; syntax and got several fixes
** propagation of including is introduced for pretty links and images
** managing included tiddlers panel got the &quot;import&quot; button (link)
* 2.2.0 (30.05.2013)
** implemented the {{{&lt;&lt;describeNode nodeName self&gt;&gt;}}} syntax and ban of including from the node marked self
** added a panel for managing inluded tiddlers inside their edit mode (now contains a link to the tiddler in its &quot;source&quot; ~TiddlyWiki)
* 2.1.0 (13.05.2013)
** introduced the support of {{{[[text|tiddler]]@node}}} links
** removed functionality from the {{{wikifyIncluded}}} macro (only a notification remains)
** extended the {{{all}}} filter so that {{{[all[with included]]}}} filter brings all tiddlers accounting included ones
** fixed 'a.fetchTiddler is not a function' bug which appeared in FF, in TW 2.6.5, when a TW from outside the current folder (../some path) was tried to include (now {{{.getStore}}} method works correctly in such cases as well)
* 2.0.0 (1.05.2013)
** introduced ~TwWeb, {{{describeNode}}} macro, added support of node names to the {{{include}}} macro
** added {{{wikify}}} parameter to the {{{include}}} macro; deprecated {{{wikifyIncluded}}} macro and added a notification that pops when it is used
** some minor fixes and improvements
** major documentation update, added simplified &quot;Functionality and examples&quot; section, changed the structure of sections
* the 2.x.x series are dedicated to content managing and interaction, to ~TwWeb
* 1.6.1 (8.03.2013)
** added {{{noRefresh}}} parameter to the {{{include}}} macro
** added {{{internal}}} filter
** fixed a bug preventing ImportIncluded engine to work
** documentation improvements, added description of the {{{window.sharedTiddlersAPI.importAndLog(tiddler,mode)}}} method
* 1.6.0 (13.02.2013)
** added evaluation of tiddlers via the {{{include}}} macro with the new {{{eval}}} parameter
** added filters {{{all}}} and {{{includedFrom}}}; now in TW 2.6.1 or elder STP requires [[UpToDateFiltersPlugin|https://yakovl.github.io/TiddlyWiki_ExtraFilters/#UpToDateFiltersPlugin]]
** {{{allTiddlersAreLoaded}}} parameter is no longer added to stores, no need to check it (but old {{{if(allTiddlersAreLoaded)}}} code pieces to get all tiddlers should work)
** {{{hide}}} parameter of the {{{include}}} macro now can be used without trailing {{{:true}}}
** some fixes and code improvements, better API documentation
* 1.5.0 (11.01.2013)
** solved problems in ~FireFox, now including works in TW 2.6.0
** added autoimport via the {{{include}}} macro
** added import modes and setting the {{{store}}} as {{{dirty}}} on import
** added &quot;protection&quot; from including non-existing tiddlers (caused by the {{{tiddler}}} filter)
** some fixes, code improvments
* 1.4.4 (6.12.2012)
** slices are now &quot;recalced&quot;, substituted ~ToolbarCommands is now applied as expected
** the {{{include}}} macro is now launched only once (per session) with each used exact &quot;wording&quot;, so no loop because of refreshing is now possible
** substituted ~ViewTemplate is now refreshed on including
** {{{wikifyIncluded}}} now doesn't make infinite loops, control parameters are added
** making some abego plugins &quot;include-aware&quot; is removed from the code; howTo make any plugin &quot;include-aware&quot; is added to docs
** some minor fixes/enhancements, documentation improvments, added minified version of the plugin
* 1.4.3 (21.11.2012)
** alerting on conflicts controled by {{{chkAlertOnSharedTiddlersConflicts}}} parameter is introduced
** many improvments of code and update of documentation (including corrections in the &quot;Name conflicts and priorities&quot; section) are done
* 1.4.2 (wasn't published)
** introduced the {{{wikifyIncluded}}} macro
** introduced the &quot;importing&quot; engine (ImportIncluded)
* 1.4.1 (wasn't published)
** included ~PageTemplate is now applied
** the issue with the &quot;orphans&quot; list is fixed, the issue with the &quot;missing&quot; list is partially fixed
** {{{window.sharedTiddlersAPI.orig_forEachTiddler}}} is removed as the {{{store.forEachTiddler}}} is not actually hijacked
** documentation is updated
* 1.4.0 (29.09.2012)
** removed the {{{abego}}} namespace where possible, added {{{window.sharedTiddlersAPI}}} object and moved all (but some deprecated) API there, reduced the scope of some internal functions
* 1.3.0 (wasn't published)
** notifications of conflicts were added
** theme is refreshed when an inclusion is done so that included style sheets and templates are applied right away
* 1.2.0 (wasn't published)
** substitute and substituteShadows possibilities were added
* 1.1.0 (wasn't published)
** filtering was added
* forked from [[IncludePlugin|http://tiddlywiki.abego-software.de/#IncludePlugin]] v1.0.1, by Udo Borkowski
&lt;html&gt;&lt;h2&gt;Current quality issues&lt;/h2&gt;&lt;/html&gt;
* some tiddlers in the main store, referenced in included tiddlers, appear in the &quot;missing&quot; list
!%/&lt;&lt;tiddler {{setStylesheet('div[tiddler=&quot;SharedTiddlersPluginInfo&quot;] .tabContents { background-color:'+store.getTiddlerText('ColorPalette::Background')+'; }', 'STPInfoCSS');'';}}&gt;&gt;</pre>
</div>
<div title="SideBarOptions" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261528" changecount="1">
<pre>&lt;&lt;search&gt;&gt;&lt;&lt;closeAll&gt;&gt;&lt;&lt;permaview&gt;&gt;&lt;&lt;slider chkSliderOptionsPanel SideBarOptions##OptionsPanel &quot;options »&quot; &quot;Change TiddlyWiki advanced options&quot;&gt;&gt;/%
!OptionsPanel
&lt;&lt;option chkRegExpSearch&gt;&gt; [[RegExpSearch]]
&lt;&lt;option chkCaseSensitiveSearch&gt;&gt; [[CaseSensitiveSearch]]
&lt;&lt;option chkAnimate&gt;&gt; [[EnableAnimations]]
----
Also see [[AdvancedOptions]]
!%/</pre>
</div>
<div title="SimplifiedUpgradingPlugin" modifier="Yakov Litvin" created="202307200748" modified="202307200749" tags="systemConfig systemConfigDisable" changecount="1">
<pre>/***
|Description|Makes upgrading work ~correctly with (at least) Timimi or MTS 1.7.0 and above (tested on 2.6.5,2.9.2,2.9.3 → 2.9.3,2.9.4), adds optional upgrade autocheck on start; adds tiddlers and fields sorting so that the changes are easier to review|
|Source     |https://github.com/YakovL/TiddlyWiki_SimplifiedUpgradingPlugin/blob/master/SimplifiedUpgradingPlugin.js|
|Author     |Yakov Litvin|
|Version    |0.6.0|
|License    |[[MIT|https://github.com/YakovL/TiddlyWiki_YL_ExtensionsCollection/blob/master/Common%20License%20(MIT)]]|
Installation of this plugin is standard: create tiddler, paste this as text, tag with {{{systemConfig}}}, save, reload.

To start upgrading, use the usual way: open backstage, the &quot;upgrade&quot; tab and hit the &quot;upgrade&quot; button.

Configuration:
&lt;&lt;option txtWaitSavingSeconds&gt;&gt; &quot;wait saving&quot; interval (seconds) may need adjustments for big ~TWs (otherwise, you should check that after reloading the new version is opened: if not, try to reload again)
&lt;&lt;option chkReloadManually&gt;&gt; reload manually (don't reload automatically after saving upgraded TW)
&lt;&lt;option chkAutocheckUpgradeOnStart&gt;&gt; check for upgrades on start
***/
//{{{
config.options.txtWaitSavingSeconds = config.options.txtWaitSavingSeconds || &quot;5&quot;; // no handler for number options

// a fix for older TWs, like 2.7.1
if(config.macros.upgrade.source == 'http://tiddlywiki-releases.tiddlyspace.com/upgrade')
	config.macros.upgrade.source = 'https://classic.tiddlywiki.com/upgrade/'

var upgradingEventBus = {
	handlers: {},
	// no &quot;off&quot; method, no array of handlers for now
	on: function(name, handler) {
		this.handlers[name] = handler
	},
	fire: function(name, params) {
		if(this.handlers[name]) this.handlers[name](params)
	}
}

config.macros.simplifiedUpgrade = {
	lingo: {
		isBackupCreatedQuestion: &quot;Have you made a backup?&quot;,
		makeBackupCall: &quot;Please make sure you have a backup before upgrading&quot;,
		unsupportedMtsVersionMessage: &quot;Simplified upgrading in MainTiddlySaver below 1.7.0 is not made to work properly, aborting now&quot;,
		failedToLoadCore: &quot;Something went wrong when loading core!&quot;,
		simplifiedUpgradingDissallowed: &quot;The new core indicates that simplified upgrading is dangerous, please use import of your TW into a new empty TW instead&quot;,
		versionNotNewer: &quot;The available core is not newer than the current one&quot;,
		getUpgradeFinishedReloadMessage: function() {
			return &quot;Upgrading finished, &quot; + (config.options.chkReloadManually ?
				&quot;reload page to have the changes applied&quot; :
				&quot;will reload page to have the changes applied&quot;)
		},
		upgradeMacro: {
			statusUpgrading: &quot;building upgraded TW and saving...&quot;,
			statusUpgradedTwSaved: &quot;upgraded TW saved, should reload now&quot;,
			getUpgradeAvailableMessage: function(version) {
				return &quot;An upgrade to TiddlyWiki v&quot; + formatVersion(version) + &quot; is available&quot;
			}
		}
	},
	start: function(newCoreString) {
		// don't upgrade without a backup
		if(!confirm(this.lingo.isBackupCreatedQuestion)) {
			alert(this.lingo.makeBackupCall)
			return
		}

		// once MTS supports upgrading, here we will check MTS version instead [or feature-detect]
		var isMainTiddlyServerUsed = !!window.saveOnlineChanges ||
			(window.tiddlyBackend &amp;&amp; tiddlyBackend.version &amp;&amp; tiddlyBackend.version.title == 'MainTiddlyServer')
		if(isMainTiddlyServerUsed) {
			// for now, we assume that 1.7.0 supports upgrading (this is a matter of testing), so we don't check tiddlyBackend.version.asString
			var doesMtsSupportUpgrading = !!window.tiddlyBackend
			if(!doesMtsSupportUpgrading) {
				alert(this.lingo.unsupportedMtsVersionMessage)
				return
			}
		}

		var me = this
		if(newCoreString) {
			this.proceedWithLoadedCore(newCoreString)
		}
		else this.getNewCore(function(newCoreString) {
			upgradingEventBus.fire(&quot;available-core-loaded&quot;)
			me.proceedWithLoadedCore(newCoreString)
		}, this.onCoreLoadFail)
	},
	// onSuccess(newCoreString), onProblem(jqXHR, textStatus, errorThrown)
	getNewCore: function(onSuccess, onProblem) {
		var up = config.macros.upgrade
		var url = up.getSourceURL ? up.getSourceURL() : config.options.txtUpgradeCoreURI || up.source
		ajaxReq({
			type: &quot;GET&quot;,
			url: url,
			processData: false,
			success: onSuccess,
			error: onProblem
		})
	},
	onCoreLoadFail: function(jqXHR, textStatus, errorThrown) {
		upgradingEventBus.fire(&quot;available-core-loading-failed&quot;)
		alert(config.macros.simplifiedUpgrade.lingo.failedToLoadCore)
	},
	getSavingWaitMillisecondsInterval: function() {
		return 1000 * parseFloat(config.options.txtWaitSavingSeconds)
	},
	overrides: {},
	// main idea: make sure loadOriginal or its async analogs will return the new core, then just save
	proceedWithLoadedCore: function(newCoreString) {
		var me = config.macros.simplifiedUpgrade
		if(newCoreString.indexOf(&quot;simplifiedUpgradingDisallowed&quot;) != -1) {
			alert(me.lingo.simplifiedUpgradingDissallowed)
			return
		}
		var availableVersion = config.macros.upgrade.extractVersion(newCoreString)
		if(compareVersions(version, availableVersion) !== 1) {
			displayMessage(me.lingo.versionNotNewer)
			return
		}

		// MainTiddlyServer: avoid granulated saving (won't change core)
		me.overrides.chkAvoidGranulatedSaving = config.options.chkAvoidGranulatedSaving
		config.options.chkAvoidGranulatedSaving = true

		me.overrides.loadOriginal = loadOriginal
		loadOriginal = function loadOriginal(localPath, callback) {
			if(!callback) return newCoreString
			callback(newCoreString)
		}
		// MTS 1.7.0
		if(window.tiddlyBackend) {
			me.overrides.tiddlyBackend_loadOriginal = tiddlyBackend.loadOriginal
			tiddlyBackend.loadOriginal = function(onSuccess) {
				onSuccess(newCoreString)
			}
		}

		saveChanges()
		// restore overrides
		loadOriginal = me.overrides.loadOriginal
		if(me.overrides.tiddlyBackend_loadOriginal) tiddlyBackend.loadOriginal = me.overrides.tiddlyBackend_loadOriginal
		config.options.chkAvoidGranulatedSaving = me.overrides.chkAvoidGranulatedSaving

		// wait so that saving finishes
		setTimeout(function() {
			upgradingEventBus.fire(&quot;upgraded-tw-saved&quot;)
			me.finalize()
		}, me.getSavingWaitMillisecondsInterval())
	},
	finalize: function() {
		var me = config.macros.simplifiedUpgrade
		alert(me.lingo.getUpgradeFinishedReloadMessage())
		if(!config.options.chkReloadManually) {
			window.location.reload()
		}
	}
}

merge(config.macros.upgrade, config.macros.simplifiedUpgrade.lingo.upgradeMacro)

config.macros.upgrade.onLoadCore = function(status, params, responseText, url, xhr) {

	var me = config.macros.upgrade
	var w = params
	var errMsg = !status ? me.errorLoadingCore : undefined
	var newVer = me.extractVersion(responseText)
	if(!newVer) errMsg = me.errorCoreFormat
	if(errMsg) {
		w.setButtons([], errMsg)
		alert(errMsg)
		return
	}

	// the overridden bit
	var onStartUpgrade = function(e) {
		w.setButtons([], me.statusUpgrading)
		upgradingEventBus.on(&quot;upgraded-tw-saved&quot;, function() {
			w.setButtons([], me.statusUpgradedTwSaved)
		})
		config.macros.simplifiedUpgrade.start(responseText)
	}

	var step2 = [me.step2Html_downgrade, me.step2Html_restore, me.step2Html_upgrade][compareVersions(version, newVer) + 1];
	w.addStep(me.step2Title, step2.format([formatVersion(newVer), formatVersion(version)]));
	w.setButtons([
		{ caption: me.startLabel, tooltip: me.startPrompt, onClick: onStartUpgrade },
		{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }
	])
}

var isBelow2_9_3 = compareVersions(version, { major: 2, minor: 9, revision: 3 }) === 1
var isAbove2_9_3 = compareVersions(version, { major: 2, minor: 9, revision: 3 }) === -1

// support upgrading regardless the whitespace after '{' (extra spaces were in 2.9._)
if(isBelow2_9_3) {
	config.macros.upgrade.extractVersion = function(upgradeFile) {
		var re = /version = \{\s*title: &quot;([^&quot;]+)&quot;, major: (\d+), minor: (\d+), revision: (\d+)(, beta: (\d+)){0,1}, date: new Date\(&quot;([^&quot;]+)&quot;\)/mg
		var m = re.exec(upgradeFile)
		return !m ? null : {
			title: m[1], major: m[2], minor: m[3], revision: m[4], beta: m[6], date: new Date(m[7])
		}
	}
}

// fix the bug introduced in 2.9.3 and fixed in 2.9.4 version
if(!isAbove2_9_3) {
	// not present before 2.9.2
	config.macros.upgrade.getSourceURL = function() {
		return config.options.txtUpgradeCoreURI || config.macros.upgrade.source
	}

	config.macros.upgrade.onClickUpgrade = function(e)
	{
		var me = config.macros.upgrade
		var w = new Wizard(this)
		if(window.allowSave &amp;&amp; !window.allowSave()) {
			alert(me.errorCantUpgrade)
			return false
		}
		if(story.areAnyDirty() || store.isDirty()) {
			alert(me.errorNotSaved)
			return false
		}

		w.setButtons([], me.statusPreparingBackup)
		var localPath = getLocalPath(document.location.toString())
		var backupPath = getBackupPath(localPath, me.backupExtension)
		var original = loadOriginal(localPath)

		w.setButtons([], me.statusSavingBackup)
		var backupSuccess = copyFile(backupPath, localPath) || saveFile(backupPath, original)
		//# fails of backup saving with TF are not reported, resulting in empty TW after upgrade
		if(!backupSuccess) {
			w.setButtons([], me.errorSavingBackup)
			alert(me.errorSavingBackup)
			return false
		}
		w.setValue(&quot;backupPath&quot;, backupPath)

		w.setButtons([], me.statusLoadingCore)
		var sourceURL = me.getSourceURL()
		ajaxReq({
			type: &quot;GET&quot;,
			url: sourceURL,
			processData: false,
			success: function(data, textStatus, jqXHR) {
				me.onLoadCore(true, w, jqXHR.responseText, sourceURL, jqXHR)
			},
			error: function(jqXHR, textStatus, errorThrown) {
				me.onLoadCore(false, w, null, sourceURL, jqXHR)
			}
		})
		return false
	}
}

// auto-checking available upgrade
config.macros.upgrade.init = function() {
	config.macros.simplifiedUpgrade.getNewCore(function(coreAsText) {
		var me = config.macros.upgrade
		var availableVersion = me.extractVersion(coreAsText)
		if(compareVersions(version, availableVersion) !== 1) return
		if(config.options.chkAutocheckUpgradeOnStart) {
			displayMessage(me.getUpgradeAvailableMessage(availableVersion))
		}
	})
}

if(!isAbove2_9_3) {
	SaverBase.prototype.externalize = function(store) {
		var results = [];
		var i, tiddlers = store.getTiddlers(&quot;title&quot;);
		if(!config.options.chkAvoidSortingAll) {
			tiddlers.sort(function(t1, t2) {
				return t1.title.localeCompare(t2.title)
			});
		}
		for(i = 0; i &lt; tiddlers.length; i++) {
			if(!tiddlers[i].doNotSave())
				results.push(this.externalizeTiddler(store, tiddlers[i]));
		}
		return results.join(&quot;\n&quot;);
	};

	TW21Saver.prototype.externalizeTiddler = function(store, tiddler)
	{
		try {
			var usePre = config.options.chkUsePreForStorage;
			var created = tiddler.created;
			var modified = tiddler.modified;
			var tags = tiddler.getTags();
			var attributes =
				(tiddler.creator ? ' creator=&quot;' + tiddler.creator.htmlEncode() + '&quot;' : &quot;&quot;) +
				(tiddler.modifier ? ' modifier=&quot;' + tiddler.modifier.htmlEncode() + '&quot;' : &quot;&quot;) +
				((usePre &amp;&amp; created == version.date) ? &quot;&quot; : ' created=&quot;' + created.convertToYYYYMMDDHHMM() + '&quot;') +
				((usePre &amp;&amp; modified == created) ? &quot;&quot; : ' modified=&quot;' + modified.convertToYYYYMMDDHHMM() + '&quot;') +
				((!usePre || tags) ? ' tags=&quot;' + tags.htmlEncode() + '&quot;' : &quot;&quot;);
			//# todo: check if these changes (sort extended attributes so that the order is always the same) affect performance, commit
			var extendedAttributes = [];
			store.forEachField(tiddler, function(tiddler, fieldName, value) {
				if(typeof value != &quot;string&quot;)
					value = &quot;&quot;;
				// don't store fields from the temp namespace
				if(!fieldName.match(/^temp\./))
					extendedAttributes.push('%0=&quot;%1&quot;'.format([fieldName, value.escapeLineBreaks().htmlEncode()]));
			}, true);
			if(!config.options.chkAvoidSortingAll) {
				extendedAttributes.sort();
			}
			//# avoid closing div tags for _
			return ('&lt;div %0=&quot;%1&quot;%2%3&gt;%4&lt;/' + 'div&gt;').format([
				usePre ? &quot;title&quot; : &quot;tiddler&quot;,
				tiddler.title.htmlEncode(),
				attributes,
				' ' + extendedAttributes.join(' '),
				usePre ? &quot;\n&lt;pre&gt;&quot; + tiddler.text.htmlEncode() + &quot;&lt;/pre&gt;\n&quot; : tiddler.text.escapeLineBreaks().htmlEncode()
			]);
		} catch (ex) {
			throw exceptionText(ex, config.messages.tiddlerSaveError.format([tiddler.title]));
		}
	};
}
//}}}</pre>
</div>
<div title="SiteSubtitle" creator="Yakov Litvin" modifier="Yakov Litvin" created="201210271932" modified="201210271932" changecount="2">
<pre>a tool for sharing tiddlers between ~TiddlyWikis</pre>
</div>
<div title="SiteTitle" creator="Yakov Litvin" modifier="Yakov Litvin" created="201210271928" changecount="1">
<pre>~SharedTiddlersPlugin</pre>
</div>
<div title="StyleSheet" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261613" tags="code" changecount="1">
<pre>/*{{{*/
.viewer		{ margin: 0% 0% 15% 0%; }	/* separate tiddlers with some space;
						   also, this space allows to scroll page so that the bottom
						   thing would be on the level of eyes the of the reader */
table.tcenter	{ margin : 0 auto; }

/* make font monospace in the editor mode for tiddlers with code (CSS, JavaScript etc) */
div[tags~=&quot;code&quot;]				/* usage: add tag &quot;code&quot; to the tiddler */
.editor		{ font-family: monospace; }
/*}}}*/</pre>
</div>
<div title="ToolbarCommands" creator="Yakov Litvin" modifier="Yakov Litvin" created="201309261548" modified="201309291843" changecount="2">
<pre>|~ViewToolbar|closeTiddler closeOthers +editTiddler  permalink jump &gt; fields references deleteTiddler|
|~EditToolbar|+saveTiddler -cancelTiddler references deleteTiddler|</pre>
</div>
<div title="Web include test" creator="Titan" modifier="Yakov Litvin" created="201206271350" modified="201611272134" changecount="11">
<pre>&lt;&lt;include &quot;http://classic.tiddlywiki.com/index.html&quot;&gt;&gt;
&quot;&quot;&quot;&lt;&lt;include &quot;http://tiddlywiki.abego-software.de/index.html&quot;&gt;&gt;&quot;&quot;&quot;

Можно ли включать содержимое удалённых tw-документов с помощью STP?
* Ситуация такая: вообще говоря, нет -- из-за проблем безопасности ([[Cross-Site Scripting|http://en.wikipedia.org/wiki/Cross-Site_Scripting]]); чтобы было можно, {{DDnc{нужно настраивать CORS, но и это не панацея}}}
* В документации написано, что не включаются &quot;некоторые&quot;, в т.ч. если используемая TW находится на сайте (т.е. к ней обращаются по http/https), то нельзя включать tw-документы с других сайтов, но можно включать tw-страницы с других сайтов в локальном tw-документе или со своего сайта -- на своём же сайте.
* {{DDn{На практике не удалось включить ни одного удалённого tw-документа}}}. Пробовал:{{justDiv{
{{{ &lt;&lt;include &quot;http://www.remotely-helpful.com/TiddlyWiki/TiddlerEncryptionPlugin.html&quot;&gt;&gt; }}} -- про него выдаётся сообщение, что всё не так
{{{ &lt;&lt;include &quot;http://visualtw.ouvaton.org/VisualTW.html&gt;&gt; }}} -- сообщение не появляется
{{{ &lt;&lt;include &quot;http://tiddlier.narod.ru/index.html&quot;&gt;&gt; }}} -- снова пишут сообщение об ошибке}}}</pre>
</div>
<div title="Yakov Litvin Public Licence" creator="Yakov Litvin" modifier="Yakov Litvin" created="201209051623" modified="201308282251" changecount="7">
<pre>Yakov Litvin Public Licence Version 0.3
----
Copyright (c) 2013, Yakov Litvin

This software includes work of abego Software distributed under &lt;&lt;slider &quot;&quot; [[Yakov Litvin Public Licence##abego licence]] &quot;the following license&quot; &quot;&quot;&gt;&gt;/%
!abego licence
{{{
abego Public Licence Version 1.0

Copyright (c) 2006, abego Software GmbH (http://www.abego-software.de)

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of abego Software nor the names of its contributors may be
  used to endorse or promote products derived from this software without specific
  prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
}}}
!%/

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
<!--POST-STOREAREA-->
<!--POST-BODY-START-->

<!--POST-BODY-END-->
<script id="jsArea" type="text/javascript">
//<![CDATA[

//
// Please note:
//
// * This code is designed to be readable but for compactness it only includes brief comments. You can see fuller comments
//   in the project repository at https://github.com/TiddlyWiki/tiddlywiki
//
// * You should never need to modify this source code directly. TiddlyWiki is carefully designed to allow deep customisation
//   without changing the core code. Please consult the development group at http://groups.google.com/group/TiddlyWikiDev
//
// JSLint directives
/*global jQuery:false, version:false */
/*jslint bitwise:true, browser:true, confusion:true, eqeq:true, evil:true, forin:true, maxerr:100, plusplus:true, regexp:true, sloppy:true, sub:true, undef:true, unparam:true, vars:true, white:true */

//--
//-- Global tw object (window.tw) exposing available methods and structures for developers
//--

window.tw = {
	assets: {
		icons: {}
	},
	io: {},
	textUtils: {}
};

//--
//-- Configuration repository
//--

// Miscellaneous options
var config = {
	numRssItems: 20, // Number of items in the RSS feed
	animDuration: 400, // Duration of UI animations in milliseconds
	cascadeFast: 20, // Speed for cascade animations (higher == slower)
	cascadeSlow: 60, // Speed for EasterEgg cascade animations
	cascadeDepth: 5, // Depth of cascade animation
	locale: "en" // W3C language tag
};

// Hashmap of alternative parsers for the wikifier
config.parsers = {};

config.adaptors = {};
config.defaultAdaptor = null;

// defines the order of the backstage tasks
config.backstageTasks = ["save", "importTask", "tweak", "upgrade", "plugins"];
// map by names from config.backstageTasks, defines their content (see Lingo.js and Backstage.js)
config.tasks = {};

config.annotations = {};

// Custom fields to be automatically added to new tiddlers
config.defaultCustomFields = {};

config.messages = {
	messageClose: {},
	dates: {},
	tiddlerPopup: {}
};

// Options that can be set in the options panel and/or cookies
config.options = {
	chkAnimate: true,
	chkAutoSave: false,
	chkBackstage: false,
	chkCaseSensitiveSearch: false,
	chkConfirmDelete: true,
	chkDisplayInstrumentation: false,
	chkForceMinorUpdate: false,
	chkGenerateAnRssFeed: false,
	chkHttpReadOnly: true,
	chkIncrementalSearch: true,
	chkInsertTabs: false,
	chkOpenInNewWindow: true,
	chkPreventAsyncSaving: true,
	chkRegExpSearch: false,
	chkRemoveExtraMarkers: false, // #162
	chkSaveBackups: true,
	chkSaveEmptyTemplate: false,
	chkSliderOptionsPanel: false,
	chkToggleLinks: false,
	chkUsePreForStorage: true, // Whether to use <pre> format for storage
	txtBackupFolder: "",
	txtEditorFocus: "text",
	txtFileSystemCharSet: "UTF-8",
	txtMainTab: "tabTimeline",
	txtMaxEditRows: "30",
	txtMoreTab: "moreTabAll",
	txtTheme: "",
	txtUpgradeCoreURI: ""
};
config.optionsDesc = {};

config.optionsSource = {};

// Default tiddler templates
var DEFAULT_VIEW_TEMPLATE = 1;
var DEFAULT_EDIT_TEMPLATE = 2;
config.tiddlerTemplates = {
	1: "ViewTemplate",
	2: "EditTemplate"
};

// More messages (rather a legacy layout that should not really be like this)
config.views = {
	wikified: {
		tag: {}
	},
	editor: {
		tagChooser: {}
	}
};

config.extensions = {};

// Macros; each has a 'handler' member that is inserted later
config.macros = {
	today: {},
	version: {},
	search: { sizeTextbox: 15 },
	tiddler: {},
	tag: {},
	tags: {},
	tagging: {},
	timeline: {},
	allTags: {},
	list: {
		all: {},
		missing: {},
		orphans: {},
		shadowed: {},
		touched: {},
		filter: {}
	},
	closeAll: {},
	permaview: {},
	saveChanges: {},
	slider: {},
	option: {},
	options: {},
	newTiddler: {},
	newJournal: {},
	tabs: {},
	gradient: {},
	message: {},
	view: { defaultView: "text" },
	edit: {},
	tagChooser: {},
	toolbar: {},
	plugins: {},
	refreshDisplay: {},
	importTiddlers: {},
	upgrade: {
		source: "https://classic.tiddlywiki.com/upgrade/",
		backupExtension: "pre.core.upgrade"
	},
	sync: {},
	annotations: {}
};

// Commands supported by the toolbar macro
config.commands = {
	closeTiddler: {},
	closeOthers: {},
	editTiddler: {},
	saveTiddler: { hideReadOnly: true },
	cancelTiddler: {},
	deleteTiddler: { hideReadOnly: true },
	permalink: {},
	references: { type: "popup" },
	jump: { type: "popup" },
	syncing: { type: "popup" },
	fields: { type: "popup" }
};

// Control of macro parameter evaluation
config.evaluateMacroParameters = "all";

// Basic regular expressions
var isBadSafari = !((new RegExp("[\u0150\u0170]", "g")).test("\u0150")); //# see 52678d4 and #22  ..remove at all?
config.textPrimitives = {
	upperLetter: "[A-Z\u00c0-\u00de\u0150\u0170]",
	lowerLetter: "[a-z0-9_\\-\u00df-\u00ff\u0151\u0171]",
	anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]",
	anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]"
};
// Moved navigator dependent code out of Config.js into a separate module. Helps with https://github.com/TiddlyWiki/tiddlywiki/issues/22
if(isBadSafari) {
	config.textPrimitives = {
		upperLetter: "[A-Z\u00c0-\u00de]",
		lowerLetter: "[a-z0-9_\\-\u00df-\u00ff]",
		anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff]",
		anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff]"
	};
}
config.textPrimitives.sliceSeparator = "::";
config.textPrimitives.sectionSeparator = "##";
config.textPrimitives.urlPattern =
	"(?:file|http|https|mailto|ftp|irc|news|data):[^\\s'\"]+(?:/|\\b|\\[|\\])"; // #132
config.textPrimitives.unWikiLink = "~";
config.textPrimitives.wikiLink = "(?:(?:" + config.textPrimitives.upperLetter + "+" +
	config.textPrimitives.lowerLetter + "+" +
	config.textPrimitives.upperLetter +
	config.textPrimitives.anyLetter + "*)|(?:" +
	config.textPrimitives.upperLetter + "{2,}" +
	config.textPrimitives.lowerLetter + "+))";

config.textPrimitives.cssLookahead = "(?:(" + config.textPrimitives.anyLetter +
	"+)\\(([^\\)\\|\\n]+)(?:\\):))|(?:(" + config.textPrimitives.anyLetter + "+):([^;\\|\\n]+);)";
config.textPrimitives.cssLookaheadRegExp = new RegExp(config.textPrimitives.cssLookahead, "mg");

config.textPrimitives.brackettedLink = "\\[\\[([^\\]]+)\\]\\]";
config.textPrimitives.titledBrackettedLink = "\\[\\[([^\\[\\]\\|]+)\\|([^\\[\\]\\|]+)\\]\\]";
config.textPrimitives.tiddlerForcedLinkRegExp =
	new RegExp("(?:" + config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" +
	config.textPrimitives.urlPattern + ")", "mg");
config.textPrimitives.tiddlerAnyLinkRegExp =
	new RegExp("(" + config.textPrimitives.wikiLink + ")|(?:" +
	config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" +
	config.textPrimitives.urlPattern + ")", "mg");

config.glyphs = {
	currBrowser: null,
	browsers: [],
	codes: {}
};

//--
//-- Shadow tiddlers
//--

config.shadowTiddlers = {
	StyleSheet: "",
	MarkupPreHead: "",
	MarkupPostHead: "",
	MarkupPreBody: "",
	MarkupPostBody: "",
	TabTimeline: '<<timeline>>',
	TabAll: '<<list all>>',
	TabTags: '<<allTags excludeLists>>',
	TabMoreMissing: '<<list missing>>',
	TabMoreOrphans: '<<list orphans>>',
	TabMoreShadowed: '<<list shadowed>>',
	AdvancedOptions: '<<options>>',
	PluginManager: '<<plugins>>',
	SystemSettings: '',
	ToolbarCommands: '|~ViewToolbar|closeTiddler closeOthers +editTiddler > fields permalink references jump|\n' +
		'|~EditToolbar|+saveTiddler -cancelTiddler deleteTiddler|', // #160
	WindowTitle: '<<tiddler SiteTitle>> - <<tiddler SiteSubtitle>>'
};

// Browser detection... In a very few places, there's nothing else for it but to know what browser we're using.
config.userAgent = navigator.userAgent.toLowerCase();
config.browser = {
	isIE: config.userAgent.indexOf("msie") != -1 && config.userAgent.indexOf("opera") == -1,
	isGecko: navigator.product == "Gecko" && config.userAgent.indexOf("WebKit") == -1,
	// config.browser.ieVersion[1], if it exists, will be the IE version string, eg "6.0"
	ieVersion: /MSIE (\d{1,2}.\d)/i.exec(config.userAgent),
	isSafari: config.userAgent.indexOf("applewebkit") != -1,
	isBadSafari: !((new RegExp("[\u0150\u0170]", "g")).test("\u0150")),
	// config.browser.firefoxDate[1], if it exists, will be Firefox release date as "YYYYMMDD"
	firefoxDate: /gecko\/(\d{8})/i.exec(config.userAgent),
	isOpera: config.userAgent.indexOf("opera") != -1,
	isChrome: config.userAgent.indexOf('chrome') > -1,
	isLinux: config.userAgent.indexOf("linux") != -1,
	isUnix: config.userAgent.indexOf("x11") != -1,
	isMac: config.userAgent.indexOf("mac") != -1,
	isWindows: config.userAgent.indexOf("win") != -1
};

merge(config.glyphs, {
	browsers: [
		function() { return config.browser.isIE },
		function() { return true }
	],
	codes: {
		downTriangle: ["\u25BC", "\u25BE"],
		downArrow: ["\u2193", "\u2193"],
		bentArrowLeft: ["\u2190", "\u21A9"],
		bentArrowRight: ["\u2192", "\u21AA"]
	}
});

//--
//-- Translateable strings
//--

// Strings in "double quotes" should be translated; strings in 'single quotes' should be left alone

merge(config.options, {
	txtUserName: "YourName"
});

merge(config.tasks, {
	save: { text: "save", tooltip: "Save your changes to this TiddlyWiki" },
	importTask: { text: "import", tooltip: "Import tiddlers and plugins " +
		"from other TiddlyWiki files and servers", content: '<<importTiddlers>>' },
	tweak: { text: "tweak", tooltip: "Tweak the appearance and behaviour of TiddlyWiki", content: '<<options>>' },
	upgrade: { text: "upgrade", tooltip: "Upgrade TiddlyWiki core", content: '<<upgrade>>' },
	plugins: { text: "plugins", tooltip: "Manage installed plugins", content: '<<plugins>>' }
});

// Options that can be set in the options panel and/or cookies
merge(config.optionsDesc, {
	chkAnimate: "Enable animations",
	chkAutoSave: "Automatically save changes",
	chkCaseSensitiveSearch: "Case-sensitive searching",
	chkConfirmDelete: "Require confirmation before deleting tiddlers",
	chkIncrementalSearch: "Incremental key-by-key searching",
	chkInsertTabs: "Use the tab key to insert tab characters instead of moving between fields",
	chkForceMinorUpdate: "Don't update modifier username and date when editing tiddlers",
	chkGenerateAnRssFeed: "Generate an RSS feed when saving changes",
	chkHttpReadOnly: "Hide editing features when viewed over HTTP",
	chkOpenInNewWindow: "Open external links in a new window",
	chkPreventAsyncSaving: "Disable attempting async saving (may be needed by old plugins)",
	chkRegExpSearch: "Enable regular expressions for searches",
	chkSaveBackups: "Keep backup file when saving changes",
	chkSaveEmptyTemplate: "Generate an empty template when saving changes",
	chkToggleLinks: "Clicking on links to open tiddlers causes them to close",
	txtBackupFolder: "Name of folder to use for backups",
	txtFileSystemCharSet: "Default character set for saving changes (Firefox/Mozilla only)",
	txtMaxEditRows: "Maximum number of rows in edit boxes",
	chkRemoveExtraMarkers: "Replace unused transclusion markers with blanks", // #162
	txtTheme: "Name of the theme to use",
	txtUpgradeCoreURI: "Custom URI to download TiddlyWiki core from (when upgrading)",
	txtUserName: "Username for signing your edits"
});

merge(config.messages, {
	customConfigError: "Problems were encountered loading plugins. See PluginManager for details",
	pluginError: "Error: %0",
	pluginDisabled: "Not executed because disabled via 'systemConfigDisable' tag",
	pluginForced: "Executed because forced via 'systemConfigForce' tag",
	pluginVersionError: "Not executed because this plugin needs a newer version of TiddlyWiki",
	nothingSelected: "Nothing is selected. You must select one or more items first",
	savedSnapshotError: "It appears that this TiddlyWiki has been incorrectly saved. Please see https://classic.tiddlywiki.com/#SaveUnpredictabilities for details",
	subtitleUnknown: "(unknown)",
	undefinedTiddlerToolTip: "The tiddler '%0' doesn't yet exist",
	shadowedTiddlerToolTip: "The tiddler '%0' doesn't yet exist, but has a pre-defined shadow value",
	tiddlerLinkTooltip: "%0 - %1, %2",
	externalLinkTooltip: "External link to %0",
	noTags: "There are no tagged tiddlers",
	notFileUrlError: "You need to save this TiddlyWiki to a file before you can save changes",
	cantSaveError: "It's not possible to save changes. Possible reasons include:\n- your browser doesn't support saving (Firefox, Internet Explorer, Safari and Opera all work if properly configured)\n- the pathname to your TiddlyWiki file contains illegal characters\n- the TiddlyWiki HTML file has been moved or renamed",
	invalidFileError: "The original file '%0' does not appear to be a valid TiddlyWiki",
	backupSaved: "Backup saved",
	backupFailed: "Failed to save backup file",
	rssSaved: "RSS feed saved",
	rssFailed: "Failed to save RSS feed file",
	emptySaved: "Empty template saved",
	emptyFailed: "Failed to save empty template file",
	mainSaved: "TiddlyWiki saved",
	mainDownload: "Downloading/saving main TiddlyWiki file",
	mainDownloadManual: "RIGHT CLICK HERE to download/save main TiddlyWiki file",
	mainFailed: "Failed to save main TiddlyWiki file. Your changes have not been saved",
	macroError: "Error in macro <<%0>>",
	macroErrorDetails: "Error while executing macro <<%0>>:\n%1",
	missingMacro: "No such macro",
	overwriteWarning: "A tiddler named '%0' already exists. Choose OK to overwrite it",
	unsavedChangesWarning: "WARNING! There are unsaved changes in TiddlyWiki\n\nChoose OK to save\nChoose CANCEL to discard",
	confirmExit: "--------------------------------\n\nThere are unsaved changes in TiddlyWiki. If you continue you will lose those changes\n\n--------------------------------",
	saveInstructions: "SaveChanges",
	unsupportedTWFormat: "Unsupported TiddlyWiki format '%0'",
	tiddlerSaveError: "Error when saving tiddler '%0'",
	tiddlerLoadError: "Error when loading tiddler '%0'",
	wrongSaveFormat: "Cannot save with storage format '%0'. Using standard format for save.",
	invalidFieldName: "Invalid field name %0",
	fieldCannotBeChanged: "Field '%0' cannot be changed",
	loadingMissingTiddler: "Attempting to retrieve the tiddler '%0' from the '%1' server at:\n\n'%2' in the workspace '%3'",
	upgradeDone: "The upgrade to version %0 is now complete\n\nClick 'OK' to reload the newly upgraded TiddlyWiki",
	invalidCookie: "Invalid cookie '%0'"
});

merge(config.messages.messageClose, {
	text: "close",
	tooltip: "close this message area"
});

config.messages.backstage = {
	open: { text: "backstage", tooltip: "Open the backstage area to perform authoring and editing tasks" },
	close: { text: "close", tooltip: "Close the backstage area" },
	prompt: "backstage: ",
	decal: {
		edit: { text: "edit", tooltip: "Edit the tiddler '%0'" }
	}
};

config.messages.listView = {
	tiddlerTooltip: "Click for the full text of this tiddler",
	previewUnavailable: "(preview not available)"
};

config.messages.dates.months = ["January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December"];
config.messages.dates.days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
config.messages.dates.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
config.messages.dates.shortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
// suffixes for dates, eg "1st","2nd","3rd"..."30th","31st"
config.messages.dates.daySuffixes = [
	"st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th",
	"th", "th", "th", "th", "th", "th", "th", "th", "th", "th",
	"st", "nd", "rd", "th", "th", "th", "th", "th", "th", "th",
	"st"
];
config.messages.dates.am = "am";
config.messages.dates.pm = "pm";

merge(config.messages.tiddlerPopup, {});

merge(config.views.wikified.tag, {
	labelNoTags: "no tags",
	labelTags: "tags: ",
	openTag: "Open tag '%0'",
	tooltip: "Show tiddlers tagged with '%0'",
	openAllText: "Open all",
	openAllTooltip: "Open all of these tiddlers",
	popupNone: "No other tiddlers tagged with '%0'"
});

merge(config.views.wikified, {
	defaultText: "The tiddler '%0' doesn't yet exist. Double-click to create it",
	defaultModifier: "(missing)",
	shadowModifier: "(built-in shadow tiddler)",
	dateFormat: "DD MMM YYYY",
	createdPrompt: "created"
});

merge(config.views.editor, {
	tagPrompt: "Type tags separated with spaces, [[use double square brackets]] if necessary, or add existing",
	defaultText: "Type the text for '%0'"
});

merge(config.views.editor.tagChooser, {
	text: "tags",
	tooltip: "Choose existing tags to add to this tiddler",
	popupNone: "There are no tags defined",
	tagTooltip: "Add the tag '%0'"
});

merge(config.messages, {
	sizeTemplates: [
		{ unit: 1024 * 1024 * 1024, template: "%0\u00a0GB" },
		{ unit: 1024 * 1024, template: "%0\u00a0MB" },
		{ unit: 1024, template: "%0\u00a0KB" },
		{ unit: 1, template: "%0\u00a0B" }
	]
});

merge(config.macros.search, {
	label: "search",
	prompt: "Search this TiddlyWiki",
	placeholder: "",
	accessKey: "F",
	successMsg: "%0 tiddlers found matching %1",
	failureMsg: "No tiddlers found matching %0"
});

merge(config.macros.tagging, {
	label: "tagging: ",
	labelNotTag: "not tagging",
	tooltip: "List of tiddlers tagged with '%0'"
});

merge(config.macros.timeline, {
	dateFormat: "DD MMM YYYY"
});

merge(config.macros.allTags, {
	tooltip: "Show tiddlers tagged with '%0'",
	noTags: "There are no tagged tiddlers"
});

config.macros.list.all.prompt = "All tiddlers in alphabetical order";
config.macros.list.missing.prompt = "Tiddlers that have links to them but are not defined";
config.macros.list.orphans.prompt = "Tiddlers that are not linked to from any other tiddlers";
config.macros.list.shadowed.prompt = "Tiddlers shadowed with default contents";
config.macros.list.touched.prompt = "Tiddlers that have been modified locally";

merge(config.macros.closeAll, {
	label: "close all",
	prompt: "Close all displayed tiddlers (except any that are being edited)"
});

merge(config.macros.permaview, {
	label: "permaview",
	prompt: "Link to an URL that retrieves all the currently displayed tiddlers"
});

merge(config.macros.saveChanges, {
	label: "save changes",
	prompt: "Save all tiddlers to create a new TiddlyWiki",
	accessKey: "S"
});

merge(config.macros.newTiddler, {
	label: "new tiddler",
	prompt: "Create a new tiddler",
	title: "New Tiddler",
	accessKey: "N"
});

merge(config.macros.newJournal, {
	label: "new journal",
	prompt: "Create a new tiddler from the current date and time",
	accessKey: "J"
});

merge(config.macros.options, {
	wizardTitle: "Tweak advanced options",
	step1Title: "These options are saved in cookies in your browser",
	step1Html: "<input type='hidden' name='markList'></input><br>" +
		"<label><input type='checkbox' checked='false' name='chkUnknown'>Show unknown options</label>",
	unknownDescription: "//(unknown)//",
	listViewTemplate: {
		columns: [
			{ name: 'Option', field: 'option', title: "Option", type: 'String' },
			{ name: 'Description', field: 'description', title: "Description", type: 'WikiText' },
			{ name: 'Name', field: 'name', title: "Name", type: 'String' }
		],
		rowClasses: [
			{ className: 'lowlight', field: 'lowlight' }
		]
	}
});

merge(config.macros.plugins, {
	wizardTitle: "Manage plugins",
	step1Title: "Currently loaded plugins",
	step1Html: "<input type='hidden' name='markList'></input>", // DO NOT TRANSLATE
	skippedText: "(This plugin has not been executed because it was added since startup)",
	noPluginText: "There are no plugins installed",
	confirmDeleteText: "Are you sure you want to delete these plugins:\n\n%0",
	removeLabel: "remove systemConfig tag",
	removePrompt: "Remove systemConfig tag",
	deleteLabel: "delete",
	deletePrompt: "Delete these tiddlers forever",
	listViewTemplate: {
		columns: [
			{ name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector' },
			{ name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler' },
			{ name: 'Description', field: 'Description', title: "Description", type: 'String' },
			{ name: 'Version', field: 'Version', title: "Version", type: 'String' },
			{ name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size' },
			{ name: 'Forced', field: 'forced', title: "Forced", tag: 'systemConfigForce', type: 'TagCheckbox' },
			{ name: 'Disabled', field: 'disabled', title: "Disabled", tag: 'systemConfigDisable', type: 'TagCheckbox' },
			{ name: 'Executed', field: 'executed', title: "Loaded", type: 'Boolean', trueText: "Yes", falseText: "No" },
			{ name: 'Startup Time', field: 'startupTime', title: "Startup Time", type: 'String' },
			{ name: 'Error', field: 'error', title: "Status", type: 'Boolean', trueText: "Error", falseText: "OK" },
			{ name: 'Log', field: 'log', title: "Log", type: 'StringList' }
		],
		rowClasses: [
			{ className: 'error', field: 'error' },
			{ className: 'warning', field: 'warning' }
		]
	},
	listViewTemplateReadOnly: {
		columns: [
			{ name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler' },
			{ name: 'Description', field: 'Description', title: "Description", type: 'String' },
			{ name: 'Version', field: 'Version', title: "Version", type: 'String' },
			{ name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size' },
			{ name: 'Executed', field: 'executed', title: "Loaded", type: 'Boolean', trueText: "Yes", falseText: "No" },
			{ name: 'Startup Time', field: 'startupTime', title: "Startup Time", type: 'String' },
			{ name: 'Error', field: 'error', title: "Status", type: 'Boolean', trueText: "Error", falseText: "OK" },
			{ name: 'Log', field: 'log', title: "Log", type: 'StringList' }
		],
		rowClasses: [
			{ className: 'error', field: 'error' },
			{ className: 'warning', field: 'warning' }
		]
	}
});

merge(config.macros.toolbar, {
	moreLabel: "more",
	morePrompt: "Show additional commands",
	lessLabel: "less",
	lessPrompt: "Hide additional commands",
	separator: "|"
});

merge(config.macros.refreshDisplay, {
	label: "refresh",
	prompt: "Redraw the entire TiddlyWiki display"
});

merge(config.macros.importTiddlers, {
	readOnlyWarning: "You cannot import into a read-only TiddlyWiki file. Try opening it from a file:// URL",
	wizardTitle: "Import tiddlers from another file or server",
	step1Title: "Step 1: Locate the server or TiddlyWiki file",
	step1Html: "Specify the type of the server: <select name='selTypes'><option value=''>Choose...</option></select><br>" +
		"Enter the URL or pathname here: <input type='text' size=50 name='txtPath'><br>" +
		"...or browse for a file: <input type='file' size=50 name='txtBrowse'><br><hr>" +
		"...or select a pre-defined feed: <select name='selFeeds'><option value=''>Choose...</option></select>",
	openLabel: "open",
	openPrompt: "Open the connection to this file or server",
	statusOpenHost: "Opening the host",
	statusGetWorkspaceList: "Getting the list of available workspaces",
	step2Title: "Step 2: Choose the workspace",
	step2Html: "Enter a workspace name: <input type='text' size=50 name='txtWorkspace'><br>...or select a workspace: " +
		"<select name='selWorkspace'><option value=''>Choose...</option></select>",
	cancelLabel: "cancel",
	cancelPrompt: "Cancel this import",
	statusOpenWorkspace: "Opening the workspace",
	statusGetTiddlerList: "Getting the list of available tiddlers",
	errorGettingTiddlerList: "Error getting list of tiddlers, click Cancel to try again",
	errorGettingTiddlerListHttp404: "Error retrieving tiddlers from url, please ensure the url exists. Click Cancel to try again.",
	errorGettingTiddlerListHttp: "Error retrieving tiddlers from url, please " +
		"ensure this url exists and is <a href='http://enable-cors.org/'>CORS</a> enabled",
	errorGettingTiddlerListFile: "Error retrieving tiddlers from local file, " +
		"please make sure the file is in the same directory as your TiddlyWiki. Click Cancel to try again.",
	step3Title: "Step 3: Choose the tiddlers to import",
	step3Html: "<input type='hidden' name='markList'></input><br><input type='checkbox' checked='true' name='chkSync'>" +
		"Keep these tiddlers linked to this server so that you can synchronise subsequent changes</input><br>" +
		"<input type='checkbox' name='chkSave'>Save the details of this server in a 'systemServer' tiddler called:</input> <input type='text' size=25 name='txtSaveTiddler'>",
	importLabel: "import",
	importPrompt: "Import these tiddlers",
	confirmOverwriteText: "Are you sure you want to overwrite these tiddlers:\n\n%0",
	step4Title: "Step 4: Importing %0 tiddler(s)",
	step4Html: "<input type='hidden' name='markReport'></input>", // DO NOT TRANSLATE
	doneLabel: "done",
	donePrompt: "Close this wizard",
	statusDoingImport: "Importing tiddlers",
	statusDoneImport: "All tiddlers imported",
	systemServerNamePattern: "%2 on %1",
	systemServerNamePatternNoWorkspace: "%1",
	confirmOverwriteSaveTiddler: "The tiddler '%0' already exists. Click 'OK' " +
		"to overwrite it with the details of this server, or 'Cancel' to leave it unchanged",
	serverSaveTemplate: "|''Type:''|%0|\n|''URL:''|%1|\n|''Workspace:''|%2|\n\n" +
		"This tiddler was automatically created to record the details of this server",
	serverSaveModifier: "(System)",
	listViewTemplate: {
		columns: [
			{ name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector' },
			{ name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler' },
			{ name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size' },
			{ name: 'Tags', field: 'tags', title: "Tags", type: 'Tags' }
		],
		rowClasses: []
	}
});

merge(config.macros.upgrade, {
	wizardTitle: "Upgrade TiddlyWiki",
	step1Title: "Update or repair TiddlyWiki core to the latest release",
	step1Html: "You are about to upgrade TiddlyWiki core to the latest release " +
		"(from <a href='%0' class='externalLink' target='_blank'>%1</a>). " +
		"Your content will be preserved across the upgrade.<br><br>" +
		"Note that core upgrades have been known to interfere with older plugins. " +
		"If you run into problems with upgrading, read how to handle them " +
		"<a href='%2' class='externalLink' target='_blank'>here</a>.",
	errorCantUpgrade: "Unable to upgrade this TiddlyWiki. You can only perform upgrades on TiddlyWiki files stored locally",
	errorNotSaved: "You must save changes before you can perform an upgrade",
	step2Title: "Confirm the upgrade details",
	step2Html_downgrade: "You are about to downgrade to TiddlyWiki version %0 from %1.<br><br>Downgrading to an earlier version of the core code is not recommended",
	step2Html_restore: "This TiddlyWiki appears to be already using the latest version of the core code (%0).<br><br>" +
		"You can continue to upgrade anyway to ensure that the core code hasn't been corrupted or damaged",
	step2Html_upgrade: "You are about to upgrade to TiddlyWiki version %0 from %1",
	upgradeLabel: "upgrade",
	upgradePrompt: "Prepare for the upgrade process",
	statusPreparingBackup: "Preparing backup",
	statusSavingBackup: "Saving backup file",
	errorSavingBackup: "There was a problem saving the backup file",
	errorVerifyingBackup: "Failed to verify the backup was saved. " +
		"This is either because it wasn't saved to the moment of the check or " +
		"loading file doesn't work with your saver (and it is needed for " +
		"the next step of upgrading). To upgrade your TiddlyWiki, you can use " +
		"other methods listed at <a href='%0' class='externalLink' target='_blank'>%0</a>",
	statusLoadingCore: "Loading core code",
	errorLoadingCore: "Error loading the core code",
	errorCoreFormat: "Error with the new core code",
	statusSavingCore: "Saving the new core code",
	statusReloadingCore: "Reloading the new core code",
	startLabel: "start",
	startPrompt: "Start the upgrade process",
	cancelLabel: "cancel",
	cancelPrompt: "Cancel the upgrade process",
	step3Title: "Upgrade cancelled",
	step3Html: "You have cancelled the upgrade process"
});

merge(config.macros.annotations, {});

merge(config.commands.closeTiddler, {
	text: "close",
	tooltip: "Close this tiddler"
});

merge(config.commands.closeOthers, {
	text: "close others",
	tooltip: "Close all other tiddlers"
});

merge(config.commands.editTiddler, {
	text: "edit",
	tooltip: "Edit this tiddler",
	readOnlyText: "view",
	readOnlyTooltip: "View the source of this tiddler"
});

merge(config.commands.saveTiddler, {
	text: "done",
	tooltip: "Save changes to this tiddler"
});

merge(config.commands.cancelTiddler, {
	text: "cancel",
	tooltip: "Undo changes to this tiddler",
	warning: "Are you sure you want to abandon your changes to '%0'?",
	readOnlyText: "done",
	readOnlyTooltip: "View this tiddler normally"
});

merge(config.commands.deleteTiddler, {
	text: "delete",
	tooltip: "Delete this tiddler",
	warning: "Are you sure you want to delete '%0'?"
});

merge(config.commands.permalink, {
	text: "permalink",
	tooltip: "Permalink for this tiddler"
});

merge(config.commands.references, {
	text: "references",
	tooltip: "Show tiddlers that link to this one",
	popupNone: "No references"
});

merge(config.commands.jump, {
	text: "jump",
	tooltip: "Jump to another open tiddler"
});

merge(config.commands.fields, {
	text: "fields",
	tooltip: "Show the extended fields of this tiddler",
	emptyText: "There are no extended fields for this tiddler",
	listViewTemplate: {
		columns: [
			{ name: 'Field', field: 'field', title: "Field", type: 'String' },
			{ name: 'Value', field: 'value', title: "Value", type: 'String' }
		],
		rowClasses: [],
		buttons: []
	}
});

merge(config.shadowTiddlers, {
	DefaultTiddlers: "[[GettingStarted]]",
	MainMenu: "[[GettingStarted]]",
	SiteTitle: "My TiddlyWiki",
	SiteSubtitle: "a reusable non-linear personal web notebook",
	SiteUrl: "",
	SideBarOptions: '<<search>><<closeAll>><<permaview>><<newTiddler>><<newJournal "DD MMM YYYY" "journal">>' +
		'<<saveChanges>><<slider chkSliderOptionsPanel OptionsPanel "options \u00bb" "Change TiddlyWiki advanced options">>',
	SideBarTabs: '<<tabs txtMainTab "Timeline" "Timeline" TabTimeline "All" "All tiddlers" TabAll "Tags" "All tags" TabTags "More" "More lists" TabMore>>',
	TabMore: '<<tabs txtMoreTab "Missing" "Missing tiddlers" TabMoreMissing "Orphans" "Orphaned tiddlers" TabMoreOrphans "Shadowed" "Shadowed tiddlers" TabMoreShadowed>>'
});

merge(config.annotations, {
	AdvancedOptions: "This shadow tiddler provides access to several advanced options",
	ColorPalette: "These values in this shadow tiddler determine the colour scheme of the ~TiddlyWiki user interface",
	DefaultTiddlers: "The tiddlers listed in this shadow tiddler will be automatically displayed when ~TiddlyWiki starts up",
	EditTemplate: "The HTML template in this shadow tiddler determines how tiddlers look while they are being edited",
	GettingStarted: "This shadow tiddler provides basic usage instructions",
	ImportTiddlers: "This shadow tiddler provides access to importing tiddlers",
	MainMenu: "This shadow tiddler is used as the contents of the main menu in the left-hand column of the screen",
	MarkupPreHead: "This tiddler is inserted at the top of the <head> section of the TiddlyWiki HTML file",
	MarkupPostHead: "This tiddler is inserted at the bottom of the <head> section of the TiddlyWiki HTML file",
	MarkupPreBody: "This tiddler is inserted at the top of the <body> section of the TiddlyWiki HTML file",
	MarkupPostBody: "This tiddler is inserted at the end of the <body> section of the TiddlyWiki HTML file immediately after the script block",
	OptionsPanel: "This shadow tiddler is used as the contents of the options panel slider in the right-hand sidebar",
	PageTemplate: "The HTML template in this shadow tiddler determines the overall ~TiddlyWiki layout",
	PluginManager: "This shadow tiddler provides access to the plugin manager",
	SideBarOptions: "This shadow tiddler is used as the contents of the option panel in the right-hand sidebar",
	SideBarTabs: "This shadow tiddler is used as the contents of the tabs panel in the right-hand sidebar",
	SiteSubtitle: "This shadow tiddler is used as the second part of the page title",
	SiteTitle: "This shadow tiddler is used as the first part of the page title",
	SiteUrl: "This shadow tiddler should be set to the full target URL for publication",
	StyleSheetColors: "This shadow tiddler contains CSS definitions related to the color of page elements. " +
		"''DO NOT EDIT THIS TIDDLER'', instead make your changes in the StyleSheet shadow tiddler",
	StyleSheet: "This tiddler can contain custom CSS definitions",
	StyleSheetLayout: "This shadow tiddler contains CSS definitions related to the layout of page elements. " +
	"''DO NOT EDIT THIS TIDDLER'', instead make your changes in the StyleSheet shadow tiddler",
	StyleSheetLocale: "This shadow tiddler contains CSS definitions related to the translation locale",
	StyleSheetPrint: "This shadow tiddler contains CSS definitions for printing",
	SystemSettings: "Options may be stored here using the slice notation (like {{{chkAutoSave: true}}} or {{{|txtUserName|The great inventor|}}})",
	TabAll: "This shadow tiddler contains the contents of the 'All' tab in the right-hand sidebar",
	TabMore: "This shadow tiddler contains the contents of the 'More' tab in the right-hand sidebar",
	TabMoreMissing: "This shadow tiddler contains the contents of the 'Missing' tab in the right-hand sidebar",
	TabMoreOrphans: "This shadow tiddler contains the contents of the 'Orphans' tab in the right-hand sidebar",
	TabMoreShadowed: "This shadow tiddler contains the contents of the 'Shadowed' tab in the right-hand sidebar",
	TabTags: "This shadow tiddler contains the contents of the 'Tags' tab in the right-hand sidebar",
	TabTimeline: "This shadow tiddler contains the contents of the 'Timeline' tab in the right-hand sidebar",
	ToolbarCommands: "This shadow tiddler determines which commands are shown in tiddler toolbars",
	ViewTemplate: "The HTML template in this shadow tiddler determines how tiddlers look"
});
//--
//-- Main
//--

var params = null; // Command line parameters
var store = null; // TiddlyWiki storage
var story = null; // Main story
var formatter = null; // Default formatters for the wikifier
var anim = typeof Animator == "function" ? new Animator() : null; // Animation engine
var readOnly = false; // Whether we're in readonly mode
var highlightHack = null; // Embarrassing hack department...
var hadConfirmExit = false; // Don't warn more than once
var safeMode = false; // Disable all plugins and cookies
var showBackstage; // Whether to include the backstage area
var installedPlugins = []; // Information filled in when plugins are executed
var startingUp = false; // Whether we're in the process of starting up
var pluginInfo, tiddler; // Used to pass information to plugins in loadPlugins()

// Whether this file can be saved back to the same location [Preemption]
window.allowSave = window.allowSave || function(l)
{
	return true;
};

// Whether this file is being viewed locally
window.isLocal = function()
{
	return (document.location.protocol == "file:");
};

var useJavaSaver = false;

// Allow preemption code a chance to tweak config and useJavaSaver [Preemption]
if (window.tweakConfig) window.tweakConfig();

if(!window || !window.console) {
	console = { tiddlywiki: true, log: function(message) { displayMessage(message) } };
}

// Starting up
function main()
{
	window.originalHTML = recreateOriginal();

	var t10, t9, t8, t7, t6, t5, t4, t3, t2, t1, t0 = new Date();
	startingUp = true;
	var doc = jQuery(document);
	jQuery.noConflict();
	window.onbeforeunload = function(e) { if(window.confirmExit) return confirmExit(); };
	params = getParameters();
	if(params) params = params.parseParams("open", null, false);
	store = new TiddlyWiki({ config: config });
	invokeParamifier(params, "oninit");
	story = new Story("tiddlerDisplay", "tiddler");
	addEvent(document, "click", Popup.onDocumentClick);
	saveTest();
	for(var i = 0; i < config.notifyTiddlers.length; i++)
		store.addNotification(config.notifyTiddlers[i].name, config.notifyTiddlers[i].notify);
	t1 = new Date();
	loadShadowTiddlers();
	doc.trigger("loadShadows");
	t2 = new Date();
	store.loadFromDiv("storeArea", "store", true);
	doc.trigger("loadTiddlers");
	loadOptions();
	t3 = new Date();
	invokeParamifier(params, "onload");
	t4 = new Date();
	readOnly = window.isLocal() ? false : config.options.chkHttpReadOnly;
	var pluginProblem = loadPlugins("systemConfig");
	doc.trigger("loadPlugins");
	t5 = new Date();
	formatter = new Formatter(config.formatters);
	invokeParamifier(params, "onconfig");
	story.switchTheme(config.options.txtTheme);
	showBackstage = showBackstage !== undefined ? showBackstage : !readOnly;
	t6 = new Date();
	for(var name in config.macros) {
		if(config.macros[name].init)
			config.macros[name].init();
	}
	t7 = new Date();
	store.notifyAll();
	t8 = new Date();
	restart();
	refreshDisplay();
	t9 = new Date();
	if(pluginProblem) {
		story.displayTiddler(null, "PluginManager");
		displayMessage(config.messages.customConfigError);
	}
	if(showBackstage)
		backstage.init();
	t10 = new Date();
	if(config.options.chkDisplayInstrumentation) {
		displayMessage("LoadShadows " + (t2 - t1) + " ms");
		displayMessage("LoadFromDiv " + (t3 - t2) + " ms");
		displayMessage("LoadPlugins " + (t5 - t4) + " ms");
		displayMessage("Macro init " + (t7 - t6) + " ms");
		displayMessage("Notify " + (t8 - t7) + " ms");
		displayMessage("Restart " + (t9 - t8) + " ms");
		displayMessage("Total: " + (t10 - t0) + " ms");
	}
	startingUp = false;
	doc.trigger("startup");
}

// Called on unload. Functions may get unloaded too, so they are called conditionally.
function unload()
{
	if(window.checkUnsavedChanges) checkUnsavedChanges();
	if(window.scrubNodes) scrubNodes(document.body);
}

// Restarting
function restart()
{
	invokeParamifier(params, "onstart");
	if(story.isEmpty()) {
		story.displayDefaultTiddlers();
	}
	window.scrollTo(0, 0);
}

function saveTest()
{
	var s = document.getElementById("saveTest");
	if(s.hasChildNodes())
		alert(config.messages.savedSnapshotError);
	s.appendChild(document.createTextNode("savetest"));
}

function loadShadowTiddlers()
{
	var shadows = new TiddlyWiki();
	shadows.loadFromDiv("shadowArea", "shadows", true);
	shadows.forEachTiddler(function(title, tiddler) { config.shadowTiddlers[title] = tiddler.text });
}

function loadPlugins(tag)
{
	if(safeMode)
		return false;
	var tiddlers = store.getTaggedTiddlers(tag);
	tiddlers.sort(function(a, b) { return a.title < b.title ? -1 : (a.title == b.title ? 0 : 1) });
	var toLoad = [];
	var nLoaded = 0;
	var map = {};
	var nPlugins = tiddlers.length;
	installedPlugins = [];
	for(var i = 0; i < nPlugins; i++) {
		var p = getPluginInfo(tiddlers[i]);
		installedPlugins[i] = p;
		var n = p.Name || p.title;
		if(n) map[n] = p;
		n = p.Source;
		if(n) map[n] = p;
	}
	var visit = function(p) {
		if(!p || p.done) return;
		p.done = 1;
		var reqs = p.Requires;
		if(reqs) {
			reqs = reqs.readBracketedList();
			for(var i = 0; i < reqs.length; i++)
				visit(map[reqs[i]]);
		}
		toLoad.push(p);
	};
	for(i = 0; i < nPlugins; i++)
		visit(installedPlugins[i]);
	for(i = 0; i < toLoad.length; i++) {
		p = toLoad[i];
		pluginInfo = p;
		tiddler = p.tiddler;
		if(isPluginExecutable(p)) {
			if(isPluginEnabled(p)) {
				p.executed = true;
				var startTime = new Date();
				try {
					if(tiddler.text)
						window.eval(tiddler.text);
					nLoaded++;
				} catch(ex) {
					p.log.push(config.messages.pluginError.format([exceptionText(ex)]));
					p.error = true;
					if(!console.tiddlywiki) {
						console.log("error evaluating " + tiddler.title, ex);
					}
				}
				pluginInfo.startupTime = String((new Date()) - startTime) + "ms";
			} else {
				nPlugins--;
			}
		} else {
			p.warning = true;
		}
	}
	return nLoaded != nPlugins;
}

function getPluginInfo(tiddler)
{
	var p = store.getTiddlerSlices(tiddler.title, ["Name", "Description", "Version",
		"Requires", "CoreVersion", "Date", "Source", "Author", "License", "Browsers"]);
	p.tiddler = tiddler;
	p.title = tiddler.title;
	p.log = [];
	return p;
}

// Check that a particular plugin is valid for execution
function isPluginExecutable(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigForce")) {
		plugin.log.push(config.messages.pluginForced);
		return true;
	}
	if(plugin["CoreVersion"]) {
		var coreVersion = plugin["CoreVersion"].split(".");
		var w = parseInt(coreVersion[0], 10) - version.major;
		if(w == 0 && coreVersion[1])
			w = parseInt(coreVersion[1], 10) - version.minor;
		if(w == 0 && coreVersion[2])
			w = parseInt(coreVersion[2], 10) - version.revision;
		if(w > 0) {
			plugin.log.push(config.messages.pluginVersionError);
			return false;
		}
	}
	return true;
}

function isPluginEnabled(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigDisable")) {
		plugin.log.push(config.messages.pluginDisabled);
		return false;
	}
	return true;
}

//--
//-- Paramifiers
//--

function getParameters()
{
	return window.location.hash ? decodeURIComponent(window.location.hash.substr(1)) : null;
}

function invokeParamifier(params, handler)
{
	if(!params || params.length == undefined || params.length <= 1)
		return;

	for(var i = 1; i < params.length; i++) {
		var name = params[i].name,
		    value = params[i].value;
		var p = config.paramifiers[name];
		if(p && p[handler] instanceof Function)
			p[handler](value);
		else {
			var h = config.optionHandlers[name.substr(0, 3)];
			if(h && h.set instanceof Function)
				h.set(name, value);
		}
	}
}

config.paramifiers = {};

config.paramifiers.start = {
	oninit: function(v) {
		safeMode = v.toLowerCase() == "safe";
	}
};

config.paramifiers.open = {
	onstart: function(title) {
		if(!readOnly || store.tiddlerExists(title) || store.isShadowTiddler(title))
			story.displayTiddler("bottom", title, null, false, null);
	}
};

config.paramifiers.story = {
	onstart: function(title) {
		var list = store.getTiddlerText(title, "").parseParams("open", null, false);
		invokeParamifier(list, "onstart");
	}
};

config.paramifiers.search = {
	onstart: function(query) {
		story.search(query, false, false);
	}
};

config.paramifiers.searchRegExp = {
	onstart: function(v) {
		story.prototype.search(v, false, true);
	}
};

config.paramifiers.tag = {
	onstart: function(tag) {
		story.displayTiddlers(null, store.filterTiddlers("[tag[" + tag + "]]"), null, false, null);
	}
};

config.paramifiers.newTiddler = {
	onstart: function(v) {
		if(readOnly) return;
		var args = v.parseParams("anon", null, null)[0];
		var title = args.title ? args.title[0] : v;
		var customFields = args.fields ? args.fields[0] : null;

		story.displayTiddler(null, title, DEFAULT_EDIT_TEMPLATE, false, null, customFields);
		story.focusTiddler(title, "text");
		var i, tags = args.tag || [];
		for(i = 0; i < tags.length; i++) {
			story.setTiddlerTag(title, tags[i], +1);
		}
	}
};

config.paramifiers.newJournal = {
	onstart: function(titleTemplate) {
		if(readOnly) return;
		var now = new Date();
		var title = now.formatString(titleTemplate.trim());
		story.displayTiddler(null, title, DEFAULT_EDIT_TEMPLATE);
		story.focusTiddler(title, "text");
	}
};

config.paramifiers.readOnly = {
	onconfig: function(v) {
		var p = v.toLowerCase();
		readOnly = p == "yes" ? true : (p == "no" ? false : readOnly);
	}
};

config.paramifiers.theme = {
	onconfig: function(themeTitle) {
		story.switchTheme(themeTitle);
	}
};

config.paramifiers.upgrade = {
	onstart: function(v) {
		upgradeFrom(v);
	}
};

config.paramifiers.recent = {
	onstart: function(limit) {
		var titles = [];
		var i, tiddlers = store.getTiddlers("modified", "excludeLists").reverse();
		for(i = 0; i < limit && i < tiddlers.length; i++)
			titles.push(tiddlers[i].title);
		story.displayTiddlers(null, titles);
	}
};

config.paramifiers.filter = {
	onstart: function(filterExpression) {
		story.displayTiddlers(null, store.filterTiddlers(filterExpression), null, false);
	}
};

//--
//-- Formatter helpers
//--

function Formatter(formatters)
{
	this.formatters = [];
	var pattern = [];
	for(var n = 0; n < formatters.length; n++) {
		pattern.push("(" + formatters[n].match + ")");
		this.formatters.push(formatters[n]);
	}
	this.formatterRegExp = new RegExp(pattern.join("|"), "mg");
}

config.formatterHelpers = {

	createElementAndWikify: function(w)
	{
		w.subWikifyTerm(createTiddlyElement(w.output, this.element), this.termRegExp);
	},

	inlineCssHelper: function(w)
	{
		// Convert CSS property name to a JavaScript style name ("background-color" -> "backgroundColor")
		var unDash = function(name) {
			return name
				.split("-")
				.map(function(word, i) {
					return i == 0 ? word :
						word.charAt(0).toUpperCase() + word.slice(1);
				})
				.join("");
		};
		var styles = [];
		config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			var s, v;
			if(lookaheadMatch[1]) {
				s = unDash(lookaheadMatch[1]);
				v = lookaheadMatch[2];
			} else {
				s = unDash(lookaheadMatch[3]);
				v = lookaheadMatch[4];
			}
			if(s == "bgcolor") s = "backgroundColor";
			if(s == "float") s = "cssFloat";
			styles.push({ style: s, value: v });
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
			config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		}
		return styles;
	},

	applyCssHelper: function(e, styles)
	{
		for(var i = 0; i < styles.length; i++) {
			try {
				e.style[styles[i].style] = styles[i].value;
			} catch (ex) {}
		}
	},

	enclosedTextHelper: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var text = lookaheadMatch[1];
			if(config.browser.isIE && (config.browser.ieVersion[1] < 10))
				text = text.replace(/\n/g, "\r");
			createTiddlyElement(w.output, this.element, null, null, text);
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
		}
	},

	isExternalLink: function(link)
	{
		if(store.tiddlerExists(link) || store.isShadowTiddler(link)) {
			return false;
		}
		var urlRegExp = new RegExp(config.textPrimitives.urlPattern, "mg");
		if(urlRegExp.exec(link)) {
			return true;
		}
		if(link.indexOf(".") != -1 ||
		   link.indexOf("\\") != -1 ||
		   link.indexOf("/") != -1 ||
		   link.indexOf("#") != -1
		) {
			return true;
		}
		return false;
	}
};

//--
//-- Standard formatters
//--

config.formatters = [
	{
		name: "table",
		match: "^\\|(?:[^\\n]*)\\|(?:[fhck]?)$",
		lookaheadRegExp: /^\|([^\n]*)\|([fhck]?)$/mg,
		rowTermRegExp: /(\|(?:[fhck]?)$\n?)/mg,
		cellRegExp: /(?:\|([^\n\|]*)\|)|(\|[fhck]?$\n?)/mg,
		cellTermRegExp: /((?:\x20*)\|)/mg,
		rowTypes: { "c": "caption", "h": "thead", "": "tbody", "f": "tfoot" },
		handler: function(w)
		{
			var table = createTiddlyElement(w.output, "table", null, "twtable");
			var prevColumns = [];
			var currRowType = null;
			var rowContainer;
			var rowCount = 0;
			var onmouseover = function() { jQuery(this).addClass("hoverRow") };
			var onmouseout = function() { jQuery(this).removeClass("hoverRow") };
			w.nextMatch = w.matchStart;
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
				var nextRowType = lookaheadMatch[2];
				if(nextRowType == "k") {
					table.className = lookaheadMatch[1];
					w.nextMatch += lookaheadMatch[0].length + 1;
				} else {
					if(nextRowType != currRowType) {
						rowContainer = createTiddlyElement(table, this.rowTypes[nextRowType]);
						currRowType = nextRowType;
					}
					if(currRowType == "c") {
						// Caption
						w.nextMatch++;
						if(rowContainer != table.firstChild)
							table.insertBefore(rowContainer, table.firstChild);
						rowContainer.setAttribute("align", rowCount == 0 ? "top" : "bottom");
						w.subWikifyTerm(rowContainer, this.rowTermRegExp);
					} else {
						var theRow = createTiddlyElement(rowContainer, "tr", null, rowCount % 2 ? "oddRow" : "evenRow");
						theRow.onmouseover = onmouseover;
						theRow.onmouseout = onmouseout;
						this.rowHandler(w, theRow, prevColumns);
						rowCount++;
					}
				}
				this.lookaheadRegExp.lastIndex = w.nextMatch;
				lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			}
		},
		rowHandler: function(w, e, prevColumns)
		{
			var col = 0;
			var colSpanCount = 1;
			var prevCell = null;
			this.cellRegExp.lastIndex = w.nextMatch;
			var cellMatch = this.cellRegExp.exec(w.source);
			while(cellMatch && cellMatch.index == w.nextMatch) {
				if(cellMatch[1] == "~") {
					// Rowspan
					var last = prevColumns[col];
					if(last) {
						last.rowSpanCount++;
						last.element.setAttribute("rowspan", last.rowSpanCount);
						last.element.setAttribute("rowSpan", last.rowSpanCount); // Needed for IE
						last.element.valign = "center";
						if(colSpanCount > 1) {
							last.element.setAttribute("colspan", colSpanCount);
							last.element.setAttribute("colSpan", colSpanCount); // Needed for IE
							colSpanCount = 1;
						}
					}
					w.nextMatch = this.cellRegExp.lastIndex - 1;
				} else if(cellMatch[1] == ">") {
					// Colspan
					colSpanCount++;
					w.nextMatch = this.cellRegExp.lastIndex - 1;
				} else if(cellMatch[2]) {
					// End of row
					if(prevCell && colSpanCount > 1) {
						prevCell.setAttribute("colspan", colSpanCount);
						prevCell.setAttribute("colSpan", colSpanCount); // Needed for IE
					}
					w.nextMatch = this.cellRegExp.lastIndex;
					break;
				} else {
					// Cell
					w.nextMatch++;
					var styles = config.formatterHelpers.inlineCssHelper(w);
					var spaceLeft = false;
					var chr = w.source.substr(w.nextMatch, 1);
					while(chr == " ") {
						spaceLeft = true;
						w.nextMatch++;
						chr = w.source.substr(w.nextMatch, 1);
					}
					var cell;
					if(chr == "!") {
						cell = createTiddlyElement(e, "th");
						w.nextMatch++;
					} else {
						var isInsideHeader = e.parentElement.tagName.toLocaleLowerCase() === 'thead';
						cell = createTiddlyElement(e, isInsideHeader ? "th" : "td");
					}
					prevCell = cell;
					prevColumns[col] = { rowSpanCount: 1, element: cell };
					if(colSpanCount > 1) {
						cell.setAttribute("colspan", colSpanCount);
						cell.setAttribute("colSpan", colSpanCount); // Needed for IE
						colSpanCount = 1;
					}
					config.formatterHelpers.applyCssHelper(cell, styles);
					w.subWikifyTerm(cell, this.cellTermRegExp);
					if(w.matchText.substr(w.matchText.length - 2, 1) == " ") // spaceRight
						cell.align = spaceLeft ? "center" : "left";
					else if(spaceLeft)
						cell.align = "right";
					w.nextMatch--;
				}
				col++;
				this.cellRegExp.lastIndex = w.nextMatch;
				cellMatch = this.cellRegExp.exec(w.source);
			}
		}
	},

	{
		name: "heading",
		match: "^!{1,6}",
		termRegExp: /(\n)/mg,
		handler: function(w)
		{
			w.subWikifyTerm(createTiddlyElement(w.output, "h" + w.matchLength), this.termRegExp);
		}
	},

	{
		name: "list",
		match: "^(?:[\\*#;:]+)",
		lookaheadRegExp: /^(?:(?:(\*)|(#)|(;)|(:))+)/mg,
		termRegExp: /(\n)/mg,
		handler: function(w)
		{
			// stack holds nested elements to which (nested) lists are appended
			var stack = [w.output];
			var currLevel = 0, currType = null;
			var listLevel, listType, itemType, baseType;
			w.nextMatch = w.matchStart;
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
				if(lookaheadMatch[1]) {
					listType = "ul";
					itemType = "li";
				} else if(lookaheadMatch[2]) {
					listType = "ol";
					itemType = "li";
				} else if(lookaheadMatch[3]) {
					listType = "dl";
					itemType = "dt";
				} else if(lookaheadMatch[4]) {
					listType = "dl";
					itemType = "dd";
				}
				if(!baseType)
					baseType = listType;
				listLevel = lookaheadMatch[0].length;
				w.nextMatch += lookaheadMatch[0].length;
				var l;
				if(listLevel > currLevel) {
					for(l = currLevel; l < listLevel; l++) {
						var target = (currLevel == 0) ? stack[stack.length - 1] : stack[stack.length - 1].lastChild;
						stack.push(createTiddlyElement(target, listType));
					}
				} else if(listType != baseType && listLevel == 1) {
					w.nextMatch -= lookaheadMatch[0].length;
					return;
				} else if(listLevel < currLevel) {
					for(l = currLevel; l > listLevel; l--)
						stack.pop();
				} else if(listLevel == currLevel && listType != currType) {
					stack.pop();
					stack.push(createTiddlyElement(stack[stack.length - 1].lastChild, listType));
				}
				currLevel = listLevel;
				currType = listType;
				var itemElement = createTiddlyElement(stack[stack.length - 1], itemType);
				w.subWikifyTerm(itemElement, this.termRegExp);
				this.lookaheadRegExp.lastIndex = w.nextMatch;
				lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			}
		}
	},

	{
		name: "quoteByBlock",
		match: "^<<<\\n",
		termRegExp: /(^<<<(\n|$))/mg,
		element: "blockquote",
		handler: config.formatterHelpers.createElementAndWikify
	},

	{
		name: "quoteByLine",
		match: "^>+",
		lookaheadRegExp: /^>+/mg,
		termRegExp: /(\n)/mg,
		element: "blockquote",
		handler: function(w)
		{
			var stack = [w.output];
			var currLevel = 0;
			var newLevel = w.matchLength;
			var l, matched;
			do {
				if(newLevel > currLevel) {
					for(l = currLevel; l < newLevel; l++)
						stack.push(createTiddlyElement(stack[stack.length - 1], this.element));
				} else if(newLevel < currLevel) {
					for(l = currLevel; l > newLevel; l--)
						stack.pop();
				}
				currLevel = newLevel;
				w.subWikifyTerm(stack[stack.length - 1], this.termRegExp);
				createTiddlyElement(stack[stack.length - 1], "br");
				this.lookaheadRegExp.lastIndex = w.nextMatch;
				var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
				matched = lookaheadMatch && lookaheadMatch.index == w.nextMatch;
				if(matched) {
					newLevel = lookaheadMatch[0].length;
					w.nextMatch += lookaheadMatch[0].length;
				}
			} while(matched);
		}
	},

	{
		name: "rule",
		match: "^----+$\\n?|<hr ?/?>\\n?",
		handler: function(w)
		{
			createTiddlyElement(w.output, "hr");
		}
	},

	{
		name: "monospacedByLine",
		match: "^(?:/\\*\\{\\{\\{\\*/|\\{\\{\\{|//\\{\\{\\{|<!--\\{\\{\\{-->)\\n",
		element: "pre",
		handler: function(w)
		{
			switch(w.matchText) {
				case "/*{{{*/\n": // CSS
					this.lookaheadRegExp = /\/\*\{\{\{\*\/\n*((?:^[^\n]*\n)+?)(\n*^\f*\/\*\}\}\}\*\/$\n?)/mg;
					break;
				case "{{{\n": // monospaced block
					this.lookaheadRegExp = /^\{\{\{\n((?:^[^\n]*\n)+?)(^\f*\}\}\}$\n?)/mg;
					break;
				case "//{{{\n": // plugin
					this.lookaheadRegExp = /^\/\/\{\{\{\n\n*((?:^[^\n]*\n)+?)(\n*^\f*\/\/\}\}\}$\n?)/mg;
					break;
				case "<!--{{{-->\n": //template
					this.lookaheadRegExp = /<!--\{\{\{-->\n*((?:^[^\n]*\n)+?)(\n*^\f*<!--\}\}\}-->$\n?)/mg;
					break;
				default:
					break;
			}
			config.formatterHelpers.enclosedTextHelper.call(this, w);
		}
	},

	{
		name: "wikifyComment",
		match: "^(?:/\\*\\*\\*|<!---)\\n",
		handler: function(w)
		{
			var termRegExp = (w.matchText == "/***\n") ? (/(^\*\*\*\/\n)/mg) : (/(^--->\n)/mg);
			w.subWikifyTerm(w.output, termRegExp);
		}
	},

	{
		name: "macro",
		match: "<<",
		lookaheadRegExp: /<<([^>\s]+)(?:\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart && lookaheadMatch[1]) {
				w.nextMatch = this.lookaheadRegExp.lastIndex;
				invokeMacro(w.output, lookaheadMatch[1], lookaheadMatch[2], w, w.tiddler);
			}
		}
	},

	{
		name: "prettyLink",
		match: "\\[\\[",
		lookaheadRegExp: /\[\[(.*?)(?:\|(~)?(.*?))?\]\]/mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
				var e;
				var text = lookaheadMatch[1];
				if(lookaheadMatch[3]) {
					// Pretty bracketted link
					var link = lookaheadMatch[3];
					e = (!lookaheadMatch[2] && config.formatterHelpers.isExternalLink(link))
						? createExternalLink(w.output, link)
						: createTiddlyLink(w.output, link, false, null, w.isStatic, w.tiddler);
				} else {
					// Simple bracketted link
					e = createTiddlyLink(w.output, text, false, null, w.isStatic, w.tiddler);
				}
				createTiddlyText(e, text);
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	},

	{
		name: "wikiLink",
		match: config.textPrimitives.unWikiLink + "?" + config.textPrimitives.wikiLink,
		handler: function(w)
		{
			if(w.matchText.substr(0, 1) == config.textPrimitives.unWikiLink) {
				w.outputText(w.output, w.matchStart + 1, w.nextMatch);
				return;
			}
			if(w.matchStart > 0) {
				var preRegExp = new RegExp(config.textPrimitives.anyLetterStrict, "mg");
				preRegExp.lastIndex = w.matchStart - 1;
				var preMatch = preRegExp.exec(w.source);
				if(preMatch.index == w.matchStart - 1) {
					w.outputText(w.output, w.matchStart, w.nextMatch);
					return;
				}
			}
			if(w.autoLinkWikiWords || store.isShadowTiddler(w.matchText)) {
				var link = createTiddlyLink(w.output, w.matchText, false, null, w.isStatic, w.tiddler);
				w.outputText(link, w.matchStart, w.nextMatch);
			} else {
				w.outputText(w.output, w.matchStart, w.nextMatch);
			}
		}
	},

	{
		name: "urlLink",
		match: config.textPrimitives.urlPattern,
		handler: function(w)
		{
			w.outputText(createExternalLink(w.output, w.matchText), w.matchStart, w.nextMatch);
		}
	},

	{
		name: "image",
		match: "\\[[<>]?[Ii][Mm][Gg]\\[",
		lookaheadRegExp: /\[([<]?)(>?)[Ii][Mm][Gg]\[(?:([^\|\]]+)\|)?([^\[\]\|]+)\](?:\[([^\]]*)\])?\]/mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
				var container = w.output;
				var link = lookaheadMatch[5];
				if(link) {
					container = config.formatterHelpers.isExternalLink(link)
						? createExternalLink(w.output, link)
						: createTiddlyLink(w.output, link, false, null, w.isStatic, w.tiddler);
					jQuery(container).addClass("imageLink");
				}
				var img = createTiddlyElement(container, "img");
				if(lookaheadMatch[1])
					img.align = "left";
				else if(lookaheadMatch[2])
					img.align = "right";
				if(lookaheadMatch[3]) {
					img.title = lookaheadMatch[3];
					img.setAttribute("alt", lookaheadMatch[3]);
				}
				img.src = lookaheadMatch[4];
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	},

	{
		name: "html",
		match: "<[Hh][Tt][Mm][Ll]>",
		lookaheadRegExp: /<[Hh][Tt][Mm][Ll]>((?:.|\n)*?)<\/[Hh][Tt][Mm][Ll]>/mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
				createTiddlyElement(w.output, "span").innerHTML = lookaheadMatch[1];
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	},

	{
		name: "commentByBlock",
		match: "/%",
		lookaheadRegExp: /\/%((?:.|\n)*?)%\//mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart)
				w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	},

	{
		name: "characterFormat",
		match: "''|//|__|\\^\\^|~~|--(?!\\s|$)|\\{\\{\\{",
		handler: function(w)
		{
			switch(w.matchText) {
				case "''":
					w.subWikifyTerm(w.output.appendChild(document.createElement("strong")), /('')/mg);
					break;
				case "//":
					w.subWikifyTerm(createTiddlyElement(w.output, "em"), /(\/\/)/mg);
					break;
				case "__":
					w.subWikifyTerm(createTiddlyElement(w.output, "u"), /(__)/mg);
					break;
				case "^^":
					w.subWikifyTerm(createTiddlyElement(w.output, "sup"), /(\^\^)/mg);
					break;
				case "~~":
					w.subWikifyTerm(createTiddlyElement(w.output, "sub"), /(~~)/mg);
					break;
				case "--":
					w.subWikifyTerm(createTiddlyElement(w.output, "strike"), /(--)/mg);
					break;
				case "{{{":
					var lookaheadRegExp = /\{\{\{((?:.|\n)*?)\}\}\}/mg;
					lookaheadRegExp.lastIndex = w.matchStart;
					var lookaheadMatch = lookaheadRegExp.exec(w.source);
					if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
						createTiddlyElement(w.output, "code", null, null, lookaheadMatch[1]);
						w.nextMatch = lookaheadRegExp.lastIndex;
					}
					break;
			}
		}
	},

	{
		name: "customFormat",
		match: "@@|\\{\\{",
		handler: function(w)
		{
			switch(w.matchText) {
				case "@@":
					var e = createTiddlyElement(w.output, "span");
					var styles = config.formatterHelpers.inlineCssHelper(w);
					if(styles.length == 0)
						e.className = "marked";
					else
						config.formatterHelpers.applyCssHelper(e, styles);
					w.subWikifyTerm(e, /(@@)/mg);
					break;
				case "{{":
					var lookaheadRegExp = /\{\{[\s]*([\w]+[\s\w]*)[\s]*\{(\n?)/mg;
					lookaheadRegExp.lastIndex = w.matchStart;
					var lookaheadMatch = lookaheadRegExp.exec(w.source);
					if(lookaheadMatch) {
						w.nextMatch = lookaheadRegExp.lastIndex;
						e = createTiddlyElement(w.output, lookaheadMatch[2] == "\n" ? "div" : "span", null, lookaheadMatch[1]);
						w.subWikifyTerm(e, /(\}\}\})/mg);
					}
					break;
			}
		}
	},

	{
		name: "mdash",
		match: "--",
		handler: function(w)
		{
			createTiddlyElement(w.output, "span").innerHTML = "&mdash;";
		}
	},

	{
		name: "lineBreak",
		match: "\\n|<br ?/?>",
		handler: function(w)
		{
			createTiddlyElement(w.output, "br");
		}
	},

	{
		name: "rawText",
		match: "\"{3}|<nowiki>",
		lookaheadRegExp: /(?:\"{3}|<nowiki>)((?:.|\n)*?)(?:\"{3}|<\/nowiki>)/mg,
		handler: function(w)
		{
			this.lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
				createTiddlyElement(w.output, "span", null, null, lookaheadMatch[1]);
				w.nextMatch = this.lookaheadRegExp.lastIndex;
			}
		}
	},

	{
		name: "htmlEntitiesEncoding",
		match: "(?:(?:&#?[a-zA-Z0-9]{2,8};|.)" +
			"(?:&#?(?:x0*(?:3[0-6][0-9a-fA-F]|1D[c-fC-F][0-9a-fA-F]|20[d-fD-F][0-9a-fA-F]|FE2[0-9a-fA-F])|0*" +
			"(?:76[89]|7[7-9][0-9]|8[0-7][0-9]|761[6-9]|76[2-7][0-9]|84[0-3][0-9]|844[0-7]|6505[6-9]|6506[0-9]|6507[0-1]));)+" +
			"|&#?[a-zA-Z0-9]{2,8};)",
		handler: function(w)
		{
			createTiddlyElement(w.output, "span").innerHTML = w.matchText;
		}
	}
];

//--
//-- Wikifier
//--

function getParser(tiddler, format)
{
	if(tiddler) {
		if(!format) format = tiddler.fields["wikiformat"];
		var i;
		if(format) {
			for(i in config.parsers)
				if(format == config.parsers[i].format)
					return config.parsers[i];
		} else {
			for(i in config.parsers)
				if(tiddler.isTagged(config.parsers[i].formatTag))
					return config.parsers[i];
		}
	}
	return formatter;
}

function Wikifier(source, formatter, highlightRegExp, tiddler)
{
	this.source = source;
	this.output = null;
	this.formatter = formatter;
	this.nextMatch = 0;
	this.autoLinkWikiWords = tiddler && tiddler.autoLinkWikiWords() == false ? false : true;
	this.highlightRegExp = highlightRegExp;
	this.highlightMatch = null;
	this.isStatic = false;
	if(highlightRegExp) {
		highlightRegExp.lastIndex = 0;
		this.highlightMatch = highlightRegExp.exec(source);
	}
	this.tiddler = tiddler;
}

Wikifier.prototype.wikifyPlain = function()
{
	var e = createTiddlyElement(document.body, "div");
	e.style.display = "none";
	this.subWikify(e);
	var text = jQuery(e).text();
	jQuery(e).remove();
	return text;
};

Wikifier.prototype.subWikify = function(output, terminator)
{
	try {
		if(terminator)
			this.subWikifyTerm(output, new RegExp("(" + terminator + ")", "mg"));
		else
			this.subWikifyUnterm(output);
	} catch(ex) {
		showException(ex);
	}
};

Wikifier.prototype.subWikifyUnterm = function(output)
{
	var oldOutput = this.output;
	this.output = output;
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch;
	while(formatterMatch = this.formatter.formatterRegExp.exec(this.source)) {
		// Output any text before the match
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output, this.nextMatch, formatterMatch.index);
		// Set the match parameters for the handler
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var i = 1; i < formatterMatch.length; i++) {
			if(formatterMatch[i]) {
				this.formatter.formatters[i - 1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output, this.nextMatch, this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.subWikifyTerm = function(output, terminatorRegExp)
{
	var oldOutput = this.output;
	this.output = output;
	terminatorRegExp.lastIndex = this.nextMatch;
	var terminatorMatch = terminatorRegExp.exec(this.source);
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ?
		this.source.substr(0, terminatorMatch.index) : this.source);
	while(terminatorMatch || formatterMatch) {
		if(terminatorMatch && (!formatterMatch || terminatorMatch.index <= formatterMatch.index)) {
			if(terminatorMatch.index > this.nextMatch)
				this.outputText(this.output, this.nextMatch, terminatorMatch.index);
			this.matchText = terminatorMatch[1];
			this.matchLength = terminatorMatch[1].length;
			this.matchStart = terminatorMatch.index;
			this.nextMatch = this.matchStart + this.matchLength;
			this.output = oldOutput;
			return;
		}
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output, this.nextMatch, formatterMatch.index);
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var i = 1; i < formatterMatch.length; i++) {
			if(formatterMatch[i]) {
				this.formatter.formatters[i - 1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
		terminatorRegExp.lastIndex = this.nextMatch;
		terminatorMatch = terminatorRegExp.exec(this.source);
		formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ?
			this.source.substr(0, terminatorMatch.index) : this.source);
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output, this.nextMatch, this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.outputText = function(place, startPos, endPos)
{
	while(this.highlightMatch && (this.highlightRegExp.lastIndex > startPos) &&
		  (this.highlightMatch.index < endPos) && (startPos < endPos)) {
		if(this.highlightMatch.index > startPos) {
			createTiddlyText(place, this.source.substring(startPos, this.highlightMatch.index));
			startPos = this.highlightMatch.index;
		}
		var highlightEnd = Math.min(this.highlightRegExp.lastIndex, endPos);
		createTiddlyElement(place, "span", null, "highlight", this.source.substring(startPos, highlightEnd));
		startPos = highlightEnd;
		if(startPos >= this.highlightRegExp.lastIndex)
			this.highlightMatch = this.highlightRegExp.exec(this.source);
	}
	if(startPos < endPos) {
		createTiddlyText(place, this.source.substring(startPos, endPos));
	}
};

function wikify(source, output, highlightRegExp, tiddler)
{
	if(!source) return;
	var wikifier = new Wikifier(source, getParser(tiddler), highlightRegExp, tiddler);
	var t0 = new Date();
	wikifier.subWikify(output);
	if(tiddler && config.options.chkDisplayInstrumentation)
		displayMessage("wikify:" + tiddler.title + " in " + (new Date() - t0) + " ms");
}

function wikifyStatic(source, highlightRegExp, tiddler, format)
{
	if(!source) return "";
	if(!tiddler) tiddler = new Tiddler("temp");
	var wikifier = new Wikifier(source, getParser(tiddler, format), highlightRegExp, tiddler);
	wikifier.isStatic = true;

	var e = createTiddlyElement(document.body, "pre");
	e.style.display = "none";
	wikifier.subWikify(e);
	var html = e.innerHTML;
	jQuery(e).remove();
	return html;
}

function wikifyPlainText(text, limit, tiddler)
{
	if(limit > 0)
		text = text.substr(0, limit);
	var wikifier = new Wikifier(text, formatter, null, tiddler);
	return wikifier.wikifyPlain();
}

function highlightify(source, output, highlightRegExp, tiddler)
{
	if(!source) return;
	var wikifier = new Wikifier(source, formatter, highlightRegExp, tiddler);
	wikifier.outputText(output, 0, source.length);
}

//--
//-- Macro definitions
//--

function invokeMacro(place, macro, params, wikifier, tiddler)
{
	try {
		var m = config.macros[macro];
		if(m && m.handler) {
			var tiddlerElem = story.findContainingTiddler(place);

			window.tiddler = tiddlerElem ? store.getTiddler(tiddlerElem.getAttribute("tiddler")) : null;
			window.place = place;

			var allowEval = true;
			if(config.evaluateMacroParameters == "system") {
				if(!tiddler || tiddler.tags.indexOf("systemAllowEval") == -1) {
					allowEval = false;
				}
			}
			m.handler(place, macro, m.noPreParse ? null : params.readMacroParams(!allowEval), wikifier, params, tiddler);
		} else {
			createTiddlyError(place, config.messages.macroError.format([macro]),
				config.messages.macroErrorDetails.format([macro, config.messages.missingMacro]));
		}
	} catch(ex) {
		createTiddlyError(place, config.messages.macroError.format([macro]),
			config.messages.macroErrorDetails.format([macro, ex.toString()]));
	}
}

config.macros.version.handler = function(place)
{
	jQuery("<span/>").text(formatVersion()).appendTo(place);
};

config.macros.today.handler = function(place, macroName, params)
{
	var now = new Date();
	var text = params[0] ? now.formatString(params[0].trim()) : now.toLocaleString();
	jQuery("<span/>").text(text).appendTo(place);
};

config.macros.list.template = "<<view title link>>";
config.macros.list.handler = function(place, macroName, params, wikifier, paramString)
{
	var list = document.createElement("ul");
	jQuery(list).attr({ refresh: "macro", macroName: macroName }).data("params", paramString);
	place.appendChild(list);
	this.refresh(list);
};

config.macros.list.refresh = function(list)
{
	var paramString = jQuery(list).data("params");
	var params = paramString.readMacroParams();
	var args = paramString.parseParams("anon", null, null)[0];
	var type = args.anon ? args.anon[0] : "all";
	var template = args.template ? store.getTiddlerText(args.template[0]) : false;
	if(!template) {
		template = config.macros.list.template;
	}
	var results;
	if(this[type].handler)
		results = this[type].handler(params);

	jQuery(list).empty().addClass("list list-" + type);
	if(this[type].prompt)
		createTiddlyElement(list, "li", null, "listTitle", this[type].prompt);

	for(var i = 0; i < results.length; i++) {
		var li = createTiddlyElement(list, "li");
		var tiddler = results[i];
		if(typeof(tiddler) == 'string') { // deal with missing etc..
			tiddler = store.getTiddler(tiddler) || new Tiddler(tiddler);
		}
		wikify(template, li, null, tiddler);
	}
	if(results.length === 0 && args.emptyMessage) {
		jQuery(list).addClass("emptyList");
		jQuery("<li />").text(args.emptyMessage[0]).appendTo(list);
	}
};

config.macros.list.all.handler = function(params)
{
	return store.reverseLookup("tags", "excludeLists", false, "title");
};

config.macros.list.missing.handler = function(params)
{
	return store.getMissingLinks();
};

config.macros.list.orphans.handler = function(params)
{
	return store.getOrphans();
};

config.macros.list.shadowed.handler = function(params)
{
	return store.getShadowed();
};

config.macros.list.touched.handler = function(params)
{
	return store.getTouched();
};

config.macros.list.filter.handler = function(params)
{
	var filter = params[1];
	if(!filter) return [];
	return store.filterTiddlers(filter).map(function(tiddler) {
		return tiddler.title;
	});
};

config.macros.allTags.handler = function(place, macroName, params)
{
	var tags = store.getTags(params[0]);
	var ul = createTiddlyElement(place, "ul");
	if(tags.length == 0) createTiddlyElement(ul, "li", null, "listTitle", this.noTags);

	for(var i = 0; i < tags.length; i++) {
		var title = tags[i][0];
		var info = getTiddlyLinkInfo(title);
		var li = createTiddlyElement(ul, "li");
		var btn = createTiddlyButton(li, title + " (" + tags[i][1] + ")",
			this.tooltip.format([title]), onClickTag, info.classes);
		btn.setAttribute("tag", title);
		btn.setAttribute("refresh", "link");
		btn.setAttribute("tiddlyLink", title);
		if(params[1]) btn.setAttribute("sortby", params[1]);
	}
};

var macro = config.macros.timeline;
merge(macro, {
	handler: function(place, macroName, params, wikifier, paramString, tiddler) {
		var container = jQuery("<div />").attr("params", paramString).
			attr("macroName", macroName).appendTo(place)[0];
		macro.refresh(container);
	},
	refresh: function(container) {
		jQuery(container).attr("refresh", "macro").empty();
		var paramString = jQuery(container).attr("params");
		var args = paramString.parseParams("anon", null, null)[0];
		var params = args.anon || [];

		var field = params[0] || "modified";
		var prefix = field.charAt(0);
		var no_prefix_field = prefix === "-" || prefix === "+" ? field.substr(1, field.length) : field;
		var dateFormat = params[2] || this.dateFormat;

		var groupTemplate = (args.groupTemplate ? store.getTiddlerText(args.groupTemplate[0]) : null)
			|| macro.groupTemplate.format(no_prefix_field, dateFormat);
		var itemTemplate = (args.template ? store.getTiddlerText(args.template[0]) : null)
			|| macro.itemTemplate;

		var tiddlers = args.filter ? store.sortTiddlers(store.filterTiddlers(args.filter[0]), field) :
			store.reverseLookup("tags", "excludeLists", false, field);
		var last = params[1] ? tiddlers.length - Math.min(tiddlers.length, parseInt(params[1], 10)) : 0;
		var lastGroup = "", ul;

		for(var i = tiddlers.length - 1; i >= last; i--) {
			var theGroup = wikifyPlainText(groupTemplate, 0, tiddlers[i]);
			if(ul === undefined || theGroup != lastGroup) {
				ul = createTiddlyElement(container, "ul", null, "timeline");
				createTiddlyElement(ul, "li", null, "listTitle", theGroup);
				lastGroup = theGroup;
			}
			var item = createTiddlyElement(ul, "li", null, "listLink");
			wikify(itemTemplate, item, null, tiddlers[i]);
		}
	},
	groupTemplate: "<<view %0 date '%1'>>",
	itemTemplate: "<<view title link>>"
});

config.macros.tiddler.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	var allowEval = true;
	var stack = config.macros.tiddler.tiddlerStack;
	if(stack.length > 0 && config.evaluateMacroParameters == "system") {
		// included tiddler and "system" evaluation required, so check tiddler tagged appropriately
		var title = stack[stack.length - 1];
		var pos = title.indexOf(config.textPrimitives.sectionSeparator);
		if(pos != -1) {
			title = title.substr(0, pos); // get the base tiddler title
		}
		var t = store.getTiddler(title);
		if(!t || t.tags.indexOf("systemAllowEval") == -1) {
			allowEval = false;
		}
	}
	params = paramString.parseParams("name", null, allowEval, false, true);
	var names = params[0]["name"];
	var tiddlerName = names[0];
	var className = names[1] || null;
	var args = params[0]["with"];

	var wrapper = createTiddlyElement(place, "span", null, className, null, {
		refresh: "content", tiddler: tiddlerName
	});
	if(args !== undefined)
		wrapper.macroArgs = args; // #154
	this.transclude(wrapper, tiddlerName, args);
};

config.macros.tiddler.transclude = function(wrapper, tiddlerName, args)
{
	var text = store.getTiddlerText(tiddlerName);
	if(!text) return;

	var stack = config.macros.tiddler.tiddlerStack;
	if(stack.indexOf(tiddlerName) !== -1) return;

	stack.push(tiddlerName);
	try {
		// substitute $1, $2, .. placeholders (markers)
		if(typeof args == "string")
			args = args.readBracketedList();
		var maxSupportedPlaceholders = 9; // $1 - $9
		var n = args ? args.length : 0;
		for(var i = 0; i < maxSupportedPlaceholders; i++) {
			var placeholderRE = new RegExp("\\$" + (i + 1), "mg");
			if(i < n) {
				text = text.replace(placeholderRE, args[i]);
			}
			// #162
			else if(n && config.options.chkRemoveExtraMarkers) {
				text = text.replace(placeholderRE, "");
			}
		}

		config.macros.tiddler.renderText(wrapper, text, tiddlerName);
	} finally {
		stack.pop();
	}
};

config.macros.tiddler.renderText = function(place, text, tiddlerName)
{
	wikify(text, place, null, store.getTiddler(tiddlerName));
};

config.macros.tiddler.tiddlerStack = [];

config.macros.tag.handler = function(place, macroName, params)
{
	var btn = createTagButton(place, params[0], null, params[1], params[2]);
	if(params[3]) btn.setAttribute('sortby', params[3]);
};

config.macros.tags.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	params = paramString.parseParams("anon", null, true, false, false);
	var title = getParam(params, "anon", "");
	if(title && store.tiddlerExists(title))
		tiddler = store.getTiddler(title);
	var sep = getParam(params, "sep", " ");
	var lingo = config.views.wikified.tag;

	var ul = createTiddlyElement(place, "ul");
	createTiddlyElement(ul, "li", null, "listTitle",
		(tiddler.tags.length ? lingo.labelTags : lingo.labelNoTags).format([tiddler.title])
	);
	for(var i = 0; i < tiddler.tags.length; i++) {
		var tag = store.getTiddler(tiddler.tags[i]);
		if(tag && tag.tags.indexOf("excludeLists") != -1) continue;
		createTagButton(createTiddlyElement(ul, "li"), tiddler.tags[i], tiddler.title);
		if(i < tiddler.tags.length - 1)
			createTiddlyText(ul, sep);
	}
};

config.macros.tagging.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	params = paramString.parseParams("anon", null, true, false, false);
	var title = getParam(params, "anon", "");
	if(title == "" && tiddler instanceof Tiddler)
		title = tiddler.title;
	var sep = getParam(params, "sep", " ");
	var sortby = getParam(params, "sortBy", false);
	var tagged = store.getTaggedTiddlers(title, sortby);
	var prompt = tagged.length == 0 ? this.labelNotTag : this.label;

	var ul = createTiddlyElement(place, "ul");
	ul.setAttribute("title", this.tooltip.format([title]));
	createTiddlyElement(ul, "li", null, "listTitle", prompt.format([title, tagged.length]));

	for(var i = 0; i < tagged.length; i++) {
		createTiddlyLink(createTiddlyElement(ul, "li"), tagged[i].title, true);
		if(i < tagged.length - 1)
			createTiddlyText(ul, sep);
	}
};

config.macros.closeAll.handler = function(place)
{
	createTiddlyButton(place, this.label, this.prompt, this.onClick);
};

config.macros.closeAll.onClick = function(e)
{
	story.closeAllTiddlers();
	return false;
};

config.macros.permaview.handler = function(place)
{
	createTiddlyButton(place, this.label, this.prompt, this.onClick);
};

config.macros.permaview.onClick = function(e)
{
	story.permaView();
	return false;
};

config.macros.saveChanges.handler = function(place, macroName, params)
{
	if(!readOnly)
		createTiddlyButton(place, params[0] || this.label, params[1] || this.prompt, this.onClick, null, null, this.accessKey);
};

config.macros.saveChanges.onClick = function(e)
{
	saveChanges();
	return false;
};

config.macros.slider.onClickSlider = function(ev)
{
	var n = this.nextSibling;
	var cookie = n.getAttribute("cookie");
	var isOpen = n.style.display != "none";
	if(config.options.chkAnimate && anim && typeof Slider == "function")
		anim.startAnimating(new Slider(n, !isOpen, null, "none"));
	else
		n.style.display = isOpen ? "none" : "block";
	config.options[cookie] = !isOpen;
	saveOption(cookie);
	return false;
};

config.macros.slider.createSlider = function(place, cookie, title, tooltip)
{
	var c = cookie || "";
	createTiddlyButton(place, title, tooltip, this.onClickSlider);
	var panel = createTiddlyElement(null, "div", null, "sliderPanel");
	panel.setAttribute("cookie", c);
	panel.style.display = config.options[c] ? "block" : "none";
	place.appendChild(panel);
	return panel;
};

config.macros.slider.handler = function(place, macroName, params)
{
	var panel = this.createSlider(place, params[0], params[2], params[3]);
	var text = store.getTiddlerText(params[1]);
	panel.setAttribute("refresh", "content");
	panel.setAttribute("tiddler", params[1]);
	if(text)
		wikify(text, panel, null, store.getTiddler(params[1]));
};

// <<gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... >>
config.macros.gradient.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	var panel = wikifier ? createTiddlyElement(place, "div", null, "gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel, styles);
	}
	params = paramString.parseParams("color");
	var loColors = [], hiColors = [];

	for(var i = 2; i < params.length; i++) {
		var c = params[i].value;
		if(params[i].name == "snap") {
			hiColors[hiColors.length - 1] = c;
		} else {
			loColors.push(c);
			hiColors.push(c);
		}
	}
	drawGradient(panel, params[1].value != "vert", loColors, hiColors);
	if(wikifier)
		wikifier.subWikify(panel, ">>");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

config.macros.message.handler = function(place, macroName, params)
{
	if(!params[0]) return;

	var names = params[0].split(".");
	var lookupMessage = function(root, nameIndex) {
		if(root[names[nameIndex]]) {
			if(nameIndex < names.length - 1)
				return (lookupMessage(root[names[nameIndex]], nameIndex + 1));
			else
				return root[names[nameIndex]];
		} else
			return null;
	};
	var m = lookupMessage(config, 0);
	if(m == null)
		m = lookupMessage(window, 0);
	createTiddlyText(place, m.toString().format(params.splice(1)));
};

config.macros.view.depth = 0;
config.macros.view.values = [];
config.macros.view.views = {
	text: function(value, place, params, wikifier, paramString, tiddler) {
		highlightify(value, place, highlightHack, tiddler);
	},
	link: function(value, place, params, wikifier, paramString, tiddler) {
		createTiddlyLink(place, value, true);
	},
	wikified: function(value, place, params, wikifier, paramString, tiddler) {
		if(config.macros.view.depth > 50)
			return;
		if(config.macros.view.depth > 0) {
			if (value == config.macros.view.values[config.macros.view.depth - 1]) {
				return;
			}
		}
		config.macros.view.values[config.macros.view.depth] = value;
		config.macros.view.depth++;
		if(params[2])
			value = params[2].unescapeLineBreaks().format([value]);
		wikify(value, place, highlightHack, tiddler);
		config.macros.view.depth--;
		config.macros.view.values[config.macros.view.depth] = null;
	},
	date: function(value, place, params, wikifier, paramString, tiddler) {
		value = Date.convertFromYYYYMMDDHHMM(value);
		createTiddlyText(place, value.formatString(params[2] || config.views.wikified.dateFormat));
	}
};

config.macros.view.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	if(!(tiddler instanceof Tiddler) || !params[0]) return;
	var value = store.getValue(tiddler, params[0]);
	if(!value) return;

	var type = params[1] || config.macros.view.defaultView;
	var handler = config.macros.view.views[type];
	if(handler)
		handler(value, place, params, wikifier, paramString, tiddler);
};

config.macros.edit.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	var field = params[0];
	var rows = params[1] || 0;
	var defaultValue = params[2] || '';
	if(!(tiddler instanceof Tiddler) || !field) return;

	story.setDirty(tiddler.title, true);
	var e, value = store.getValue(tiddler, field) || defaultValue;
	if(field != "text" && !rows) {
		e = createTiddlyElement(place, "input", null, null, null, {
			type: "text", edit: field, size: "40", autocomplete: "off"
		});
		e.value = value;
	} else {
		rows = rows || 10;
		var lines = value.match(/\n/mg);
		var maxLines = Math.max(parseInt(config.options.txtMaxEditRows), 5);
		if(lines != null && lines.length > rows)
			rows = lines.length + 5;
		rows = Math.min(rows, maxLines);

		var wrapper1 = createTiddlyElement(null, "fieldset", null, "fieldsetFix");
		var wrapper2 = createTiddlyElement(wrapper1, "div");
		e = createTiddlyElement(wrapper2, "textarea");
		e.value = value;
		e.setAttribute("rows", rows);
		e.setAttribute("edit", field);
		place.appendChild(wrapper1);
	}
	if(tiddler.isReadOnly()) {
		e.setAttribute("readOnly", "readOnly");
		jQuery(e).addClass("readOnly");
	}
	return e;
};

config.macros.tagChooser.onClick = function(ev)
{
	var e = ev || window.event;
	var lingo = config.views.editor.tagChooser;
	var popup = Popup.create(this);
	var tags = store.getTags(this.getAttribute("tags"));

	for(var i = 0; i < tags.length; i++) {
		var tag = createTiddlyButton(createTiddlyElement(popup, "li"), tags[i][0],
			lingo.tagTooltip.format([tags[i][0]]), config.macros.tagChooser.onTagClick);
		tag.setAttribute("tag", tags[i][0]);
		tag.setAttribute("tiddler", this.getAttribute("tiddler"));
	}
	if(tags.length == 0) jQuery("<li/>").addClass('disabled').text(lingo.popupNone).appendTo(popup);

	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
};

config.macros.tagChooser.onTagClick = function(ev)
{
	var e = ev || window.event;
	if(e.metaKey || e.ctrlKey) stopEvent(e); //# keep popup open on CTRL-click
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(!readOnly)
		story.setTiddlerTag(title, tag, 0);
	return false;
};

config.macros.tagChooser.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	if(!(tiddler instanceof Tiddler)) return;
	var lingo = config.views.editor.tagChooser;
	createTiddlyButton(place, lingo.text, lingo.tooltip, this.onClick, null, null, null, {
		tiddler: tiddler.title,
		tags: params[0]
	});
};

config.macros.refreshDisplay.handler = function(place)
{
	createTiddlyButton(place, this.label, this.prompt, this.onClick);
};

config.macros.refreshDisplay.onClick = function(e)
{
	refreshAll();
	return false;
};

config.macros.annotations.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	var title = tiddler ? tiddler.title : null;
	var annotation = title ? config.annotations[title] : null;
	if(!tiddler || !title || !annotation) return;
	var text = annotation.format([title]);
	wikify(text, createTiddlyElement(place, "div", null, "annotation"), null, tiddler);
};

//--
//-- NewTiddler and NewJournal macros
//--

config.macros.newTiddler.createNewTiddlerButton = function(place,
	title, params, label, prompt, accessKey, newFocus, isJournal)
{
	label = getParam(params, "label", label);
	prompt = getParam(params, "prompt", prompt);
	accessKey = getParam(params, "accessKey", accessKey);
	var customFields = getParam(params, "fields", "");
	if(!customFields && !store.isShadowTiddler(title))
		customFields = String.encodeHashMap(config.defaultCustomFields);
	var tags = [];
	for(var i = 1; i < params.length; i++) {
		if((params[i].name == "anon" && i != 1) || (params[i].name == "tag"))
			tags.push(params[i].value);
	}
	var text = getParam(params, "text");

	var btn = createTiddlyButton(place, label, prompt, this.onClickNewTiddler, null, null, accessKey, {
		newTitle: title,
		isJournal: isJournal ? "true" : "false",
		newFocus: getParam(params, "focus", newFocus),
		newTemplate: getParam(params, "template", DEFAULT_EDIT_TEMPLATE)
	});
	if(tags.length > 0)
		btn.setAttribute("params", tags.join("|"));
	if(customFields !== "")
		btn.setAttribute("customFields", customFields);
	if(text !== undefined)
		btn.setAttribute("newText", text);
	return btn;
};

config.macros.newTiddler.onClickNewTiddler = function()
{
	var title = this.getAttribute("newTitle");
	if(this.getAttribute("isJournal") == "true") {
		title = new Date().formatString(title.trim());
	}
	var params = this.getAttribute("params");
	var tags = params ? params.split("|") : [];
	var focus = this.getAttribute("newFocus");
	var template = this.getAttribute("newTemplate");
	var customFields = this.getAttribute("customFields");
	if(!customFields && !store.isShadowTiddler(title))
		customFields = String.encodeHashMap(config.defaultCustomFields);

	story.displayTiddler(this, title, template, false, null, null); // #161
	var tiddlerElem = story.getTiddler(title);
	if(customFields)
		story.addCustomFields(tiddlerElem, customFields);
	var text = this.getAttribute("newText");
	if(typeof text == "string" && story.getTiddlerField(title, "text"))
		story.getTiddlerField(title, "text").value = text.format([title]);
	for(var i = 0; i < tags.length; i++)
		story.setTiddlerTag(title, tags[i], +1);
	story.focusTiddler(title, focus);
	return false;
};

config.macros.newTiddler.handler = function(place, macroName, params, wikifier, paramString)
{
	if(readOnly) return;
	params = paramString.parseParams("anon", null, true, false, false);
	var title = params[1] && params[1].name == "anon" ? params[1].value : this.title;
	title = getParam(params, "title", title);
	this.createNewTiddlerButton(place, title, params, this.label, this.prompt, this.accessKey, "title", false);
};

config.macros.newJournal.handler = function(place, macroName, params, wikifier, paramString)
{
	if(readOnly) return;
	params = paramString.parseParams("anon", null, true, false, false);
	var title = params[1] && params[1].name == "anon" ? params[1].value : config.macros.timeline.dateFormat;
	title = getParam(params, "title", title);
	config.macros.newTiddler.createNewTiddlerButton(place, title,
		params, this.label, this.prompt, this.accessKey, "text", true);
};

//--
//-- Search macro
//--

config.macros.search.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	params = paramString.parseParams("anon", null, false, false, false);
	createTiddlyButton(place, this.label, this.prompt, this.onClick, "button searchButton");
	var attributes = {
		size: this.sizeTextbox,
		accessKey: getParam(params, "accesskey", this.accessKey),
		autocomplete: "off",
		lastSearchText: "",
		placeholder: getParam(params, "placeholder", this.placeholder)
	};
	if(config.browser.isSafari) {
		attributes.type = "search";
		attributes.results = "5";
	} else {
		attributes.type = "text";
	}
	var input = createTiddlyElement(place, "input", null, "txtOptionInput searchField", null, attributes);
	input.value = getParam(params, "anon", "");
	input.onkeyup = this.onKeyPress;
	input.onfocus = this.onFocus;
};

// Global because there's only ever one outstanding incremental search timer
config.macros.search.timeout = null;

config.macros.search.doSearch = function(input)
{
	if(input.value.length == 0) return;
	story.search(input.value, config.options.chkCaseSensitiveSearch, config.options.chkRegExpSearch);
	input.setAttribute("lastSearchText", input.value);
};

config.macros.search.onClick = function(e)
{
	config.macros.search.doSearch(this.nextSibling);
	return false;
};

config.macros.search.onKeyPress = function(ev)
{
	var me = config.macros.search;
	var e = ev || window.event;
	switch(e.keyCode) {
		case 9: // Tab
			return;
		case 13: // Ctrl-Enter
		case 10: // Ctrl-Enter on IE PC
			me.doSearch(this);
			break;
		case 27: // Escape
			this.value = "";
			clearMessage();
			break;
	}
	if(config.options.chkIncrementalSearch) {
		if(this.value.length > 2) {
			if(this.value != this.getAttribute("lastSearchText")) {
				if(me.timeout) clearTimeout(me.timeout);
				var input = this;
				me.timeout = setTimeout(function() { me.doSearch(input) }, 500);
			}
		} else {
			if(me.timeout) clearTimeout(me.timeout);
		}
	}
};

config.macros.search.onFocus = function(e)
{
	this.select();
};

//--
//-- Tabs macro
//--

config.macros.tabs.handler = function(place, macroName, params)
{
	var cookie = params[0];
	var numTabs = (params.length - 1) / 3;
	var wrapper = createTiddlyElement(null, "div", null, "tabsetWrapper " + cookie);
	var tabset = createTiddlyElement(wrapper, "div", null, "tabset");
	tabset.setAttribute("cookie", cookie);
	var validTab = false;
	for(var i = 0; i < numTabs; i++) {
		var label = params[i * 3 + 1];
		var prompt = params[i * 3 + 2];
		var content = params[i * 3 + 3];
		var tab = createTiddlyButton(tabset, label, prompt, this.onClickTab, "tab tabUnselected");
		createTiddlyElement(tab, "span", null, null, " ", { style: "font-size:0pt;line-height:0px" });
		tab.setAttribute("tab", label);
		tab.setAttribute("content", content);
		tab.title = prompt;
		if(config.options[cookie] == label)
			validTab = true;
	}
	if(!validTab)
		config.options[cookie] = params[1];
	place.appendChild(wrapper);
	this.switchTab(tabset, config.options[cookie]);
};

config.macros.tabs.onClickTab = function(e)
{
	config.macros.tabs.switchTab(this.parentNode, this.getAttribute("tab"));
	return false;
};

config.macros.tabs.switchTab = function(tabset, tab)
{
	var cookie = tabset.getAttribute("cookie");
	var theTab = null;
	var nodes = tabset.childNodes;
	for(var i = 0; i < nodes.length; i++) {
		if(nodes[i].getAttribute && nodes[i].getAttribute("tab") == tab) {
			theTab = nodes[i];
			theTab.className = "tab tabSelected";
		} else {
			nodes[i].className = "tab tabUnselected";
		}
	}
	if(!theTab) return;

	if(tabset.nextSibling && tabset.nextSibling.className == "tabContents")
		jQuery(tabset.nextSibling).remove();
	var tabContent = createTiddlyElement(null, "div", null, "tabContents");
	tabset.parentNode.insertBefore(tabContent, tabset.nextSibling);
	var contentTitle = theTab.getAttribute("content");
	wikify(store.getTiddlerText(contentTitle), tabContent, null, store.getTiddler(contentTitle));
	if(cookie) {
		config.options[cookie] = tab;
		saveOption(cookie);
	}
};

//--
//-- Tiddler toolbar
//--

// Create a toolbar command button
config.macros.toolbar.createCommand = function(place, commandName, tiddler, className)
{
	if(!(tiddler instanceof Tiddler)) return;
	if(typeof commandName != "string") {
		for(var name in config.commands) {
			if(config.commands[name] == commandName)
				commandName = name;
		}
	}
	if(typeof commandName != "string") return;
	var command = config.commands[commandName];
	if(command.isEnabled ? !command.isEnabled(tiddler) : !this.isCommandEnabled(command, tiddler))
		return;

	var text = command.getText ? command.getText(tiddler) : this.getCommandText(command, tiddler);
	var tooltip = command.getTooltip ? command.getTooltip(tiddler) : this.getCommandTooltip(command, tiddler);
	var cmd = command.type == "popup" ? this.onClickPopup : this.onClickCommand;
	var btn = createTiddlyButton(place, text, tooltip, cmd, "button command_" + commandName, null, null, {
		commandName: commandName,
		tiddler: tiddler.title
	});
	if(className) jQuery(btn).addClass(className);
	if(commandName === 'permalink') {
		jQuery(btn).attr('href', config.commands.permalink.getUrl(tiddler.title));
	}
};

config.macros.toolbar.isCommandEnabled = function(command, tiddler)
{
	var title = tiddler.title;
	var shadow = store.isShadowTiddler(title) && !store.tiddlerExists(title);
	if(shadow && command.hideShadow) return false;
	var ro = tiddler.isReadOnly();
	return !ro || (ro && !command.hideReadOnly);
};

config.macros.toolbar.getCommandText = function(command, tiddler)
{
	return (tiddler.isReadOnly() && command.readOnlyText) || command.text;
};

config.macros.toolbar.getCommandTooltip = function(command, tiddler)
{
	return (tiddler.isReadOnly() && command.readOnlyTooltip) || command.tooltip;
};

config.macros.toolbar.onClickCommand = function(ev)
{
	var e = ev || window.event;
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	var command = config.commands[this.getAttribute("commandName")];
	return command.handler(e, this, this.getAttribute("tiddler"));
};

config.macros.toolbar.onClickPopup = function(ev)
{
	var e = ev || window.event;
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	var popup = Popup.create(this);
	var title = this.getAttribute("tiddler");
	popup.setAttribute("tiddler", title);
	var command = config.commands[this.getAttribute("commandName")];
	command.handlePopup(popup, title);
	Popup.show();
	return false;
};

// Invoke the first command encountered from a given place that is tagged with a specified class
config.macros.toolbar.invokeCommand = function(place, className, event)
{
	var children = place.getElementsByTagName("a");
	for(var i = 0; i < children.length; i++) {
		var c = children[i];
		if(jQuery(c).hasClass(className) && c.getAttribute && c.getAttribute("commandName")) {
			if(c.onclick instanceof Function)
				c.onclick.call(c, event);
			break;
		}
	}
};

config.macros.toolbar.onClickMore = function(ev)
{
	var e = this.nextSibling;
	e.style.display = "inline";
	this.style.display = "none";
	return false;
};

config.macros.toolbar.onClickLess = function(ev)
{
	var e = this.parentNode;
	var m = e.previousSibling;
	e.style.display = "none";
	m.style.display = "inline";
	return false;
};

config.macros.toolbar.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	for(var i = 0; i < params.length; i++) {
		var commandName = params[i];
		switch(commandName) {
			case "!":
				createTiddlyText(place, this.separator);
				break;
			case "*":
				createTiddlyElement(place, "br");
				break;
			case "<":
				createTiddlyButton(place, this.lessLabel, this.lessPrompt,
					config.macros.toolbar.onClickLess, "button lessCommand");
				break;
			case ">":
				createTiddlyButton(place, this.moreLabel, this.morePrompt,
					config.macros.toolbar.onClickMore, "button moreCommand");
				place = createTiddlyElement(place, "span", null, "moreCommand");
				place.style.display = "none";
				break;
			default:
				var className = "";
				switch(commandName.substring(0, 1)) {
					case "+":
						className = "defaultCommand";
						commandName = commandName.substring(1);
						break;
					case "-":
						className = "cancelCommand";
						commandName = commandName.substring(1);
						break;
				}
				if(config.commands[commandName]) {
					this.createCommand(place, commandName, tiddler, className);
				} else {
					this.customCommand(place, commandName, wikifier, tiddler);
				}
				break;
		}
	}
};

// Overrideable function to extend toolbar handler
config.macros.toolbar.customCommand = function(place, command, wikifier, tiddler)
{
};

//--
//-- Menu and toolbar commands
//--

config.commands.closeTiddler.handler = function(event, src, title)
{
	if(story.isDirty(title) && !readOnly) {
		if(!confirm(config.commands.cancelTiddler.warning.format([title])))
			return false;
	}
	story.setDirty(title, false);
	story.closeTiddler(title, true);
	return false;
};

config.commands.closeOthers.handler = function(event, src, title)
{
	story.closeAllTiddlers(title);
	return false;
};

config.commands.editTiddler.handler = function(event, src, title)
{
	clearMessage();
	var tiddlerElem = story.getTiddler(title);
	var fields = tiddlerElem.getAttribute("tiddlyFields");
	story.displayTiddler(null, title, DEFAULT_EDIT_TEMPLATE, false, null, fields);

	var editorElement = story.getTiddlerField(title, config.options.txtEditorFocus || "text");
	if(editorElement) setCaretPosition(editorElement, 0);
	return false;
};

config.commands.saveTiddler.handler = function(event, src, title)
{
	var newTitle = story.saveTiddler(title, event.shiftKey);
	if(newTitle) story.displayTiddler(null, newTitle);
	return false;
};

config.commands.cancelTiddler.handler = function(event, src, title)
{
	if(story.hasChanges(title) && !readOnly) {
		if(!confirm(this.warning.format([title])))
			return false;
	}
	story.setDirty(title, false);
	story.displayTiddler(null, title);
	return false;
};

config.commands.deleteTiddler.handler = function(event, src, title)
{
	var deleteIt = true;
	if(config.options.chkConfirmDelete) deleteIt = confirm(this.warning.format([title]));
	if(!deleteIt) return false;

	store.removeTiddler(title);
	story.closeTiddler(title, true);
	autoSaveChanges();
	return false;
};

config.commands.permalink.getUrl = function(title) {
	var hash = story.getPermaViewHash([title]);
	return window.location.href.replace(/#.*/, hash);
};
config.commands.permalink.handler = function(event, src, title)
{
	var hash = story.getPermaViewHash([title]);
	if(window.location.hash != hash) window.location.hash = hash;
	return false;
};

config.commands.references.handlePopup = function(popup, title)
{
	var references = store.getReferringTiddlers(title);
	var hasRefs = false;
	for(var i = 0; i < references.length; i++) {
		if(references[i].title != title && !references[i].isTagged("excludeLists")) {
			createTiddlyLink(createTiddlyElement(popup, "li"), references[i].title, true);
			hasRefs = true;
		}
	}
	if(!hasRefs) createTiddlyElement(popup, "li", null, "disabled", this.popupNone);
};

config.commands.jump.handlePopup = function(popup, title)
{
	story.forEachTiddler(function(title, element) {
		createTiddlyLink(createTiddlyElement(popup, "li"), title, true, null, false, null, true);
	});
};

config.commands.fields.handlePopup = function(popup, title)
{
	var tiddler = store.fetchTiddler(title);
	if(!tiddler) return;
	var items = [];
	store.forEachField(tiddler, function(tiddler, fieldName, value) {
		items.push({ field: fieldName, value: value }); }, true);
	items.sort(function(a, b) { return a.field < b.field ? -1 : (a.field == b.field ? 0 : +1) });

	if(items.length > 0) {
		ListView.create(popup, items, this.listViewTemplate);
	} else {
		createTiddlyElement(popup, "li", null, "disabled", this.emptyText);
	}
};

//--
//-- Tiddler() object
//--

function Tiddler(title)
{
	this.title = title;
	this.text = "";
	this.creator = null;
	this.modifier = null;
	this.created = new Date();
	this.modified = this.created;
	this.links = [];
	this.linksUpdated = false;
	this.tags = [];
	this.fields = {};
	return this;
}

Tiddler.prototype.getLinks = function()
{
	if(this.linksUpdated == false) this.changed();
	return this.links;
};

// Returns the fields that are inherited in string field:"value" field2:"value2" format
Tiddler.prototype.getInheritedFields = function()
{
	var f = {};
	for(var i in this.fields) {
		if(i == "server.host" || i == "server.workspace" || i == "wikiformat" || i == "server.type") {
			f[i] = this.fields[i];
		}
	}
	return String.encodeHashMap(f);
};

// Increment the changeCount of a tiddler
Tiddler.prototype.incChangeCount = function()
{
	var c = this.fields['changecount'];
	c = c ? parseInt(c, 10) : 0;
	this.fields['changecount'] = String(c + 1);
};

Tiddler.prototype.clearChangeCount = function()
{
	if(this.fields['changecount']) {
		delete this.fields['changecount'];
	}
};

Tiddler.prototype.doNotSave = function()
{
	return this.fields['doNotSave'];
};

// Returns true if the tiddler has been updated since the tiddler was created or downloaded
Tiddler.prototype.isTouched = function()
{
	var changecount = this.fields.changecount || 0;
	return changecount > 0;
};

// Change the text and other attributes of a tiddler
Tiddler.prototype.set = function(title, text, modifier, modified, tags, created, fields, creator)
{
	this.assign(title, text, modifier, modified, tags, created, fields, creator);
	this.changed();
	return this;
};

// Change the text and other attributes of a tiddler without triggered a tiddler.changed() call
Tiddler.prototype.assign = function(title, text, modifier, modified, tags, created, fields, creator)
{
	if(title != undefined) this.title = title;
	if(text != undefined) this.text = text;
	if(modifier != undefined) this.modifier = modifier;
	if(modified != undefined) this.modified = modified;
	if(creator != undefined) this.creator = creator;
	if(created != undefined) this.created = created;
	if(fields != undefined) this.fields = fields;
	if(tags != undefined) this.tags = (typeof tags == "string") ? tags.readBracketedList() : tags;
	else if(this.tags == undefined) this.tags = [];
	return this;
};

// Get the tags for a tiddler as a string (space delimited, using [[brackets]] for tags containing spaces)
Tiddler.prototype.getTags = function()
{
	return String.encodeTiddlyLinkList(this.tags);
};

// Test if a tiddler carries a tag
Tiddler.prototype.isTagged = function(tag)
{
	return this.tags.indexOf(tag) != -1;
};

// Static method to convert "\n" to newlines, "\s" to "\"
Tiddler.unescapeLineBreaks = function(text)
{
	return text ? text.unescapeLineBreaks() : "";
};

// Convert newlines to "\n", "\" to "\s"
Tiddler.prototype.escapeLineBreaks = function()
{
	return this.text.escapeLineBreaks();
};

// Updates the secondary information (like .links array) after a change to a tiddler
Tiddler.prototype.changed = function()
{
	this.links = [];
	var text = this.text;
	// remove 'quoted' text before scanning tiddler source
	text = text.replace(/\/%((?:.|\n)*?)%\//g, "")
		.replace(/\{{3}((?:.|\n)*?)\}{3}/g, "")
		.replace(/"""((?:.|\n)*?)"""/g, "")
		.replace(/<nowiki\>((?:.|\n)*?)<\/nowiki\>/g, "")
		.replace(/<html\>((?:.|\n)*?)<\/html\>/g, "")
		.replace(/<script((?:.|\n)*?)<\/script\>/g, "");
	var t = this.autoLinkWikiWords() ? 0 : 1;
	var tiddlerLinkRegExp = t == 0 ?
		config.textPrimitives.tiddlerAnyLinkRegExp :
		config.textPrimitives.tiddlerForcedLinkRegExp;
	tiddlerLinkRegExp.lastIndex = 0;
	var formatMatch = tiddlerLinkRegExp.exec(text);
	while(formatMatch) {
		var lastIndex = tiddlerLinkRegExp.lastIndex;
		if(t == 0 && formatMatch[1] && formatMatch[1] != this.title) {
			// wikiWordLink
			if(formatMatch.index > 0) {
				var preRegExp = new RegExp(config.textPrimitives.unWikiLink + "|" +
					config.textPrimitives.anyLetter, "mg");
				preRegExp.lastIndex = formatMatch.index - 1;
				var preMatch = preRegExp.exec(text);
				if(preMatch.index != formatMatch.index - 1)
					this.links.pushUnique(formatMatch[1]);
			} else {
				this.links.pushUnique(formatMatch[1]);
			}
		}
		else if(formatMatch[2 - t] && !config.formatterHelpers.isExternalLink(formatMatch[3 - t]))
			// titledBrackettedLink
			this.links.pushUnique(formatMatch[3 - t]);
		else if(formatMatch[4 - t] && formatMatch[4 - t] != this.title) // brackettedLink
			this.links.pushUnique(formatMatch[4 - t]);
		tiddlerLinkRegExp.lastIndex = lastIndex;
		formatMatch = tiddlerLinkRegExp.exec(text);
	}
	this.linksUpdated = true;
};

Tiddler.prototype.getSubtitle = function()
{
	var modifier = this.modifier || config.messages.subtitleUnknown || "";
	var modified = this.modified ?
		this.modified.toLocaleString() :
		config.messages.subtitleUnknown || "";
	var f = config.messages.tiddlerLinkTooltip || "%0 - %1, %2";
	return f.format([this.title, modifier, modified]);
};

Tiddler.prototype.isReadOnly = function()
{
	return readOnly;
};

Tiddler.prototype.autoLinkWikiWords = function()
{
	return !(this.isTagged("systemConfig") || this.isTagged("excludeMissing"));
};

Tiddler.prototype.getServerType = function()
{
	var serverType = this.fields['server.type'] || this.fields['wikiformat'];
	if(serverType && !config.adaptors[serverType]) return null;
	return serverType;
};

Tiddler.prototype.getAdaptor = function()
{
	var serverType = this.getServerType();
	return serverType ? new config.adaptors[serverType]() : null;
};

//--
//-- TiddlyWiki instance contains TiddlerS
//--

function TiddlyWiki(params)
{
	var tiddlers = {}; // Hashmap by name of tiddlers
	if(params && params.config) {
		this.config = config;
	}
	this.tiddlersUpdated = false;
	this.namedNotifications = []; // Array of {name:,notify:} of notification functions
	this.notificationLevel = 0;
	this.slices = {}; // map tiddlerName->(map sliceName->sliceValue). Lazy.
	this.clear = function() {
		tiddlers = {};
		this.setDirty(false);
	};
	this.fetchTiddler = function(title) {
		var t = tiddlers[title];
		return t instanceof Tiddler ? t : null;
	};
	this.deleteTiddler = function(title) {
		delete this.slices[title];
		delete tiddlers[title];
	};
	this.addTiddler = function(tiddler) {
		delete this.slices[tiddler.title];
		tiddlers[tiddler.title] = tiddler;
	};
	this.forEachTiddler = function(callback) {
		for(var title in tiddlers) {
			var tiddler = tiddlers[title];
			if(tiddler instanceof Tiddler)
				callback.call(this, title, tiddler);
		}
	};
}

TiddlyWiki.prototype.setDirty = function(dirty)
{
	this.dirty = dirty;
};

TiddlyWiki.prototype.isDirty = function()
{
	return this.dirty;
};

TiddlyWiki.prototype.tiddlerExists = function(title)
{
	return this.fetchTiddler(title) != undefined;
};

TiddlyWiki.prototype.isShadowTiddler = function(title)
{
	return config.shadowTiddlers[title] === undefined ? false : true;
};

TiddlyWiki.prototype.isAvailable = function(title) {
	if(!title) return false;
	var i = title.indexOf(config.textPrimitives.sectionSeparator);
	if(i != -1) title = title.substring(0, i);
	return this.tiddlerExists(title) || this.isShadowTiddler(title);
};

TiddlyWiki.prototype.createTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler) {
		tiddler = new Tiddler(title);
		this.addTiddler(tiddler);
		this.setDirty(true);
	}
	return tiddler;
};

TiddlyWiki.prototype.getTiddler = function(title)
{
	return this.fetchTiddler(title) || null;
};

TiddlyWiki.prototype.getShadowTiddlerText = function(title)
{
	return (typeof config.shadowTiddlers[title] == "string")
		? config.shadowTiddlers[title]
		: "";
};

// Retrieve tiddler contents
TiddlyWiki.prototype.getTiddlerText = function(title, defaultText)
{
	if(!title) return defaultText;

	var pos = title.indexOf(config.textPrimitives.sectionSeparator);
	var section = null;
	if(pos != -1) {
		section = title.substr(pos + config.textPrimitives.sectionSeparator.length);
		title = title.substr(0, pos);
	}
	pos = title.indexOf(config.textPrimitives.sliceSeparator);
	if(pos != -1) {
		var sliceNameStart = pos + config.textPrimitives.sliceSeparator.length;
		var slice = this.getTiddlerSlice(title.substr(0, pos), title.substr(sliceNameStart));
		if(slice) return slice;
	}

	var tiddler = this.fetchTiddler(title);
	var text = tiddler ? tiddler.text : null;
	if(!tiddler && this.isShadowTiddler(title)) {
		text = this.getShadowTiddlerText(title);
	}
	if(!text) return defaultText != undefined ? defaultText : null;
	if(!section) return text;

	var headerRE = new RegExp("(^!{1,6}[ \t]*" + section.escapeRegExp() + "[ \t]*\n)", "mg");
	headerRE.lastIndex = 0;
	var match = headerRE.exec(text);
	if(!match) return defaultText;

	var t = text.substr(match.index + match[1].length);
	var nextHeaderRE = /^!/mg;
	nextHeaderRE.lastIndex = 0;
	match = nextHeaderRE.exec(t);
	return !match ? t :
		// don't include final \n
		t.substr(0, match.index - 1);
};

TiddlyWiki.prototype.getRecursiveTiddlerText = function(title, defaultText, depth)
{
	var text = this.getTiddlerText(title, null);
	if(text == null) return defaultText;

	var bracketRegExp = new RegExp("(?:\\[\\[([^\\]]+)\\]\\])", "mg");
	var textOut = [], match, lastPos = 0;
	do {
		if(match = bracketRegExp.exec(text)) {
			textOut.push(text.substr(lastPos, match.index - lastPos));
			if(match[1]) {
				if(depth <= 0)
					textOut.push(match[1]);
				else
					textOut.push(this.getRecursiveTiddlerText(match[1], "", depth - 1));
			}
			lastPos = match.index + match[0].length;
		} else {
			textOut.push(text.substr(lastPos));
		}
	} while(match);
	return textOut.join("");
};

//TiddlyWiki.prototype.slicesRE = /(?:^([\'\/]{0,2})~?([\.\w]+)\:\1[\t\x20]*([^\n]+)[\t\x20]*$)|(?:^\|([\'\/]{0,2})~?([\.\w]+)\:?\4\|[\t\x20]*([^\n]+)[\t\x20]*\|$)/gm;
TiddlyWiki.prototype.slicesRE = /(?:^([\'\/]{0,2})~?([\.\w]+)\:\1[\t\x20]*([^\n]+)[\t\x20]*$)|(?:^\|\x20?([\'\/]{0,2})~?([^\|\s\:\~\'\/]|(?:[^\|\s~\'\/][^\|\n\f\r]*[^\|\s\:\'\/]))\:?\4[\x20\t]*\|[\t\x20]*([^\n\t\x20](?:[^\n]*[^\n\t\x20])?)[\t\x20]*\|$)/gm; // #112
// @internal
TiddlyWiki.prototype.calcAllSlices = function(title)
{
	var text = this.getTiddlerText(title, "");
	this.slicesRE.lastIndex = 0;
	var slices = {}, m;
	while(m = this.slicesRE.exec(text)) {
		if(m[2])
			slices[m[2]] = m[3];
		else
			slices[m[5]] = m[6];
	}
	return slices;
};

// Returns the slice of text of the given name
TiddlyWiki.prototype.getTiddlerSlice = function(title, sliceName)
{
	var slices = this.slices[title];
	if(!slices) {
		slices = this.calcAllSlices(title);
		this.slices[title] = slices;
	}
	return slices[sliceName];
};

// Build an hashmap of the specified named slices of a tiddler
TiddlyWiki.prototype.getTiddlerSlices = function(title, sliceNames)
{
	var i, r = {};
	for(i = 0; i < sliceNames.length; i++) {
		var slice = this.getTiddlerSlice(title, sliceNames[i]);
		if(slice) r[sliceNames[i]] = slice;
	}
	return r;
};

TiddlyWiki.prototype.suspendNotifications = function()
{
	this.notificationLevel--;
};

TiddlyWiki.prototype.resumeNotifications = function()
{
	this.notificationLevel++;
};

// Invoke the notification handlers for a particular tiddler
TiddlyWiki.prototype.notify = function(title, doBlanket)
{
	if(this.notificationLevel) return;
	for(var i = 0; i < this.namedNotifications.length; i++) {
		var n = this.namedNotifications[i];
		if((n.name == null && doBlanket) || (n.name == title))
			n.notify(title);
	}
};

// Invoke the notification handlers for all tiddlers
TiddlyWiki.prototype.notifyAll = function()
{
	if(this.notificationLevel) return;
	for(var i = 0; i < this.namedNotifications.length; i++) {
		var n = this.namedNotifications[i];
		if(n.name)
			n.notify(n.name);
	}
};

// Add a notification handler to a tiddler unless it's already set
TiddlyWiki.prototype.addNotification = function(title, fn)
{
	for(var i = 0; i < this.namedNotifications.length; i++) {
		if((this.namedNotifications[i].name == title) && (this.namedNotifications[i].notify == fn))
			return this;
	}
	this.namedNotifications.push({ name: title, notify: fn });
	return this;
};

TiddlyWiki.prototype.removeTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		this.deleteTiddler(title);
		this.notify(title, true);
		this.setDirty(true);
	}
};

// Reset the sync status of a freshly synced tiddler
TiddlyWiki.prototype.resetTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		tiddler.clearChangeCount();
		this.notify(title, true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.setTiddlerTag = function(title, status, tag)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler) return;

	var t = tiddler.tags.indexOf(tag);
	if(t != -1)
		tiddler.tags.splice(t, 1);
	if(status)
		tiddler.tags.push(tag);

	tiddler.changed();
	tiddler.incChangeCount();
	this.notify(title, true);
	this.setDirty(true);
};

TiddlyWiki.prototype.addTiddlerFields = function(title, fields)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler) return;

	merge(tiddler.fields, fields);
	tiddler.changed();
	tiddler.incChangeCount();
	this.notify(title, true);
	this.setDirty(true);
};

// Store tiddler in TiddlyWiki instance
TiddlyWiki.prototype.saveTiddler = function(titleOrTiddler, newTitle, newBody,
	modifier, modified, tags, fields, clearChangeCount, created, creator)
{
	var wasTiddlerProvided = titleOrTiddler instanceof Tiddler;
	var tiddler = this.resolveTiddler(titleOrTiddler);
	var title = tiddler ? tiddler.title : titleOrTiddler;
	newTitle = newTitle || title;

	if(tiddler) {
		this.deleteTiddler(title); //# clean up slices for title, make sure the tiddler is not copied when renamed
		created = created || tiddler.created; // Preserve created date
		creator = creator || tiddler.creator;
	} else {
		tiddler = new Tiddler();
		created = created || modified;
	}

	if(wasTiddlerProvided) {
		tiddler.fields = merge(merge({}, tiddler.fields), config.defaultCustomFields, true);
	} else {
		fields = merge(merge({}, fields), config.defaultCustomFields, true);
		tiddler.set(newTitle, newBody, modifier, modified, tags, created, fields, creator);
	}
	if(clearChangeCount)
		tiddler.clearChangeCount();
	else
		tiddler.incChangeCount();

	this.addTiddler(tiddler); //# clean up slices for newTitle, add/return the tiddler
	if(title != newTitle) this.notify(title, true);
	this.notify(newTitle, true);
	this.setDirty(true);

	return tiddler;
};

TiddlyWiki.prototype.incChangeCount = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler)
		tiddler.incChangeCount();
};

TiddlyWiki.prototype.getLoader = function()
{
	if(!this.loader)
		this.loader = new TW21Loader();
	return this.loader;
};

TiddlyWiki.prototype.getSaver = function()
{
	if(!this.saver)
		this.saver = new TW21Saver();
	return this.saver;
};

// Return all tiddlers formatted as an HTML string
TiddlyWiki.prototype.allTiddlersAsHtml = function()
{
	return this.getSaver().externalize(store);
};

// Load contents of a TiddlyWiki from an HTML DIV
TiddlyWiki.prototype.loadFromDiv = function(src, idPrefix, noUpdate)
{
	var storeElem = (typeof src == "string") ? document.getElementById(src) : src;
	if(!storeElem) return;

	this.idPrefix = idPrefix;
	var tiddlers = this.getLoader().loadTiddlers(this, storeElem.childNodes);
	this.setDirty(false);
	if(!noUpdate) {
		for(var i = 0; i < tiddlers.length; i++)
			tiddlers[i].changed();
	}
	jQuery(document).trigger("loadTiddlers");
};

// Load contents of a TiddlyWiki from a string
// Returns null if there's an error
TiddlyWiki.prototype.importTiddlyWiki = function(text)
{
	var posDiv = locateStoreArea(text);
	if(!posDiv) return null;
	var content = "<" + "html><" + "body>" + text.substring(posDiv[0], posDiv[1] + endSaveArea.length) + "<" + "/body><" + "/html>";

	// Create an iframe
	var iframe = document.createElement("iframe");
	iframe.style.display = "none";
	document.body.appendChild(iframe);
	var doc = iframe.document;
	if(iframe.contentDocument)
		doc = iframe.contentDocument; // For NS6
	else if(iframe.contentWindow)
		doc = iframe.contentWindow.document; // For IE5.5 and IE6

	// Put the content in the iframe
	doc.open();
	doc.writeln(content);
	doc.close();

	// Load the content into a TiddlyWiki() object
	var storeArea = doc.getElementById("storeArea");
	this.loadFromDiv(storeArea, "store");

	iframe.parentNode.removeChild(iframe);
	return this;
};

TiddlyWiki.prototype.updateTiddlers = function()
{
	this.tiddlersUpdated = true;
	this.forEachTiddler(function(title, tiddler) {
		tiddler.changed();
	});
};

// Return an array of tiddlers matching a search regular expression
TiddlyWiki.prototype.search = function(searchRegExp, sortField, excludeTag, match)
{
	var candidates = this.reverseLookup("tags", excludeTag, !!match);
	var i, results = [];
	for(i = 0; i < candidates.length; i++) {
		if((candidates[i].title.search(searchRegExp) != -1) || (candidates[i].text.search(searchRegExp) != -1))
			results.push(candidates[i]);
	}
	if(!sortField) sortField = "title";
	results.sort(function(a, b) { return a[sortField] < b[sortField] ? -1 : (a[sortField] == b[sortField] ? 0 : +1) });
	return results;
};

// Returns a list of all tags in use (in the form of an array of [tagName, numberOfOccurances] "tuples")
//   excludeTag - if present, excludes tags that are themselves tagged with excludeTag
TiddlyWiki.prototype.getTags = function(excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title, tiddler) {
	    var i, j;
		for(i = 0; i < tiddler.tags.length; i++) {
			var tag = tiddler.tags[i];
			var isTagToAdd = true;
			for(j = 0; j < results.length; j++) {
				if(results[j][0] == tag) {
					isTagToAdd = false;
					results[j][1]++;
				}
			}
			if(isTagToAdd && excludeTag) {
				var t = this.fetchTiddler(tag);
				if(t && t.isTagged(excludeTag))
					isTagToAdd = false;
			}
			if(isTagToAdd) results.push([tag, 1]);
		}
	});
	results.sort(function(a, b) {
		var tag1 = a[0].toLowerCase(), tag2 = b[0].toLowerCase();
		return tag1 < tag2 ? -1 : (tag1 == tag2 ? 0 : +1);
	});
	return results;
};

// Return an array of the tiddlers that are tagged with a given tag
TiddlyWiki.prototype.getTaggedTiddlers = function(tag, sortField)
{
	return this.reverseLookup("tags", tag, true, sortField);
};

TiddlyWiki.prototype.getValueTiddlers = function(field, value, sortField)
{
	return this.reverseLookup(field, value, true, sortField);
};

// Return an array of the tiddlers that link to a given tiddler
TiddlyWiki.prototype.getReferringTiddlers = function(title, unusedParameter, sortField)
{
	if(!this.tiddlersUpdated)
		this.updateTiddlers();
	return this.reverseLookup("links", title, true, sortField);
};

// Return an array of the tiddlers that have a specified entry (lookupValue) in the specified field (lookupField, like "links" or "tags")
// if shouldMatch == true, or don't have such entry (if shouldMatch == false)
TiddlyWiki.prototype.reverseLookup = function(lookupField, lookupValue, shouldMatch, sortField)
{
	var results = [];
	this.forEachTiddler(function(title, tiddler) {
		var values;
		if(["links", "tags"].contains(lookupField)) {
			values = tiddler[lookupField];
		} else {
			var accessor = TiddlyWiki.standardFieldAccess[lookupField];
			values = accessor ? [ accessor.get(tiddler) ] :
				( tiddler.fields[lookupField] ? [tiddler.fields[lookupField]] : [] );
		}

		var hasMatch = false;
		for(var i = 0; i < values.length; i++) {
			if(values[i] == lookupValue)
				hasMatch = true;
		}
		if(hasMatch == !!shouldMatch) results.push(tiddler);
	});
	return this.sortTiddlers(results, sortField || "title");
};

// Return the tiddlers as a sorted array
TiddlyWiki.prototype.getTiddlers = function(field, excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title, tiddler) {
		if(excludeTag == undefined || !tiddler.isTagged(excludeTag))
			results.push(tiddler);
	});
	if(field) results.sort(function(a, b) { return a[field] < b[field] ? -1 : (a[field] == b[field] ? 0 : +1) });
	return results;
};

// Return array of names of tiddlers that are referred to but not defined
TiddlyWiki.prototype.getMissingLinks = function()
{
	if(!this.tiddlersUpdated) this.updateTiddlers();

	var results = [];
	this.forEachTiddler(function (title, tiddler) {
		if(tiddler.isTagged("excludeMissing") || tiddler.isTagged("systemConfig"))
			return;

		for(var i = 0; i < tiddler.links.length; i++) {
			var link = tiddler.links[i];
			if(this.getTiddlerText(link, null) == null && !this.isShadowTiddler(link) && !config.macros[link])
				results.pushUnique(link);
		}
	});
	results.sort();
	return results;
};

// Return an array of names of tiddlers that are defined but not referred to
TiddlyWiki.prototype.getOrphans = function()
{
	var results = [];
	this.forEachTiddler(function (title, tiddler) {
		if(this.getReferringTiddlers(title).length == 0 && !tiddler.isTagged("excludeLists"))
			results.push(title);
	});
	results.sort();
	return results;
};

// Return an array of names of all the shadow tiddlers
TiddlyWiki.prototype.getShadowed = function()
{
	var t, results = [];
	for(t in config.shadowTiddlers) {
		if(this.isShadowTiddler(t))
			results.push(t);
	}
	results.sort();
	return results;
};

// Return an array of tiddlers that have been touched since they were downloaded or created
TiddlyWiki.prototype.getTouched = function()
{
	var results = [];
	this.forEachTiddler(function(title, tiddler) {
		if(tiddler.isTouched())
			results.push(tiddler);
	});
	results.sort();
	return results;
};

// Resolves a Tiddler reference or tiddler title into a Tiddler object, or null if it doesn't exist
TiddlyWiki.prototype.resolveTiddler = function(tiddler)
{
	var t = (typeof tiddler == "string") ? this.getTiddler(tiddler) : tiddler;
	return t instanceof Tiddler ? t : null;
};

// Sort a list of tiddlers
TiddlyWiki.prototype.sortTiddlers = function(tiddlers, field)
{
	var asc = +1;
	switch(field.substr(0, 1)) {
		case "-":
			asc = -1;
			field = field.substr(1);
			break;
		case "+":
			field = field.substr(1);
			break;
	}
	if(TiddlyWiki.standardFieldAccess[field]) {
		if(field == "title") {
			tiddlers.sort(function(a, b) {
				var t1 = a[field].toLowerCase(), t2 = b[field].toLowerCase();
				return t1 < t2 ? -asc : (t1 == t2 ? 0 : asc);
			});
		} else {
			tiddlers.sort(function(a, b) {
				return a[field] < b[field] ? -asc : (a[field] == b[field] ? 0 : asc);
			});
		}
	} else {
		tiddlers.sort(function(a, b) {
			return a.fields[field] < b.fields[field] ? -asc : (a.fields[field] == b.fields[field] ? 0 : +asc);
		});
	}
	return tiddlers;
};

//--
//-- Filter a list of tiddlers
//--

config.filters = {
	tiddler: function(results, match) {
		var title = match[1] || match[4];
		var tiddler = this.fetchTiddler(title);
		if(tiddler) {
			results.pushUnique(tiddler);
		} else if(this.isShadowTiddler(title)) {
			tiddler = new Tiddler();
			tiddler.set(title, this.getTiddlerText(title));
			results.pushUnique(tiddler);
		} else {
			results.pushUnique(new Tiddler(title));
		}
		return results;
	},
	tag: function(results, match) {
		var i, matched = this.getTaggedTiddlers(match[3]);
		for(i = 0; i < matched.length; i++) {
			results.pushUnique(matched[i]);
		}
		return results;
	},
	sort: function(results, match) {
		return this.sortTiddlers(results, match[3]);
	},
	limit: function(results, match) {
		return results.slice(0, parseInt(match[3], 10));
	},
	field: function(results, match) {
		var i, matched = this.getValueTiddlers(match[2], match[3]);
		for (i = 0; i < matched.length; i++) {
			results.pushUnique(matched[i]);
		}
		return results;
	}
};

// Filter a list of tiddlers
TiddlyWiki.prototype.filterTiddlers = function(filter, results)
{
	var re = /([^\s\[\]]+)|(?:\[([ \w\.\-]+)\[([^\]]+)\]\])|(?:\[\[([^\]]+)\]\])/mg;

	results = results || [];
	if(filter) {
		var match;
		while(match = re.exec(filter)) {
			var handler = (match[1] || match[4]) ? 'tiddler' :
				config.filters[match[2]] ? match[2] : 'field';
			results = config.filters[handler].call(this, results, match);
		}
	}
	return results;
};

// Returns true if path is a valid field name (path),
// i.e. a sequence of identifiers, separated by "."
TiddlyWiki.isValidFieldName = function(name)
{
	var match = /[a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*/.exec(name);
	return match && (match[0] == name);
};

// Throws an exception when name is not a valid field name.
TiddlyWiki.checkFieldName = function(name)
{
	if(!TiddlyWiki.isValidFieldName(name))
		throw config.messages.invalidFieldName.format([name]);
};

function StringFieldAccess(fName, readOnly)
{
	this.set = readOnly ?
		function(tiddler, newValue) {
			if(newValue != tiddler[fName]) throw config.messages.fieldCannotBeChanged.format([fName]);
		} :
		function(tiddler, newValue) {
			if(newValue == tiddler[fName]) return;
			tiddler[fName] = newValue;
			return true;
		};
	this.get = function(tiddler) { return tiddler[fName] };
}

function DateFieldAccess(fName)
{
	this.set = function(tiddler, newValue) {
		var d = newValue instanceof Date ? newValue : Date.convertFromYYYYMMDDHHMM(newValue);
		if(d == tiddler[fName]) return;
		tiddler[fName] = d;
		return true;
	};
	this.get = function(tiddler) { return tiddler[fName].convertToYYYYMMDDHHMM() };
}

function LinksFieldAccess(fName)
{
	this.set = function(tiddler, newValue) {
		var items = (typeof newValue == "string") ? newValue.readBracketedList() : newValue;
		if(items.toString() == tiddler[fName].toString()) return;
		tiddler[fName] = items;
		return true;
	};
	this.get = function(tiddler) { return String.encodeTiddlyLinkList(tiddler[fName]) };
}

TiddlyWiki.standardFieldAccess = {
	// The set functions return true when setting the data has changed the value.
	"title":    new StringFieldAccess("title", true),
	// Handle the "tiddler" field name as the title
	"tiddler":  new StringFieldAccess("title", true),
	"text":     new StringFieldAccess("text"),
	"modifier": new StringFieldAccess("modifier"),
	"modified": new DateFieldAccess("modified"),
	"creator":  new StringFieldAccess("creator"),
	"created":  new DateFieldAccess("created"),
	"tags":     new LinksFieldAccess("tags")
};

TiddlyWiki.isStandardField = function(name)
{
	return TiddlyWiki.standardFieldAccess[name] != undefined;
};

// Sets the value of the given field of the tiddler to the value.
// Setting an ExtendedField's value to null or undefined removes the field.
// Setting a namespace to undefined removes all fields of that namespace.
// The fieldName is case-insensitive.
// All values will be converted to a string value.
TiddlyWiki.prototype.setValue = function(tiddlerOrTitle, fieldName, value)
{
	TiddlyWiki.checkFieldName(fieldName);
	var t = this.resolveTiddler(tiddlerOrTitle);
	if(!t) return;

	fieldName = fieldName.toLowerCase();
	var isRemove = (value === undefined) || (value === null);
	var accessor = TiddlyWiki.standardFieldAccess[fieldName];
	if(accessor) {
		// don't remove StandardFields
		if(isRemove) return;
		if(!accessor.set(t, value)) return;
	} else {
		var oldValue = t.fields[fieldName];
		if(isRemove) {
			if(oldValue !== undefined) {
				// deletes a single field
				delete t.fields[fieldName];
			} else {
				// no concrete value is defined for the fieldName
				// so we guess this is a namespace path.
				// delete all fields in a namespace
				var re = new RegExp("^" + fieldName + "\\.");
				var dirty = false;
				for(var n in t.fields) {
					if(n.match(re)) {
						delete t.fields[n];
						dirty = true;
					}
				}
				if(!dirty) return;
			}
		} else {
			// the "normal" set case. value is defined (not null/undefined)
			// For convenience convert Date -> String
			value = value instanceof Date ? value.convertToYYYYMMDDHHMMSSMMM() : String(value);
			if(oldValue == value) return;
			t.fields[fieldName] = value;
		}
	}

	// When we are here the tiddler/store really was changed.
	this.notify(t.title, true);
	if(!fieldName.match(/^temp\./))
		this.setDirty(true);
};

// Returns the value of the given field of the tiddler.
// The fieldName is case-insensitive.
// Will only return String values (or undefined).
TiddlyWiki.prototype.getValue = function(tiddlerOrTitle, fieldName)
{
	var t = this.resolveTiddler(tiddlerOrTitle);
	if(!t) return undefined;

	if(fieldName.indexOf(config.textPrimitives.sectionSeparator) === 0 ||
	   fieldName.indexOf(config.textPrimitives.sliceSeparator) === 0
	) {
		var separator = fieldName.substr(0, 2);
		var partName = fieldName.substring(2);
		return store.getTiddlerText(t.title + separator + partName);
	} else {
		fieldName = fieldName.toLowerCase();
		var accessor = TiddlyWiki.standardFieldAccess[fieldName];
		if(accessor) return accessor.get(t);
	}
	return t.fields[fieldName];
};

// Calls the callback function for every field in the tiddler.
// When callback function returns a non-false value the iteration stops
// and that value is returned.
// The order of the fields is not defined.
// @param callback a function(tiddler, fieldName, value).
TiddlyWiki.prototype.forEachField = function(tiddlerOrTitle, callback, onlyExtendedFields)
{
	var t = this.resolveTiddler(tiddlerOrTitle);
	if(!t) return undefined;

	var name, result;
	for(name in t.fields) {
		result = callback(t, name, t.fields[name]);
		if(result) return result;
	}

	if(onlyExtendedFields) return undefined;
	for(name in TiddlyWiki.standardFieldAccess) {
		// even though the "title" field can also be referenced through the name "tiddler"
		// we only visit this field once.
		if(name == "tiddler") continue;

		result = callback(t, name, TiddlyWiki.standardFieldAccess[name].get(t));
		if(result) return result;
	}
	return undefined;
};

//--
//-- Story functions
//--

// A story is a HTML div containing a sequence of tiddlers that can be manipulated
//  container - id of containing element
//  idPrefix - string prefix prepended to title to make ids for tiddlers in this story
function Story(containerId, idPrefix)
{
	this.container = containerId;
	this.idPrefix = idPrefix;
	this.highlightRegExp = null;
	this.tiddlerId = function(title) {
		var validId = title.replace(/_/g, "__").replace(/ /g, "_");
		var id = this.idPrefix + validId;
		return id == this.container ? this.idPrefix + "_" + validId : id;
	};
	this.containerId = function() {
		return this.container;
	};
}

Story.prototype.getTiddler = function(title)
{
	return document.getElementById(this.tiddlerId(title));
};

Story.prototype.getContainer = function()
{
	return document.getElementById(this.containerId());
};

Story.prototype.forEachTiddler = function(handleTiddler)
{
	var place = this.getContainer();
	if(!place) return;
	var el = place.firstChild;
	while(el) {
		var next = el.nextSibling;
		var title = el.getAttribute("tiddler");
		if(title) {
			handleTiddler.call(this, title, el);
		}
		el = next;
	}
};

Story.prototype.displayTiddler = function(srcElement, tiddler,
	template, animate, unused, customFields, toggle, animationSrc)
{
	var title = (tiddler instanceof Tiddler) ? tiddler.title : tiddler;
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem) {
		if(toggle) {
			if(tiddlerElem.getAttribute("dirty") != "true")
				this.closeTiddler(title, true);
		} else {
			this.refreshTiddler(title, template, false, customFields);
		}
	} else {
		var place = this.getContainer();
		var before = this.positionTiddler(srcElement);
		tiddlerElem = this.createTiddler(place, before, title, template, customFields);
	}

	if(animationSrc && typeof animationSrc !== "string") {
		srcElement = animationSrc;
	}
	if(srcElement && typeof srcElement !== "string") {
		if(config.options.chkAnimate && (animate == undefined || animate == true) && anim &&
		   typeof Zoomer == "function" && typeof Scroller == "function")
			anim.startAnimating(new Zoomer(title, srcElement, tiddlerElem), new Scroller(tiddlerElem));
		else
			window.scrollTo(0, ensureVisible(tiddlerElem));
	}
	return tiddlerElem;
};

Story.prototype.displayTiddlers = function(srcElement, titles, template, animate, unused, customFields, toggle)
{
	for(var i = titles.length - 1; i >= 0; i--)
		this.displayTiddler(srcElement, titles[i], template, animate, unused, customFields);
};

Story.prototype.displayDefaultTiddlers = function()
{
	this.displayTiddlers(null, store.filterTiddlers(store.getTiddlerText("DefaultTiddlers")));
};

Story.prototype.positionTiddler = function(srcElement)
{
	var place = this.getContainer();
	var before = null;
	if(typeof srcElement == "string") {
		switch(srcElement) {
			case "top":
				before = place.firstChild;
				break;
			case "bottom":
				before = null;
				break;
		}
	} else {
		var after = this.findContainingTiddler(srcElement);
		if(after == null) {
			before = place.firstChild;
		} else if(after.nextSibling) {
			before = after.nextSibling;
			if(before.nodeType != 1)
				before = null;
		}
	}
	return before;
};

Story.prototype.createTiddler = function(place, before, title, template, customFields)
{
	var tiddlerElem = createTiddlyElement(null, "div", this.tiddlerId(title), "tiddler");
	tiddlerElem.setAttribute("refresh", "tiddler");
	if(customFields)
		tiddlerElem.setAttribute("tiddlyFields", customFields);
	place.insertBefore(tiddlerElem, before);
	var defaultText = null;
	if(!store.tiddlerExists(title) && !store.isShadowTiddler(title))
		defaultText = this.loadMissingTiddler(title, customFields);
	this.refreshTiddler(title, template, false, customFields, defaultText);
	return tiddlerElem;
};

Story.prototype.loadMissingTiddler = function(title, fields, callback)
{
	var tiddler = new Tiddler(title);
	tiddler.fields = typeof fields == "string" ? fields.decodeHashMap() : fields || {};
	var context = { serverType: tiddler.getServerType() };
	if(!context.serverType) return "";
	context.host = tiddler.fields['server.host'];
	context.workspace = tiddler.fields['server.workspace'];
	var adaptor = new config.adaptors[context.serverType]();

	var onLoadTiddlerResponse = function(context)
	{
		if(context.status) {
			var t = context.tiddler;
			t.created  = t.created  || new Date();
			t.modified = t.modified || t.created;
			var dirty = store.isDirty();
			context.tiddler = store.saveTiddler(t.title, t.title, t.text, t.modifier, t.modified,
				t.tags, t.fields, true, t.created, t.creator);
			if(!window.allowSave())
				store.setDirty(dirty);
			autoSaveChanges();
		} else {
			story.refreshTiddler(context.title, null, true);
		}
		context.adaptor.close();
		if(callback) callback(context);
	};
	adaptor.getTiddler(title, context, null, onLoadTiddlerResponse);
	return config.messages.loadingMissingTiddler.format([title, context.serverType, context.host, context.workspace]);
};

Story.prototype.chooseTemplateForTiddler = function(title, template)
{
	if(!template)
		template = DEFAULT_VIEW_TEMPLATE;
	if(template == DEFAULT_VIEW_TEMPLATE || template == DEFAULT_EDIT_TEMPLATE)
		template = config.tiddlerTemplates[template];
	return template;
};

Story.prototype.getTemplateForTiddler = function(title, template, tiddler)
{
	return store.getRecursiveTiddlerText(template, null, 10);
};

Story.prototype.refreshTiddler = function(title, template, force, customFields, defaultText)
{
	var tiddlerElem = this.getTiddler(title);
	if(!tiddlerElem) return null;

	if(tiddlerElem.getAttribute("dirty") == "true" && !force)
		return tiddlerElem;
	template = this.chooseTemplateForTiddler(title, template);
	var currTemplate = tiddlerElem.getAttribute("template");
	if((template == currTemplate) && !force)
		return tiddlerElem;

	var tiddler = store.getTiddler(title);
	if(!tiddler) {
		tiddler = new Tiddler();
		if(store.isShadowTiddler(title)) {
			var tags = [];
			tiddler.set(title, store.getTiddlerText(title),
				config.views.wikified.shadowModifier, version.date, tags, version.date);
		} else {
			var text = template == config.tiddlerTemplates[DEFAULT_EDIT_TEMPLATE] // #166
				? config.views.editor.defaultText.format([title])
				: config.views.wikified.defaultText.format([title]);
			text = defaultText || text;
			var fields = customFields ? customFields.decodeHashMap() : null;
			tiddler.set(title, text, config.views.wikified.defaultModifier, version.date, [], version.date, fields);
		}
	}

	tiddlerElem.setAttribute("tags", tiddler.tags.join(" "));
	tiddlerElem.setAttribute("tiddler", title);
	tiddlerElem.setAttribute("template", template);
	tiddlerElem.onmouseover = this.onTiddlerMouseOver;
	tiddlerElem.onmouseout = this.onTiddlerMouseOut;
	tiddlerElem.ondblclick = this.onTiddlerDblClick;
	tiddlerElem[window.event ? "onkeydown" : "onkeypress"] = this.onTiddlerKeyPress;
	tiddlerElem.innerHTML = this.getTemplateForTiddler(title, template, tiddler);
	applyHtmlMacros(tiddlerElem, tiddler);
	if(store.getTaggedTiddlers(title).length > 0)
		jQuery(tiddlerElem).addClass("isTag");
	else
		jQuery(tiddlerElem).removeClass("isTag");
	if(store.tiddlerExists(title)) {
		jQuery(tiddlerElem).removeClass("shadow");
		jQuery(tiddlerElem).removeClass("missing");
	} else {
		jQuery(tiddlerElem).addClass(store.isShadowTiddler(title) ? "shadow" : "missing");
	}
	if(customFields)
		this.addCustomFields(tiddlerElem, customFields);

	return tiddlerElem;
};

Story.prototype.addCustomFields = function(place, customFields)
{
	var fields = customFields.decodeHashMap();
	var container = createTiddlyElement(place, "div", null, "customFields");
	container.style.display = "none";
	for(var fieldName in fields) {
		var input = document.createElement("input");
		input.setAttribute("type", "text");
		input.setAttribute("value", fields[fieldName]);
		container.appendChild(input);
		input.setAttribute("edit", fieldName);
	}
};

Story.prototype.refreshAllTiddlers = function(force)
{
	this.forEachTiddler(function(title, element) {
		var template = element.getAttribute("template");
		if(template && element.getAttribute("dirty") != "true") {
			this.refreshTiddler(title, force ? null : template, true);
		}
	});
};

Story.prototype.onTiddlerMouseOver = function()
{
	jQuery(this).addClass("selected");
};

Story.prototype.onTiddlerMouseOut = function()
{
	jQuery(this).removeClass("selected");
};

Story.prototype.onTiddlerDblClick = function(ev)
{
	var e = ev || window.event;
	var target = resolveTarget(e);
	if(!target || target.nodeName.toLowerCase() == "input" || target.nodeName.toLowerCase() == "textarea")
		return false;
	if(document.selection && document.selection.empty)
		document.selection.empty();
	config.macros.toolbar.invokeCommand(this, "defaultCommand", e);
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return true;
};

Story.prototype.onTiddlerKeyPress = function(ev)
{
	var e = ev || window.event;
	clearMessage();
	var consume = false;
	var title = this.getAttribute("tiddler");
	var target = resolveTarget(e);
	switch(e.keyCode) {
		case 9: // Tab
			var editor = story.getTiddlerField(title, "text");
			if(target.tagName.toLowerCase() == "input"
			   && editor.value == config.views.editor.defaultText.format([title])) {
				// moving from input field and editor still contains default text, so select it
				editor.focus();
				editor.select();
				consume = true;
			}
			if(config.options.chkInsertTabs && !e.ctrlKey && target.tagName.toLowerCase() == "textarea") {
				replaceSelection(target, String.fromCharCode(9));
				consume = true;
			}
			if(config.isOpera) {
				target.onblur = function() {
					this.focus();
					this.onblur = null;
				};
			}
			break;
		case 13: // Ctrl-Enter
		case 10: // Ctrl-Enter on IE PC
		case 77: // Ctrl-Enter is "M" on some platforms
			if(e.ctrlKey) {
				blurElement(this);
				config.macros.toolbar.invokeCommand(this, "defaultCommand", e);
				consume = true;
			}
			break;
		case 27: // Escape
			blurElement(this);
			config.macros.toolbar.invokeCommand(this, "cancelCommand", e);
			consume = true;
			break;
	}
	e.cancelBubble = consume;
	if(consume) {
		if(e.stopPropagation) e.stopPropagation(); // Stop Propagation
		e.returnValue = true; // Cancel The Event in IE
		if(e.preventDefault) e.preventDefault(); // Cancel The Event in Moz
	}
	return !consume;
};

Story.prototype.getTiddlerField = function(title, field)
{
	var tiddlerElem = this.getTiddler(title);
	if(!tiddlerElem) return null;

	var $editors = jQuery(tiddlerElem).find('input, textarea');
	return $editors.filter('[edit="' + field + '"]')[0] || $editors[0] || null;
};

Story.prototype.focusTiddler = function(title, field)
{
	var e = this.getTiddlerField(title, field);
	if(e) {
		e.focus();
		e.select();
	}
};

Story.prototype.blurTiddler = function(title)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem && tiddlerElem.focus && tiddlerElem.blur) {
		tiddlerElem.focus();
		tiddlerElem.blur();
	}
};

Story.prototype.setTiddlerField = function(title, tag, mode, field)
{
	var editor = this.getTiddlerField(title, field);
	var tags = editor.value.readBracketedList();

	var i = tags.indexOf(tag);
	if(mode == 0) mode = (i == -1) ? +1 : -1;
	if(mode == +1) {
		if(i == -1) tags.push(tag);
	} else if(mode == -1) {
		if(i != -1) tags.splice(i, 1);
	}

	editor.value = String.encodeTiddlyLinkList(tags);
};

Story.prototype.setTiddlerTag = function(title, tag, mode)
{
	this.setTiddlerField(title, tag, mode, "tags");
};

Story.prototype.closeTiddler = function(title, shouldAnimate, unused)
{
	var tiddlerElem = this.getTiddler(title);
	if(!tiddlerElem) return;

	clearMessage();
	this.scrubTiddler(tiddlerElem);
	if(config.options.chkAnimate && shouldAnimate && anim && typeof Slider == "function") {
		anim.startAnimating(new Slider(tiddlerElem, false, null, "all"));
	} else {
		jQuery(tiddlerElem).remove();
	}
};

Story.prototype.scrubTiddler = function(tiddlerElement)
{
	tiddlerElement.id = null;
};

// 'dirty' flag attribute is used on tiddlers to mark those having unsaved changes

Story.prototype.setDirty = function(title, dirty)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem)
		tiddlerElem.setAttribute("dirty", dirty ? "true" : "false");
};

Story.prototype.isDirty = function(title)
{
	var tiddlerElem = this.getTiddler(title);
	if(!tiddlerElem) return null;
	return tiddlerElem.getAttribute("dirty") == "true";
};

Story.prototype.areAnyDirty = function()
{
	var r = false;
	this.forEachTiddler(function(title, element) {
		if(this.isDirty(title))
			r = true;
	});
	return r;
};

Story.prototype.closeAllTiddlers = function(exclude)
{
	clearMessage();
	this.forEachTiddler(function(title, element) {
		if((title != exclude) && element.getAttribute("dirty") != "true")
			this.closeTiddler(title);
	});
	window.scrollTo(0, ensureVisible(this.container));
};

Story.prototype.isEmpty = function()
{
	var place = this.getContainer();
	return place && place.firstChild == null;
};

Story.prototype.search = function(text, useCaseSensitive, useRegExp)
{
	this.closeAllTiddlers();
	highlightHack = new RegExp(useRegExp ? text : text.escapeRegExp(), useCaseSensitive ? "mg" : "img");
	var matches = store.search(highlightHack, "title", "excludeSearch");
	this.displayTiddlers(null, matches);
	highlightHack = null;
	var q = useRegExp ? "/" : "'";
	if(matches.length > 0)
		displayMessage(config.macros.search.successMsg.format([matches.length.toString(), q + text + q]));
	else
		displayMessage(config.macros.search.failureMsg.format([q + text + q]));
};

Story.prototype.findContainingTiddler = function(el)
{
	while(el && !jQuery(el).hasClass("tiddler")) {
		el = jQuery(el).hasClass("popup") && Popup.stack[0] ? Popup.stack[0].root
			: el.parentNode;
	}
	return el;
};

Story.prototype.gatherSaveFields = function(el, fields)
{
	if(!el || !el.getAttribute) return;
	var fieldName = el.getAttribute("edit");
	if(fieldName)
		fields[fieldName] = el.value.replace(/\r/mg, "");
	if(el.hasChildNodes()) {
		for(var i = 0; i < el.childNodes.length; i++)
			this.gatherSaveFields(el.childNodes[i], fields);
	}
};

Story.prototype.hasChanges = function(title)
{
	var tiddlerElement = this.getTiddler(title);
	if(!tiddlerElement) return false;

	var fields = {};
	this.gatherSaveFields(tiddlerElement, fields);
	if(store.fetchTiddler(title)) {
		for(var fieldName in fields) {
			if(store.getValue(title, fieldName) != fields[fieldName])
				return true;
		}
		return false;
	}
	if(store.isShadowTiddler(title)) {
		// not checking for title or tags
		return store.getShadowTiddlerText(title) != fields.text;
	}
	// new tiddler
	return true;
};

Story.prototype.saveTiddler = function(title, minorUpdate)
{
	var tiddlerElem = this.getTiddler(title);
	if(!tiddlerElem) return null;

	var fields = {};
	this.gatherSaveFields(tiddlerElem, fields);
	var newTitle = fields.title || title;
	if(!store.tiddlerExists(newTitle)) {
		newTitle = newTitle.trim();
		var creator = config.options.txtUserName;
	}
	if(store.tiddlerExists(newTitle) && newTitle != title) {
		if(!confirm(config.messages.overwriteWarning.format([newTitle.toString()])))
			return null;
	}
	if(newTitle != title)
		this.closeTiddler(newTitle, false);
	tiddlerElem.id = this.tiddlerId(newTitle);
	tiddlerElem.setAttribute("tiddler", newTitle);
	tiddlerElem.setAttribute("template", DEFAULT_VIEW_TEMPLATE);
	tiddlerElem.setAttribute("dirty", "false");
	if(config.options.chkForceMinorUpdate)
		minorUpdate = !minorUpdate;
	if(!store.tiddlerExists(newTitle))
		minorUpdate = false;
	if(store.tiddlerExists(title)) {
		var t = store.fetchTiddler(title);
		var extendedFields = t.fields;
		creator = t.creator;
	} else {
		extendedFields = merge({}, config.defaultCustomFields);
	}
	for(var n in fields) {
		if(!TiddlyWiki.isStandardField(n))
			extendedFields[n] = fields[n];
	}
	var tiddler = store.saveTiddler(title, newTitle, fields.text, minorUpdate ? undefined : config.options.txtUserName,
		minorUpdate ? undefined : new Date(), fields.tags, extendedFields, null, null, creator);
	autoSaveChanges(null, [tiddler]);
	return newTitle;
};

Story.prototype.getPermaViewHash = function(titles)
{
	return '#' + encodeURIComponent(String.encodeTiddlyLinkList(titles));
};

Story.prototype.permaView = function()
{
	var titles = [];
	this.forEachTiddler(function(title, element) {
		titles.push(title);
	});
	var hash = this.getPermaViewHash(titles);
	if(window.location.hash != hash)
		window.location.hash = hash;
};

Story.prototype.switchTheme = function(theme)
{
	if(safeMode) return;

	var getSlice = function(theme, slice) {
		var r;
		if(readOnly)
			r = store.getTiddlerSlice(theme, slice + "ReadOnly") || store.getTiddlerSlice(theme, "Web" + slice);
		r = r || store.getTiddlerSlice(theme, slice);
		if(r && r.indexOf(config.textPrimitives.sectionSeparator) == 0)
			r = theme + r;
		return store.isAvailable(r) ? r : slice;
	};

	var replaceNotification = function(i, name, theme, slice) {
		var newName = getSlice(theme, slice);
		if(name != newName && store.namedNotifications[i].name == name) {
			store.namedNotifications[i].name = newName;
			return newName;
		}
		return name;
	};

	var pt = config.refresherData.pageTemplate;
	var vi = DEFAULT_VIEW_TEMPLATE;
	var vt = config.tiddlerTemplates[vi];
	var ei = DEFAULT_EDIT_TEMPLATE;
	var et = config.tiddlerTemplates[ei];

	for(var i = 0; i < config.notifyTiddlers.length; i++) {
		var name = config.notifyTiddlers[i].name;
		switch(name) {
			case "PageTemplate":
				config.refresherData.pageTemplate = replaceNotification(i, config.refresherData.pageTemplate, theme, name);
				break;
			case "StyleSheet":
				removeStyleSheet(config.refresherData.styleSheet);
				config.refresherData.styleSheet = replaceNotification(i, config.refresherData.styleSheet, theme, name);
				break;
			case "ColorPalette":
				config.refresherData.colorPalette = replaceNotification(i, config.refresherData.colorPalette, theme, name);
				break;
			default:
				break;
		}
	}
	config.tiddlerTemplates[vi] = getSlice(theme, "ViewTemplate");
	config.tiddlerTemplates[ei] = getSlice(theme, "EditTemplate");
	if(!startingUp) {
		if(config.refresherData.pageTemplate != pt || config.tiddlerTemplates[vi] != vt
		   || config.tiddlerTemplates[ei] != et) {
			refreshAll();
			this.refreshAllTiddlers(true);
		} else {
			setStylesheet(store.getRecursiveTiddlerText(config.refresherData.styleSheet, "", 10),
				config.refreshers.styleSheet);
		}
		config.options.txtTheme = theme;
		saveOption("txtTheme");
	}
};

//--
//-- Backstage
//--
// Backstage tasks
config.tasks.save.action = saveChanges;

var backstage = {
	area: null,
	toolbar: null,
	button: null,
	showButton: null,
	hideButton: null,
	cloak: null,
	panel: null,
	panelBody: null,
	panelFooter: null,
	currTabName: null,
	currTabElem: null,
	content: null,

	init: function() {
		var cmb = config.messages.backstage;
		this.area = document.getElementById("backstageArea");
		this.toolbar = jQuery("#backstageToolbar").empty()[0];
		this.button = jQuery("#backstageButton").empty()[0];
		this.button.style.display = "block";
		var text = cmb.open.text + " " + glyph("bentArrowLeft");
		this.showButton = createTiddlyButton(this.button, text, cmb.open.tooltip,
			function(e) { backstage.show(); return false }, null, "backstageShow");
		text = glyph("bentArrowRight") + " " + cmb.close.text;
		this.hideButton = createTiddlyButton(this.button, text, cmb.close.tooltip,
			function(e) { backstage.hide(); return false }, null, "backstageHide");
		this.cloak = document.getElementById("backstageCloak");
		this.panel = document.getElementById("backstagePanel");
		this.panelFooter = createTiddlyElement(this.panel, "div", null, "backstagePanelFooter");
		this.panelBody = createTiddlyElement(this.panel, "div", null, "backstagePanelBody");
		this.cloak.onmousedown = function(e) { backstage.switchTab(null) };
		createTiddlyText(this.toolbar, cmb.prompt);
		for(var i = 0; i < config.backstageTasks.length; i++)
		{
			var taskName = config.backstageTasks[i];
			var task = config.tasks[taskName];
			var handler = task.action ? this.onClickCommand : this.onClickTab;
			var text = task.text + (task.action ? "" : glyph("downTriangle"));
			var btn = createTiddlyButton(this.toolbar, text, task.tooltip, handler, "backstageTab");
			jQuery(btn).addClass(task.action ? "backstageAction" : "backstageTask");
			btn.setAttribute("task", taskName);
		}
		this.content = document.getElementById("contentWrapper");
		if(config.options.chkBackstage)
			this.show();
		else
			this.hide();
	},

	isVisible: function() {
		return this.area ? this.area.style.display == "block" : false;
	},

	show: function() {
		this.area.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.toolbar.style.left = findWindowWidth() + "px";
			anim.startAnimating(new Morpher(backstage.toolbar, config.animDuration, [
				{ style: "left", start: findWindowWidth(), end: 0, template: "%0px" }
			]));
		} else {
			backstage.area.style.left = "0px";
		}
		jQuery(this.showButton).hide();
		jQuery(this.hideButton).show();
		config.options.chkBackstage = true;
		saveOption("chkBackstage");
		jQuery(this.content).addClass("backstageVisible");
	},

	hide: function() {
		if(this.currTabElem) {
			// close current tab, not backstage
			this.switchTab(null);
			return;
		}

		backstage.toolbar.style.left = "0px";
		var hide = function() { backstage.area.style.display = "none" };
		if(anim && config.options.chkAnimate) {
			anim.startAnimating(new Morpher(backstage.toolbar, config.animDuration, [
				{ style: "left", start: 0, end: findWindowWidth(), template: "%0px" }
			], hide));
		} else {
			hide();
		}
		this.showButton.style.display = "block";
		this.hideButton.style.display = "none";
		config.options.chkBackstage = false;
		saveOption("chkBackstage");
		jQuery(this.content).removeClass("backstageVisible");
	},

	onClickCommand: function(e) {
		var task = config.tasks[this.getAttribute("task")];
		if(task.action) {
			backstage.switchTab(null);
			task.action();
		}
		return false;
	},

	onClickTab: function(e) {
		backstage.switchTab(this.getAttribute("task"));
		return false;
	},

	// Switch to a given tab, or none if null is passed
	switchTab: function(tabName) {
		var tabElem = null;
		var e = this.toolbar.firstChild;
		while(e) {
			if(e.getAttribute && e.getAttribute("task") == tabName)
				tabElem = e;
			e = e.nextSibling;
		}
		if(tabName == this.currTabName) {
			this.hidePanel();
			return;
		}
		if(this.currTabElem) {
			jQuery(this.currTabElem).removeClass("backstageSelTab");
		}
		if(tabElem && tabName) {
			this.preparePanel();
			jQuery(tabElem).addClass("backstageSelTab");
			var task = config.tasks[tabName];
			wikify(task.content, this.panelBody, null, null);
			this.showPanel();
		} else if(this.currTabElem) {
			this.hidePanel();
		}
		this.currTabName = tabName;
		this.currTabElem = tabElem;
	},

	isPanelVisible: function() {
		return backstage.panel ? backstage.panel.style.display == "block" : false;
	},

	preparePanel: function() {
		backstage.cloak.style.height = findDocHeight() + "px";
		backstage.cloak.style.display = "block";
		jQuery(backstage.panelBody).empty();
		return backstage.panelBody;
	},

	showPanel: function() {
		backstage.panel.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.panel.style.top = (-backstage.panel.offsetHeight) + "px";
			anim.startAnimating(new Morpher(backstage.panel, config.animDuration, [
				{ style: "top", start: -backstage.panel.offsetHeight, end: 0, template: "%0px" }
			]), new Scroller(backstage.panel, false));
		} else {
			backstage.panel.style.top = "0px";
		}
		return backstage.panelBody;
	},

	hidePanel: function() {
		if(backstage.currTabElem)
			jQuery(backstage.currTabElem).removeClass("backstageSelTab");
		backstage.currTabElem = null;
		backstage.currTabName = null;
		if(anim && config.options.chkAnimate) {
			var callback = function() { backstage.cloak.style.display = "none" };
			anim.startAnimating(new Morpher(backstage.panel, config.animDuration, [
				{ style: "top", start: 0, end: -(backstage.panel.offsetHeight), template: "%0px" },
				{ style: "display", atEnd: "none" }
			], callback));
		} else {
			jQuery([backstage.panel, backstage.cloak]).hide();
		}
	}
};

config.macros.backstage = {};

config.macros.backstage.handler = function(place, macroName, params)
{
	var backstageTask = config.tasks[params[0]];
	if(!backstageTask) return;
	createTiddlyButton(place, backstageTask.text, backstageTask.tooltip, function(e) {
		backstage.switchTab(params[0]);
		return false;
	});
};

//--
//-- ImportTiddlers macro
//--

config.macros.importTiddlers.handler = function(place, macroName, params, wikifier, paramString, tiddler)
{
	if(readOnly) {
		createTiddlyElement(place, "div", null, "marked", this.readOnlyWarning);
		return;
	}
	var w = new Wizard();
	w.createWizard(place, this.wizardTitle);
	this.restart(w);
};

config.macros.importTiddlers.onCancel = function(e)
{
	var wizard = new Wizard(this);
	wizard.clear();
	config.macros.importTiddlers.restart(wizard);
	return false;
};

config.macros.importTiddlers.onClose = function(e)
{
	backstage.hidePanel();
	return false;
};

config.macros.importTiddlers.restart = function(wizard)
{
	var me = config.macros.importTiddlers;
	wizard.addStep(this.step1Title, this.step1Html);
	var name, s = wizard.getElement("selTypes");
	for(name in config.adaptors) {
		var e = createTiddlyElement(s, "option", null, null, config.adaptors[name].serverLabel || name);
		e.value = name;
	}
	if(config.defaultAdaptor) s.value = config.defaultAdaptor;
	s = wizard.getElement("selFeeds");
	var feeds = this.getFeeds();
	for(name in feeds) {
		e = createTiddlyElement(s, "option", null, null, name);
		e.value = name;
	}
	wizard.setValue("feeds", feeds);
	s.onchange = me.onFeedChange;
	var fileInput = wizard.getElement("txtBrowse");
	fileInput.onchange = me.onBrowseChange;
	fileInput.onkeyup = me.onBrowseChange;
	wizard.setButtons([{ caption: this.openLabel, tooltip: this.openPrompt, onClick: me.onOpen }]);
	wizard.formElem.action = "javascript:;";
	wizard.formElem.onsubmit = function() {
		if(!this.txtPath || this.txtPath.value.length) //# check for manually entered path in first step
			this.lastChild.firstChild.onclick();
	};
};

config.macros.importTiddlers.getFeeds = function()
{
	var feeds = {};
	var i, tagged = store.getTaggedTiddlers("systemServer", "title");
	for(i = 0; i < tagged.length; i++) {
		var title = tagged[i].title;
		feeds[title] = {
			title: title,
			url: store.getTiddlerSlice(title, "URL"),
			workspace: store.getTiddlerSlice(title, "Workspace"),
			workspaceList: store.getTiddlerSlice(title, "WorkspaceList"),
			tiddlerFilter: store.getTiddlerSlice(title, "TiddlerFilter"),
			serverType: store.getTiddlerSlice(title, "Type") || "file",
			description: store.getTiddlerSlice(title, "Description")
		};
	}
	return feeds;
};

config.macros.importTiddlers.onFeedChange = function(e)
{
	var wizard = new Wizard(this);
	var selTypes = wizard.getElement("selTypes");
	var fileInput = wizard.getElement("txtPath");
	var feeds = wizard.getValue("feeds");
	var f = feeds[this.value];
	if(f) {
		selTypes.value = f.serverType;
		fileInput.value = f.url;
		wizard.setValue("feedName", f.serverType);
		wizard.setValue("feedHost", f.url);
		wizard.setValue("feedWorkspace", f.workspace);
		wizard.setValue("feedWorkspaceList", f.workspaceList);
		wizard.setValue("feedTiddlerFilter", f.tiddlerFilter);
	}
	return false;
};

config.macros.importTiddlers.onBrowseChange = function(e)
{
	var wizard = new Wizard(this);
	var file = this.value;
	file = file.replace(/^C:\\fakepath\\/i, ''); // remove fakepath (chrome/opera/safari)
	if(this.files && this.files[0]) {
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalFileRead");
			file = this.files[0].fileName; // REQUIRES PRIVILEGES.. NULL otherwise
		} catch (ex) {
			// non-priv fallback: combine filename with path to current document
			var path = tw.io.getOriginalLocalPath();
			var slashpos = path.lastIndexOf('/');
			if (slashpos == -1) slashpos = path.lastIndexOf('\\');
			if (slashpos != -1) path = path.substr(0, slashpos + 1); // remove filename, leave trailing slash
			file = path + file;
		}
	}
	var fileInput = wizard.getElement("txtPath");
	fileInput.value = config.macros.importTiddlers.getURLFromLocalPath(file);
	var serverType = wizard.getElement("selTypes");
	serverType.value = "file";
	return true;
};

config.macros.importTiddlers.getURLFromLocalPath = function(path)
{
	if(!path) return path;
	// use "/" for cross-platform consistency
	path = path.replace(/\\/g, "/");

	var t = path.split(":");
	if(t[1] && (t[0] == "http" || t[0] == "https" || t[0] == "file")) {
		// input is already a URL
		return path;
	}

	var p = t[1] || t[0]; // remove drive letter (if any)
	if(p.substr(0, 1) == "/") {
		// path is absolute, add protocol + domain + extra slash (if drive letter)
		return document.location.protocol + "//" + document.location.hostname + (t[1] ? "/" : "") + path;
	}

	// path is relative, add current document protocol + domain + path
	var c = document.location.href.replace(/\\/g, "/");
	var pos = c.lastIndexOf("/");
	if(pos != -1)
		c = c.substring(0, pos); // remove filename
	return c + "/" + p;
};

config.macros.importTiddlers.onOpen = function(e)
{
	var me = config.macros.importTiddlers;
	var wizard = new Wizard(this);
	var fileInput = wizard.getElement("txtPath");
	var url = fileInput.value;
	var serverType = wizard.getElement("selTypes").value || config.defaultAdaptor;
	var adaptor = new config.adaptors[serverType]();
	wizard.setValue("adaptor", adaptor);
	wizard.setValue("serverType", serverType);
	wizard.setValue("host", url);
	adaptor.openHost(url, null, wizard, me.onOpenHost);
	wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], me.statusOpenHost);
	return false;
};

config.macros.importTiddlers.onOpenHost = function(context, wizard)
{
	var me = config.macros.importTiddlers;
	var adaptor = wizard.getValue("adaptor");
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenHost: " + context.statusText);
	adaptor.getWorkspaceList(context, wizard, me.onGetWorkspaceList);
	wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], me.statusGetWorkspaceList);
};

config.macros.importTiddlers.onGetWorkspaceList = function(context, wizard)
{
	var me = config.macros.importTiddlers;
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onGetWorkspaceList: " + context.statusText);
	wizard.setValue("context", context);
	var workspace = wizard.getValue("feedWorkspace");
	if(!workspace && context.workspaces.length == 1)
		workspace = context.workspaces[0].title;
	if(workspace) {
		context.adaptor.openWorkspace(workspace, context, wizard, me.onOpenWorkspace);
		wizard.setValue("workspace", workspace);
		wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], me.statusOpenWorkspace);
		return;
	}
	wizard.addStep(me.step2Title, me.step2Html);
	var i, s = wizard.getElement("selWorkspace");
	s.onchange = me.onWorkspaceChange;
	for(i = 0; i < context.workspaces.length; i++) {
		var e = createTiddlyElement(s, "option", null, null, context.workspaces[i].title);
		e.value = context.workspaces[i].title;
	}
	var workspaceList = wizard.getValue("feedWorkspaceList");
	if(workspaceList) {
		var list = workspaceList.parseParams("workspace", null, false, true);
		for(i = 1; i < list.length; i++) {
			if(context.workspaces.findByField("title", list[i].value) == null) {
				e = createTiddlyElement(s, "option", null, null, list[i].value);
				e.value = list[i].value;
			}
		}
	}
	if(workspace) {
		wizard.getElement("txtWorkspace").value = workspace;
	}
	wizard.setButtons([{ caption: me.openLabel, tooltip: me.openPrompt, onClick: me.onChooseWorkspace }]);
};

config.macros.importTiddlers.onWorkspaceChange = function(e)
{
	var wizard = new Wizard(this);
	wizard.getElement("txtWorkspace").value = this.value;
	this.selectedIndex = 0;
	return false;
};

config.macros.importTiddlers.onChooseWorkspace = function(e)
{
	var me = config.macros.importTiddlers;
	var wizard = new Wizard(this);
	var adaptor = wizard.getValue("adaptor");
	var workspace = wizard.getElement("txtWorkspace").value;
	wizard.setValue("workspace", workspace);
	var context = wizard.getValue("context");
	adaptor.openWorkspace(workspace, context, wizard, me.onOpenWorkspace);
	wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], me.statusOpenWorkspace);
	return false;
};

config.macros.importTiddlers.onOpenWorkspace = function(context, wizard)
{
	var me = config.macros.importTiddlers;
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenWorkspace: " + context.statusText);
	var adaptor = wizard.getValue("adaptor");
	var browse = wizard.getElement("txtBrowse");
	if (browse.files) context.file = browse.files[0]; // for HTML5 FileReader
	adaptor.getTiddlerList(context, wizard, me.onGetTiddlerList, wizard.getValue("feedTiddlerFilter"));
	wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], me.statusGetTiddlerList);
};

config.macros.importTiddlers.onGetTiddlerList = function(context, wizard)
{
	var me = config.macros.importTiddlers;
	if(context.status !== true) {
		var error = context.statusText || me.errorGettingTiddlerList;
		if(context.host.indexOf("file://") === 0) {
			error = me.errorGettingTiddlerListFile;
		} else {
			error = context.xhr && context.xhr.status == 404 ? me.errorGettingTiddlerListHttp404 :
				me.errorGettingTiddlerListHttp;
		}
		wizard.setButtons([{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }], "");
		jQuery("span.status", wizard.footerEl).html(error); // so error message can be html
		return;
	}

	// Extract data for the listview
	var listedTiddlers = [];
	if(context.tiddlers) {
		for(var i = 0; i < context.tiddlers.length; i++) {
			var tiddler = context.tiddlers[i];
			listedTiddlers.push({
				title: tiddler.title,
				modified: tiddler.modified,
				modifier: tiddler.modifier,
				text: tiddler.text ? wikifyPlainText(tiddler.text, 100) : "",
				tags: tiddler.tags,
				size: tiddler.text ? tiddler.text.length : 0,
				tiddler: tiddler
			});
		}
	}
	listedTiddlers.sort(function(a, b) { return a.title < b.title ? -1 : (a.title == b.title ? 0 : +1) });

	// Display the listview
	wizard.addStep(me.step3Title, me.step3Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper, markList);
	var listView = ListView.create(listWrapper, listedTiddlers, me.listViewTemplate);
	wizard.setValue("listView", listView);
	wizard.setValue("context", context);
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler");
	txtSaveTiddler.value = me.generateSystemServerName(wizard);
	wizard.setButtons([
		{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel },
		{ caption: me.importLabel, tooltip: me.importPrompt, onClick: me.doImport }
	]);
};

config.macros.importTiddlers.generateSystemServerName = function(wizard)
{
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var pattern = config.macros.importTiddlers[workspace ? "systemServerNamePattern" : "systemServerNamePatternNoWorkspace"];
	return pattern.format([serverType, host, workspace]);
};

config.macros.importTiddlers.saveServerTiddler = function(wizard)
{
	var me = config.macros.importTiddlers;
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler").value;
	if(store.tiddlerExists(txtSaveTiddler)) {
		if(!confirm(me.confirmOverwriteSaveTiddler.format([txtSaveTiddler])))
			return;
		store.suspendNotifications();
		store.removeTiddler(txtSaveTiddler);
		store.resumeNotifications();
	}
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var text = me.serverSaveTemplate.format([serverType, host, workspace]);
	store.saveTiddler(txtSaveTiddler, txtSaveTiddler, text, me.serverSaveModifier, new Date(), ["systemServer"]);
};

config.macros.importTiddlers.doImport = function(e)
{
	var me = config.macros.importTiddlers;
	var wizard = new Wizard(this);
	if(wizard.getElement("chkSave").checked)
		me.saveServerTiddler(wizard);
	var chkSync = wizard.getElement("chkSync").checked;
	wizard.setValue("sync", chkSync);

	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	var adaptor = wizard.getValue("adaptor");
	var overwrite = [];
	for(var i = 0; i < rowNames.length; i++) {
		if(store.tiddlerExists(rowNames[i]))
			overwrite.push(rowNames[i]);
	}
	if(overwrite.length > 0) {
		if(!confirm(me.confirmOverwriteText.format([overwrite.join(", ")])))
			return false;
	}

	wizard.addStep(me.step4Title.format([rowNames.length]), me.step4Html);
	for(i = 0; i < rowNames.length; i++) {
		var linkHolder = document.createElement("div");
		createTiddlyLink(linkHolder, rowNames[i], true);
		var place = wizard.getElement("markReport");
		place.parentNode.insertBefore(linkHolder, place);
	}
	wizard.setValue("remainingImports", rowNames.length);
	wizard.setButtons([
		{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }
	], me.statusDoingImport);
	var wizardContext = wizard.getValue("context");
	var tiddlers = wizardContext ? wizardContext.tiddlers : [];
	for(i = 0; i < rowNames.length; i++) {
		var context = {
			allowSynchronous: true,
			tiddler: tiddlers[tiddlers.findByField("title", rowNames[i])]
		};
		adaptor.getTiddler(rowNames[i], context, wizard, me.onGetTiddler);
	}
	return false;
};

config.macros.importTiddlers.onGetTiddler = function(context, wizard)
{
	if(!context.status)
		displayMessage("Error in importTiddlers.onGetTiddler: " + context.statusText);
	var tiddler = context.tiddler;
	store.suspendNotifications();
	store.saveTiddler(tiddler.title, tiddler.title, tiddler.text, tiddler.modifier,
		tiddler.modified, tiddler.tags, tiddler.fields, true, tiddler.created);
	if(!wizard.getValue("sync")) {
		store.setValue(tiddler.title, 'server', null);
	}
	store.resumeNotifications();
	if(!context.isSynchronous) store.notify(tiddler.title, true);

	var remainingImports = wizard.getValue("remainingImports") - 1;
	wizard.setValue("remainingImports", remainingImports);

	if(remainingImports != 0) return;
	if(context.isSynchronous) {
		store.notifyAll();
		refreshDisplay();
	}
	var me = config.macros.importTiddlers;
	wizard.setButtons([
		{ caption: me.doneLabel, tooltip: me.donePrompt, onClick: me.onClose }
	], me.statusDoneImport);
	autoSaveChanges();
};

//--
//-- Upgrade macro
//--

config.macros.upgrade.docsUrl = 'https://classic.tiddlywiki.com/#HowToUpgrade';

config.macros.upgrade.getSourceURL = function()
{
	return config.options.txtUpgradeCoreURI || config.macros.upgrade.source;
};

config.macros.upgrade.loadLatestCore = function(onSuccess, onError)
{
	ajaxReq({
		type: "GET",
		url: this.getSourceURL(),
		processData: false,
		success: onSuccess,
		error: onError
	});
};

config.macros.upgrade.handler = function(place)
{
	var w = new Wizard();
	w.createWizard(place, this.wizardTitle);
	w.addStep(this.step1Title, this.step1Html.format([
		this.getSourceURL(),
		this.getSourceURL().replace(/^https:\/\//, ''),
		this.docsUrl
	]));
	w.setButtons([{
		caption: this.upgradeLabel,
		tooltip: this.upgradePrompt,
		onClick: this.onClickUpgrade
	}]);
};

config.macros.upgrade.onClickUpgrade = function(e)
{
	var me = config.macros.upgrade;
	var w = new Wizard(this);
	if(!window.allowSave()) {
		alert(me.errorCantUpgrade);
		return false;
	}
	if(story.areAnyDirty() || store.isDirty()) {
		alert(me.errorNotSaved);
		return false;
	}

	w.setButtons([], me.statusPreparingBackup);
	var localPath = tw.io.getOriginalLocalPath();
	var backupPath = getBackupPath(localPath, me.backupExtension);
	var original = loadOriginal(localPath);

	w.setButtons([], me.statusSavingBackup);
	var backupSuccessOrPending = copyFile(backupPath, localPath) || saveFile(backupPath, original);
	if(!backupSuccessOrPending) {
		w.setButtons([], me.errorSavingBackup);
		alert(me.errorSavingBackup);
		return false;
	}

	// make sure both the backup is saved and tw.io.loadFile works before proceeding
	tw.io.loadFile(backupPath, function(backupContent) {
		if(!backupContent) {
			w.setButtons([], me.errorVerifyingBackup.format([me.docsUrl]));
			return;
		}

		w.setValue("backupPath", backupPath);

		w.setButtons([], me.statusLoadingCore);
		var sourceURL = me.getSourceURL();
		me.loadLatestCore(function(data, textStatus, jqXHR) {
			me.onLoadCore(true, w, jqXHR.responseText, sourceURL, jqXHR);
		}, function(jqXHR, textStatus, errorThrown) {
			me.onLoadCore(false, w, null, sourceURL, jqXHR);
		});
	});

	return false;
};

config.macros.upgrade.onLoadCore = function(status, w, responseText, url, xhr)
{
	var me = config.macros.upgrade;
	var errMsg;
	if(!status) errMsg = me.errorLoadingCore;
	var newVer = me.extractVersion(responseText);
	if(!newVer) errMsg = me.errorCoreFormat;
	if(errMsg) {
		w.setButtons([], errMsg);
		alert(errMsg);
		return;
	}

	var step2 = [me.step2Html_downgrade, me.step2Html_restore, me.step2Html_upgrade][compareVersions(version, newVer) + 1];
	w.addStep(me.step2Title, step2.format([formatVersion(newVer), formatVersion(version)]));
	w.setButtons([
		{ caption: me.startLabel,  tooltip: me.startPrompt,  onClick: function() {
			config.macros.upgrade.onStartUpgrade(w, responseText);
		} },
		{ caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel }
	]);
};

config.macros.upgrade.onStartUpgrade = function(wizard, newCoreHtml)
{
	wizard.setButtons([], config.macros.upgrade.statusSavingCore);
	var localPath = tw.io.getOriginalLocalPath();
	saveFile(localPath, newCoreHtml);

	wizard.setButtons([], config.macros.upgrade.statusReloadingCore);
	var backupPath = wizard.getValue("backupPath");
	var newLocation = addUpgradePartsToURI(document.location.toString(), backupPath);
	window.setTimeout(function () { window.location = newLocation }, 10);
};

config.macros.upgrade.onCancel = function(e)
{
	var me = config.macros.upgrade;
	var w = new Wizard(this);
	w.addStep(me.step3Title, me.step3Html);
	w.setButtons([]);
	return false;
};

config.macros.upgrade.extractVersion = function(upgradeFile)
{
	var re = /version = \{\s*title: "([^"]+)", major: (\d+), minor: (\d+), revision: (\d+)(, beta: (\d+)){0,1}, date: new Date\("([^"]+)"\)/mg;
	var m = re.exec(upgradeFile);
	return !m ? null : {
		title: m[1], major: m[2], minor: m[3], revision: m[4], beta: m[6], date: new Date(m[7])
	};
};

// a helper, splits uri into parts, passes the map of parts to modify and glues parts back
function changeUri(uri, modify)
{
	var uriPartsRE = /^(?:([\w:]+)\/\/)?([^\/\?#]+)?([^\?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;
	var match = uriPartsRE.exec(uri) || [null, '', '', '', '', ''];
	var parts = {
		scheme:	match[1],
		host:	match[2],
		path:	match[3],
		query:	match[4],
		hash:	match[5]
	};
	modify(parts);
	var newScheme = parts.scheme === undefined ? '' : (parts.scheme + '//'),
	    newHost   = parts.host || '',
	    newPath   = parts.path || '',
	    newQuery  = parts.query ? ('?' + parts.query) : '',
	    newHash   = parts.hash   === undefined ? '' : ('#' + parts.hash);
	return newScheme + newHost + newPath + newQuery + newHash;
}

function addUpgradePartsToURI(uri, backupPath)
{
	return changeUri(uri, function(uriParts)
	{
		var newParamifier = 'upgrade:[[' + encodeURI(backupPath) + ']]';
		uriParts.hash = (uriParts.hash ? uriParts.hash + '%20' : '') + newParamifier;

		var newQuery = "time=" + new Date().convertToYYYYMMDDHHMM();
		uriParts.query = (uriParts.query ? uriParts.query + '&' : '') + newQuery;
	});
}

function stripUpgradePartsFromURI(uri)
{
	return changeUri(uri, function(uriParts)
	{
		var queryParts = uriParts.query.split('&'),
		    hashParts = uriParts.hash.split('%20'); // splits paramifiers with a space in argument

		for(var i = 0; i < queryParts.length; i++)
			if(queryParts[i].indexOf('time=') == 0)
				queryParts.splice(i--, 1);

		// relies on the upgrade paramifier being added to the end of hash
		for(i = 0; i < hashParts.length; i++)
			if(hashParts[i].indexOf('upgrade:') == 0)
				hashParts = hashParts.slice(0, i);

		uriParts.query = queryParts.join('&');
		uriParts.hash = hashParts.join('%20') || undefined;
	});
}

function upgradeFrom(path)
{
	tw.io.loadFile(path, function(oldTw) {
		var importStore = new TiddlyWiki();
		importStore.importTiddlyWiki(oldTw);
		importStore.forEachTiddler(function(title, tiddler) {
			if(!store.getTiddler(title)) {
				store.addTiddler(tiddler);
			}
		});

		refreshDisplay();
		saveChanges();
		alert(config.messages.upgradeDone.format([formatVersion()]));
		window.location = stripUpgradePartsFromURI(window.location.toString());
	});
}

//--
//-- Manager UI for groups of tiddlers
//--

config.macros.plugins.handler = function(place, macroName, params, wikifier, paramString)
{
	var wizard = new Wizard();
	wizard.createWizard(place, this.wizardTitle);
	wizard.addStep(this.step1Title, this.step1Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper, markList);
	listWrapper.setAttribute("refresh", "macro");
	listWrapper.setAttribute("macroName", "plugins");
	listWrapper.setAttribute("params", paramString);
	this.refresh(listWrapper, paramString);
};

config.macros.plugins.refresh = function(listWrapper, paramString)
{
	var wizard = new Wizard(listWrapper);
	var selectedRows = [];
	ListView.forEachSelector(listWrapper, function(e, rowName) {
		if(e.checked) selectedRows.push(e.getAttribute("rowName"));
	});
	jQuery(listWrapper).empty();

	var plugins = installedPlugins.slice(0);
	// not all plugins are installed, gather info about those, too
	var i, tiddler, p;
	var configTiddlers = store.getTaggedTiddlers("systemConfig");
	for(i = 0; i < configTiddlers.length; i++) {
		tiddler = configTiddlers[i];
		if(plugins.findByField("title", tiddler.title) != null) continue;

		p = getPluginInfo(tiddler);
		p.executed = false;
		p.log.splice(0, 0, this.skippedText);
		plugins.push(p);
	}

	for(i = 0; i < plugins.length; i++) {
		p = plugins[i];
		p.size = p.tiddler.text ? p.tiddler.text.length : 0;
		p.forced = p.tiddler.isTagged("systemConfigForce");
		p.disabled = p.tiddler.isTagged("systemConfigDisable");
		p.Selected = selectedRows.indexOf(plugins[i].title) != -1;
	}

	if(plugins.length == 0) {
		createTiddlyElement(listWrapper, "em", null, null, this.noPluginText);
		wizard.setButtons([]);
	} else {
		var template = readOnly ? this.listViewTemplateReadOnly : this.listViewTemplate;
		var listView = ListView.create(listWrapper, plugins, template, this.onSelectCommand);
		wizard.setValue("listView", listView);
		if(!readOnly) {
			var me = config.macros.plugins;
			wizard.setButtons([
				{ caption: me.removeLabel, tooltip: me.removePrompt, onClick: me.doRemoveTag },
				{ caption: me.deleteLabel, tooltip: me.deletePrompt, onClick: me.doDelete }
			]);
		}
	}
};

config.macros.plugins.doRemoveTag = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		for(var i = 0; i < rowNames.length; i++) {
			store.setTiddlerTag(rowNames[i], false, "systemConfig");
		}
		autoSaveChanges();
	}
};

config.macros.plugins.doDelete = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		if(confirm(config.macros.plugins.confirmDeleteText.format([rowNames.join(", ")]))) {
			for(var i = 0; i < rowNames.length; i++) {
				store.removeTiddler(rowNames[i]);
				story.closeTiddler(rowNames[i], true);
			}
		}
		autoSaveChanges();
	}
};

//--
//-- Message area
//--

function getMessageDiv()
{
	var msgArea = document.getElementById("messageArea");
	if(!msgArea) return null;

	if(!msgArea.hasChildNodes()) {
		var toolbar = createTiddlyElement(msgArea, "div", null, "messageArea__toolbar messageToolbar");
		var btn = createTiddlyButton(toolbar, '', config.messages.messageClose.tooltip, clearMessage,
			"button messageToolbar__button");

		btn.innerHTML = tw.assets.icons.closeSvg;
		// inline SVG is unsupported in old FireFox
		if(window.HTMLUnknownElement && btn.firstChild instanceof window.HTMLUnknownElement) {
			btn.innerHTML = config.messages.messageClose.text;
		} else {
			btn.classList.add('messageToolbar__button_withIcon');
		}
	}
	msgArea.style.display = "block";
	return createTiddlyElement(msgArea, "div", null, "messageArea__text");
}

function displayMessage(text, link)
{
	var e = getMessageDiv();
	if(!e) {
		alert(text);
		return;
	}
	if(!link) {
		createTiddlyText(e, text);
	} else {
		createTiddlyElement(e, "a", null, null, text, { href: link, target: "_blank" });
	}
}

function clearMessage()
{
	var msgArea = document.getElementById("messageArea");
	if(msgArea) {
		jQuery(msgArea).empty();
		msgArea.style.display = "none";
	}
	return false;
}

//--
//-- Refresh mechanism
//--

config.notifyTiddlers = [
	{ name: "SystemSettings", notify: onSystemSettingsChange },
	{ name: "StyleSheetLayout", notify: refreshStyles },
	{ name: "StyleSheetColors", notify: refreshStyles },
	{ name: "StyleSheet", notify: refreshStyles },
	{ name: "StyleSheetPrint", notify: refreshStyles },
	{ name: "PageTemplate", notify: refreshPageTemplate },
	{ name: "SiteTitle", notify: refreshPageTitle },
	{ name: "SiteSubtitle", notify: refreshPageTitle },
	{ name: "WindowTitle", notify: refreshPageTitle },
	{ name: "ColorPalette", notify: refreshColorPalette },
	{ name: null, notify: refreshDisplay }
];

config.refreshers = {
	link: function(e, changeList)
	{
		var title = e.getAttribute("tiddlyLink");
		refreshTiddlyLink(e, title);
		return true;
	},

	tiddler: function(e, changeList)
	{
		if (startingUp) return true; // #147
		var title = e.getAttribute("tiddler");
		var template = e.getAttribute("template");
		if(changeList && (changeList.indexOf && changeList.indexOf(title) != -1) && !story.isDirty(title))
			story.refreshTiddler(title, template, true);
		else
			refreshElements(e, changeList);
		return true;
	},

	content: function(e, changeList)
	{
		var title = e.getAttribute("tiddler");
		var force = e.getAttribute("force");
		var args = e.macroArgs; // #154
		if(force != null || changeList == null || (changeList.indexOf && changeList.indexOf(title) != -1)) {
			jQuery(e).empty();
			config.macros.tiddler.transclude(e, title, args);
			return true;
		} else
			return false;
	},

	macro: function(e, changeList)
	{
		var macro = e.getAttribute("macroName");
		var params = e.getAttribute("params");
		if(macro)
			macro = config.macros[macro];
		if(macro && macro.refresh)
			macro.refresh(e, params);
		return true;
	}
};

config.refresherData = {
	styleSheet: "StyleSheet",
	defaultStyleSheet: "StyleSheet",
	pageTemplate: "PageTemplate",
	defaultPageTemplate: "PageTemplate",
	colorPalette: "ColorPalette",
	defaultColorPalette: "ColorPalette"
};

function refreshElements(root, changeList)
{
	var i, nodes = root.childNodes;
	for(i = 0; i < nodes.length; i++) {
		var e = nodes[i], type = null;
		if(e.getAttribute && (e.tagName ? e.tagName != "IFRAME" : true))
			type = e.getAttribute("refresh");
		var refresher = config.refreshers[type];
		var refreshed = refresher ? refresher(e, changeList) : false;
		if(e.hasChildNodes() && !refreshed)
			refreshElements(e, changeList);
	}
}

function applyHtmlMacros(root, tiddler)
{
	for(var e = root.firstChild; !!e; e = nextChild) {
		// macros can manipulate DOM, so we remember nextChild before invokeMacro
		var nextChild = e.nextSibling;
		if(e.getAttribute) {
			var macro = e.getAttribute("macro");
			if(macro) {
				e.removeAttribute("macro");
				var params = "";
				var p = macro.indexOf(" ");
				if(p != -1) {
					params = macro.substr(p + 1);
					macro = macro.substr(0, p);
				}
				invokeMacro(e, macro, params, null, tiddler);
			}
		}
		if(e.hasChildNodes()) applyHtmlMacros(e, tiddler);
	}
}

function refreshPageTemplate(title)
{
	var stash = jQuery("<div/>").appendTo("body").hide()[0];
	var display = story.getContainer();
	var nodes, i;
	if(display) {
		nodes = display.childNodes;
		for(i = nodes.length - 1; i >= 0; i--)
			stash.appendChild(nodes[i]);
	}
	var wrapper = document.getElementById("contentWrapper");

	if(!title || !store.isAvailable(title))
		title = config.refresherData.pageTemplate;
	if(!store.isAvailable(title))
		title = config.refresherData.defaultPageTemplate; //# this one is always avaialable

	wrapper.innerHTML = store.getRecursiveTiddlerText(title, null, 10);
	applyHtmlMacros(wrapper);
	refreshElements(wrapper);
	display = story.getContainer();
	jQuery(display).empty();
	if(!display)
		display = createTiddlyElement(wrapper, "div", story.containerId());
	nodes = stash.childNodes;
	for(i = nodes.length - 1; i >= 0; i--)
		display.appendChild(nodes[i]);
	jQuery(stash).remove();
}

function refreshDisplay(hint)
{
	if(typeof hint == "string")
		hint = [hint];
	var e = document.getElementById("contentWrapper");
	refreshElements(e, hint);
	if(backstage.isPanelVisible()) {
		e = document.getElementById("backstage");
		refreshElements(e, hint);
	}
}

function refreshPageTitle()
{
	document.title = getPageTitle();
}

function getPageTitle()
{
	return wikifyPlainText(store.getTiddlerText("WindowTitle", ""), null, tiddler);
}

function refreshStyles(title, doc)
{
	setStylesheet(title == null ? "" : store.getRecursiveTiddlerText(title, "", 10), title, doc || document);
}

function refreshColorPalette(title)
{
	if(!startingUp)
		refreshAll();
}

function refreshAll()
{
	refreshPageTemplate();
	refreshDisplay();
	refreshStyles("StyleSheetLayout");
	refreshStyles("StyleSheetColors");
	refreshStyles(config.refresherData.styleSheet);
	refreshStyles("StyleSheetPrint");
}

//--
//-- Option handling
//--

tw.options = {
	defaults: {},
	define: function(name, defaultValue, description) {
		this.defaults[name] = defaultValue;
		if(config.options[name] === undefined) config.options[name] = defaultValue;
		if(description) config.optionsDesc[name] = description;
	},
	hasDefaultValue: function(name) {
		return config.options[name] == this.defaults[name] ||
		       config.options[name] === undefined;
	}
};

for(var name in config.options) {
	tw.options.define(name, config.options[name], config.optionsDesc[name]);
}

config.optionHandlers = {
	'txt': {
		get: function(name) { return encodeCookie(config.options[name].toString()) },
		set: function(name, value) { config.options[name] = decodeCookie(value) }
	},
	'chk': {
		get: function(name) { return config.options[name] ? 'true' : 'false' },
		set: function(name, value) { config.options[name] = value == 'true' }
	}
};

function setOption(name, value)
{
	var optType = name.substr(0, 3);
	if(config.optionHandlers[optType] && config.optionHandlers[optType].set)
		config.optionHandlers[optType].set(name, value);
}

// Gets the value of an option as a string. Most code should just read from config.options.* directly
function getOption(name)
{
	var optType = name.substring(0, 3);
	return config.optionHandlers[optType] && config.optionHandlers[optType].get ?
		config.optionHandlers[optType].get(name) : null;
}

function loadOptions()
{
	if(safeMode) return;
	loadCookies();
	loadSystemSettings();
}
// @Deprecated; retained for backwards compatibility
var loadOptionsCookie = loadOptions;

function getCookies()
{
	var cookieList = document.cookie.split(';');
	var i, cookies = {};
	for(i = 0; i < cookieList.length; i++) {
		var p = cookieList[i].indexOf('=');
		if(p != -1) {
			var name = jQuery.trim(cookieList[i].substring(0, p));
			var value = jQuery.trim(cookieList[i].substring(p + 1));
			cookies[name] = value;
		}
	}
	return cookies;
}

function loadCookies()
{
	var i, cookies = getCookies();
	if(cookies['TiddlyWikiClassicOptions']) // TW291 and later //#159
		cookies = cookies['TiddlyWikiClassicOptions'].replace(/%22/g, '"').replace(/%25/g, '%').decodeHashMap(); // #159
	else if(cookies['TiddlyWikiOptions']) // TW290 beta //#159
		cookies = cookies['TiddlyWikiOptions'].replace(/%25/g, '%').decodeHashMap(); // #159
	else if(cookies['TiddlyWiki']) // TW281 and earlier
		cookies = cookies['TiddlyWiki'].decodeHashMap();

	for(i in cookies) {
		if(config.optionsSource[i] != 'setting') {
			setOption(i, cookies[i]);
		}
	}
}

function loadSystemSettings()
{
	var key, settings = store.calcAllSlices('SystemSettings');
	config.optionsSource = {};
	for(key in settings) {
		setOption(key, settings[key]);
		config.optionsSource[key] = 'setting';
	}
}

function onSystemSettingsChange()
{
	if(!startingUp) {
		loadSystemSettings();
	}
}

function saveOption(name)
{
	if(safeMode) return;
	if(name.match(/[()\s]/g, '_')) {
		alert(config.messages.invalidCookie.format([name]));
		return;
	}

	saveCookie(name);
	if(config.optionsSource[name] == 'setting') {
		saveSystemSetting(name, true);
	}
}
// @Deprecated; retained for backwards compatibility
var saveOptionCookie = saveOption;

function removeCookie(name)
{
	document.cookie = name + '=; expires=Thu, 01-Jan-1970 00:00:01 UTC; path=/;';
}

function saveCookie(name)
{
	var key, cookies = {};
	for(key in config.options) {
		if(tw.options.hasDefaultValue(key)) continue;
		var value = getOption(key);
		value = value == null ? 'false' : value;
		cookies[key] = value;
	}
	document.cookie = 'TiddlyWikiClassicOptions='
		+ String.encodeHashMap(cookies).replace(/%/g, '%25').replace(/"/g, '%22')
		+ '; expires=Fri, 1 Jan 2038 12:00:00 UTC; path=/';

	// clean up cookies saved in an earlier format, before TW291 (#159)
	cookies = getCookies();
	for(var c in cookies) {
		var optType = c.substring(0, 3);
		if(config.optionHandlers[optType])
			removeCookie(c);
	}
}

var systemSettingSave;
function commitSystemSettings(storeWasDirty)
{
	if(systemSettingSave) {
		window.clearTimeout(systemSettingSave);
	}
	systemSettingSave = window.setTimeout(function() {
		var tiddler = store.getTiddler('SystemSettings');
		autoSaveChanges(null, [tiddler]);
	}, 1000);
}

function saveSystemSetting(name, saveFile)
{
	var title = 'SystemSettings';
	var slice = store.getTiddlerSlice(title, name);
	var isUnchanged = slice === getOption(name);
	if(readOnly || isUnchanged) return;

	var slices = store.calcAllSlices(title);
	for(var key in config.optionsSource) {
		var value = getOption(key) || '';
		if(slices[key] !== value) {
			slices[key] = value;
		}
	}

	var text = [];
	for(key in slices) {
		text.push('%0: %1'.format([key, slices[key]]));
	}
	text = text.sort().join('\n');

	var storeWasDirty = store.isDirty();
	var tiddler = store.getTiddler(title);
	if(tiddler) {
		tiddler.text = text;
		tiddler = store.saveTiddler(tiddler);
	} else {
		tiddler = store.saveTiddler(title, title, text, 'System',
			new Date(), ['excludeLists'], config.defaultCustomFields);
	}
	if(saveFile) {
		commitSystemSettings(storeWasDirty);
	}
}

function encodeCookie(s)
{
	return escape(convertUnicodeToHtmlEntities(s));
}

function decodeCookie(s)
{
	s = unescape(s);
	var re = /&#[0-9]{1,5};/g;
	return s.replace(re, function($0) { return String.fromCharCode(eval($0.replace(/[&#;]/g, ''))) });
}

config.macros.option.genericCreate = function(place, type, opt, className, desc)
{
	var typeInfo = config.macros.option.types[type];
	var text = desc != 'no' ? (config.optionsDesc[opt] || opt) : null;
	var attributes = { option: opt };
	if(typeInfo.typeValue) attributes.type = typeInfo.typeValue;
	if(config.optionsDesc[opt]) attributes.title = config.optionsDesc[opt];
	var c = createTiddlyElement(place, typeInfo.elementType, null, className || typeInfo.className, text, attributes);
	c[typeInfo.eventName] = typeInfo.onChange;
	c[typeInfo.valueField] = config.options[opt];
	return c;
};

config.macros.option.genericOnChange = function(e)
{
	var opt = this.getAttribute('option');
	if(opt) {
		var optType = opt.substring(0, 3);
		var handler = config.macros.option.types[optType];
		if(handler.elementType && handler.valueField)
			config.macros.option.propagateOption(opt, handler.valueField,
				this[handler.valueField], handler.elementType, this);
	}
	return true;
};

config.macros.option.types = {
	'txt': {
		elementType: 'input',
		valueField: 'value',
		eventName: 'onchange',
		className: 'txtOptionInput',
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	},
	'chk': {
		elementType: 'input',
		valueField: 'checked',
		eventName: 'onclick',
		className: 'chkOptionInput',
		typeValue: 'checkbox',
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	}
};

config.macros.option.propagateOption = function(opt, valueField, value, elementType, sourceEditor)
{
	config.options[opt] = value;
	saveOption(opt);

	jQuery(elementType + '[option=' + opt + ']').each(function(i, editor) {
		if(editor != sourceEditor) editor[valueField] = value;
	});
};

config.macros.option.handler = function(place, macroName, params, wikifier, paramString)
{
	params = paramString.parseParams('anon', null, true, false, false);
	var opt = (params[1] && params[1].name == 'anon') ? params[1].value : getParam(params, 'name', null);
	var className = (params[2] && params[2].name == 'anon') ? params[2].value : getParam(params, 'class', null);
	var desc = getParam(params, 'desc', 'no');
	var type = opt.substring(0, 3);
	var h = config.macros.option.types[type];
	if(h && h.create)
		h.create(place, type, opt, className, desc);
};

config.macros.options.handler = function(place, macroName, params, wikifier, paramString)
{
	params = paramString.parseParams('anon', null, true, false, false);
	var showUnknown = getParam(params, 'showUnknown', 'no');
	var wizard = new Wizard();
	wizard.createWizard(place, this.wizardTitle);
	wizard.addStep(this.step1Title, this.step1Html);
	var markList = wizard.getElement('markList');
	var chkUnknown = wizard.getElement('chkUnknown');
	chkUnknown.checked = showUnknown == 'yes';
	chkUnknown.onchange = this.onChangeUnknown;
	var listWrapper = document.createElement('div');
	markList.parentNode.insertBefore(listWrapper, markList);
	wizard.setValue('listWrapper', listWrapper);
	this.refreshOptions(listWrapper, showUnknown == 'yes');
};

config.macros.options.refreshOptions = function(listWrapper, showUnknown)
{
	var n, opts = [];
	for(n in config.options) {
		var isUnknown = !config.optionsDesc[n];
		if(!isUnknown || showUnknown) opts.push({
			option: '',
			name: n,
			lowlight: isUnknown,
			description: config.optionsDesc[n] || this.unknownDescription
		});
	}
	opts.sort(function(a, b) {
		var nameA = a.name.substring(3);
		var nameB = b.name.substring(3);
		return nameA < nameB ? -1 : (nameA == nameB ? 0 : +1);
	});

	ListView.create(listWrapper, opts, this.listViewTemplate);
	for(var i = 0; i < opts.length; i++) {
		var type = opts[i].name.substring(0, 3);
		var h = config.macros.option.types[type];
		if(h && h.create) {
			h.create(opts[i].colElements['option'], type, opts[i].name, null, 'no');
		}
	}
};

config.macros.options.onChangeUnknown = function(e)
{
	var wizard = new Wizard(this);
	var listWrapper = wizard.getValue('listWrapper');
	jQuery(listWrapper).empty();
	config.macros.options.refreshOptions(listWrapper, this.checked);
	return false;
};

//--
//-- Saving
//--

var startSaveArea = '<div id="' + 'storeArea">'; // Split up into two so that indexOf() of this source doesn't find it
var startSaveAreaRE = /<((div)|(DIV)) ((id)|(ID))=["']?storeArea['"]?>/; // Used for IE6
var endSaveArea = '</d' + 'iv>';
var endSaveAreaCaps = '</D' + 'IV>';

// If there are unsaved changes, force the user to confirm before exitting
function confirmExit()
{
	hadConfirmExit = true;
	var hasDirtyStore = store && store.isDirty && store.isDirty();
	var hasDirtyStory = story && story.areAnyDirty && story.areAnyDirty();
	if(hasDirtyStore || hasDirtyStory) return config.messages.confirmExit;
}

// Give the user a chance to save changes before exitting
function checkUnsavedChanges()
{
	if(!(store && store.isDirty && store.isDirty()) || window.hadConfirmExit !== false) return;
	if(confirm(config.messages.unsavedChangesWarning)) saveChanges();
}

function updateLanguageAttribute(s)
{
	if(!config.locale) return s;
	var m = /(<html(?:.*?)?)(?: xml:lang\="([a-z]+)")?(?: lang\="([a-z]+)")?>/.exec(s);
	if(!m) return s;

	var htmlTag = m[1];
	if(m[2]) htmlTag += ' xml:lang="' + config.locale + '"';
	if(m[3]) htmlTag += ' lang="' + config.locale + '"';
	htmlTag += ">";

	return s.substr(0, m.index) + htmlTag + s.substr(m.index + m[0].length);
}

function updateMarkupBlock(s, blockName, tiddlerName)
{
	return tw.textUtils.replaceChunk(s,
		"<!--%0-START-->".format([blockName]),
		"<!--%0-END-->".format([blockName]),
		"\n" + store.getRecursiveTiddlerText(tiddlerName, "") + "\n");
}

function updateOriginal(original, posDiv, localPath)
{
	if(!posDiv) posDiv = locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.invalidFileError.format([localPath]));
		return null;
	}
	var revised = original.substr(0, posDiv[0] + startSaveArea.length) + "\n" +
		store.allTiddlersAsHtml() + "\n" +
		original.substr(posDiv[1]);
	var newSiteTitle = getPageTitle().htmlEncode();
	revised = tw.textUtils.replaceChunk(revised, "<title" + ">", "</title" + ">", " " + newSiteTitle + " ");
	revised = updateLanguageAttribute(revised);
	revised = updateMarkupBlock(revised, "PRE-HEAD", "MarkupPreHead");
	revised = updateMarkupBlock(revised, "POST-HEAD", "MarkupPostHead");
	revised = updateMarkupBlock(revised, "PRE-BODY", "MarkupPreBody");
	revised = updateMarkupBlock(revised, "POST-SCRIPT", "MarkupPostBody");
	return revised;
}

function locateStoreArea(original)
{
	// Locate the storeArea divs
	if(!original) return null;
	var posOpeningDiv = original.search(startSaveAreaRE);
	var limitClosingDiv = original.indexOf("<" + "!--POST-STOREAREA--" + ">");
	if(limitClosingDiv == -1)
		limitClosingDiv = original.indexOf("<" + "!--POST-BODY-START--" + ">");
	var start = limitClosingDiv == -1 ? original.length : limitClosingDiv;
	var posClosingDiv = original.lastIndexOf(endSaveArea, start);
	if(posClosingDiv == -1)
		posClosingDiv = original.lastIndexOf(endSaveAreaCaps, start);
	return (posOpeningDiv != -1 && posClosingDiv != -1) ? [posOpeningDiv, posClosingDiv] : null;
}

function autoSaveChanges(onlyIfDirty, tiddlers)
{
	if(config.options.chkAutoSave)
		saveChanges(onlyIfDirty, tiddlers);
}

// get the full HTML of the original file
function loadOriginal(localPath, callback)
{
	if(!callback) return loadFile(localPath) || window.originalHTML || recreateOriginal();

	tw.io.loadFile(localPath, function(result, details) {
		if(typeof result == 'string') {
			callback(result, details);
		} else {
			var original = window.originalHTML || recreateOriginal();
			callback(original);
		}
	});
}

// reconstruct original HTML file content from current document memory
function recreateOriginal()
{
	// construct doctype
	var content = "<!DOCTYPE ";
	var t = document.doctype;
	if (!t)
		content += "html";
	else {
		content += t.name;
		if(t.publicId)
			content += ' PUBLIC "' + t.publicId + '"';
		else if(t.systemId)
			content += ' SYSTEM "' + t.systemId + '"';
	}
	content += ' "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"';
	content += '>\n';

	// append current document content
	content += document.documentElement.outerHTML;

	// clear 'savetest' marker
	content = content.replace(/<div id="saveTest">savetest<\/div>/, '<div id="saveTest"></div>');
	content = content.replace(/script><applet [^\>]*><\/applet>/g, 'script>');
	// newline before head tag
	content = content.replace(/><head>/, '>\n<head>');
	// newlines before/after end of body/html tags
	content = content.replace(/\n\n<\/body><\/html>$/, '</' + 'body>\n</' + 'html>\n'); // #170
	// meta tag terminators
	content = content.replace(/(<(meta) [^\>]*[^\/])>/g, '$1 />');
	// decode LT/GT entities in noscript
	content = content.replace(/<noscript>[^\<]*<\/noscript>/,
		function(m) { return m.replace(/&lt;/g, '<').replace(/&gt;/g, '>') });
	// encode copyright symbols (UTF-8 to HTML entity)
	content = content.replace(/<div id="copyright">[^\<]*<\/div>/,
		function(m) { return m.replace(/\xA9/g, '&copy;') });

	return content;
}

// reconstruct the local path to TW itself
tw.io.getOriginalLocalPath = function()
{
	return getLocalPath(document.location.toString());
};

// Save tiddlywiki (but not backup or anything else)
tw.io.knownSaveMainFailures = {
	failedToLoadOriginal: 1,
	invalidFile: 2
};

// Save this tiddlywiki with the pending changes
tw.io.saveMainAndReport = function(callback)
{
	var localPath = tw.io.getOriginalLocalPath();
	var onLoadOriginal = function(original) {
		if(original == null) {
			alert(msg.cantSaveError);
			if(store.tiddlerExists(msg.saveInstructions))
				story.displayTiddler(null, msg.saveInstructions);

			return callback(false, {
				reason: tw.io.knownSaveMainFailures.failedToLoadOriginal
			});
		}

		var posDiv = locateStoreArea(original);
		if(!posDiv) {
			alert(msg.invalidFileError.format([localPath]));

			return callback(false, {
				reason: tw.io.knownSaveMainFailures.invalidFile
			});
		}

		config.saveByDownload = false;
		config.saveByManualDownload = false;
		// chkPreventAsyncSaving is checked inside saveMain
		saveMain(localPath, original, posDiv, callback);
	};

	if(!config.options.chkPreventAsyncSaving) {
		loadOriginal(localPath, onLoadOriginal);
	} else {
		// useful when loadOriginal is overwritten without support of callback
		// or when an extension relies saveChanges being a sync function
		var original = loadOriginal(localPath);
		onLoadOriginal(original);
	}
};

function saveChanges(onlyIfDirty, tiddlers)
{
	if(onlyIfDirty && !store.isDirty()) return;

	clearMessage();
	var t0 = new Date();
	var msg = config.messages;
	if(!window.allowSave()) {
		alert(msg.notFileUrlError);
		if(store.tiddlerExists(msg.saveInstructions))
			story.displayTiddler(null, msg.saveInstructions);
		return;
	}

	tw.io.saveMainAndReport(function postSave(savedOrPending, details) {
		var co = config.options;
		if (!config.saveByDownload && !config.saveByManualDownload && details && details.original) {
			var localPath = tw.io.getOriginalLocalPath();
			if(co.chkSaveBackups) saveBackup(localPath, details.original);
			if(co.chkSaveEmptyTemplate) saveEmpty(localPath, details.original);
			if(co.chkGenerateAnRssFeed) saveRss(localPath);
		}

		if(co.chkDisplayInstrumentation)
			displayMessage("saveChanges " + (new Date() - t0) + " ms");
	});
}

function saveMain(localPath, original, posDiv, callback)
{
	var reportStatusAndHandle = function(successOrPending, localPath, revised) {
		if(successOrPending) {
			tw.io.onSaveMainSuccess(config.saveByDownload ?
				getDataURI(revised) : "file://" + localPath,
				revised, original);
		} else {
			tw.io.onSaveMainFail();
		}
	};
	try {
		var revised = updateOriginal(original, posDiv, localPath);

		if(!callback || config.options.chkPreventAsyncSaving) {
			var savedOrPending = tw.io.saveFile(localPath, revised);
			reportStatusAndHandle(savedOrPending, localPath, revised);
			if(callback) callback(savedOrPending, {
				original: original
			});
		} else tw.io.saveFile(localPath, revised, function(success, details) {
			reportStatusAndHandle(success, localPath, revised);
			details.original = original;
			callback(success, details);
		});
	} catch (ex) {
		tw.io.onSaveMainFail(ex);
		if(callback) callback(false, { original: original });
	}
}

tw.io.onSaveMainSuccess = function(urlSaved, savedHtml, original) {
	if (!config.saveByManualDownload) {
		displayMessage(
			// set by HTML5DownloadSaveFile()
			config.saveByDownload ?
				config.messages.mainDownload :
				config.messages.mainSaved,
			urlSaved);
	}

	store.setDirty(false);
};

tw.io.onSaveMainFail = function(catchedExeption) {
	alert(config.messages.mainFailed);
	if(catchedExeption) showException(catchedExeption);
};

function saveBackup(localPath, original)
{
	var backupPath = getBackupPath(localPath);
	var backupSuccess = copyFile(backupPath, localPath) || saveFile(backupPath, original);
	if(backupSuccess)
		displayMessage(config.messages.backupSaved, "file://" + backupPath);
	else
		alert(config.messages.backupFailed);
}

function saveEmpty(localPath, original, posDiv)
{
	posDiv = posDiv || locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.emptyFailed);
		return;
	}

	var emptyPath, slashPosition;
	if((slashPosition = localPath.lastIndexOf("/")) != -1)
		emptyPath = localPath.substr(0, slashPosition) + "/";
	else if((slashPosition = localPath.lastIndexOf("\\")) != -1)
		emptyPath = localPath.substr(0, slashPosition) + "\\";
	else
		emptyPath = localPath + ".";
	emptyPath += "empty.html";

	var empty = original.substr(0, posDiv[0] + startSaveArea.length) + original.substr(posDiv[1]);
	var emptySave = saveFile(emptyPath, empty);
	if(emptySave)
		displayMessage(config.messages.emptySaved, "file://" + emptyPath);
	else
		alert(config.messages.emptyFailed);
}

// Translate URL to local path [Preemption]
window.getLocalPath = window.getLocalPath || function(origPath)
{
	var originalPath = convertUriToUTF8(origPath, config.options.txtFileSystemCharSet);
	// Remove any location or query part of the URL
	var argPos = originalPath.indexOf("?");
	if(argPos != -1)
		originalPath = originalPath.substr(0, argPos);
	var hashPos = originalPath.indexOf("#");
	if(hashPos != -1)
		originalPath = originalPath.substr(0, hashPos);
	// Convert file://localhost/ to file:///
	if(originalPath.indexOf("file://localhost/") == 0)
		originalPath = "file://" + originalPath.substr(16);
	// Convert to a native file format
	// "file:///x:/path/path/path..." - pc local file --> "x:\path\path\path..."
	// "file://///server/share/path/path/path..." - FireFox pc network file --> "\\server\share\path\path\path..."
	// "file:///path/path/path..." - mac/unix local file --> "/path/path/path..."
	// "file://server/share/path/path/path..." - pc network file --> "\\server\share\path\path\path..."
	var localPath;
	if(originalPath.charAt(9) == ":") // pc local file
		localPath = unescape(originalPath.substr(8)).replace(new RegExp("/", "g"), "\\");
	else if(originalPath.indexOf("file://///") == 0) // FireFox pc network file
		localPath = "\\\\" + unescape(originalPath.substr(10)).replace(new RegExp("/", "g"), "\\");
	else if(originalPath.indexOf("file:///") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(7));
	else if(originalPath.indexOf("file:/") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(5));
	else // pc network file
		localPath = "\\\\" + unescape(originalPath.substr(7)).replace(new RegExp("/", "g"), "\\");
	return localPath;
};

function getBackupPath(localPath, filenameSuffix, extension)
{
	var slash = "\\";
	var dirPathPos = localPath.lastIndexOf("\\");
	if(dirPathPos == -1) {
		dirPathPos = localPath.lastIndexOf("/");
		slash = "/";
	}
	var backupFolder = config.options.txtBackupFolder || ".";
	var backupPath = localPath.substring(0, dirPathPos) + slash + backupFolder + localPath.substring(dirPathPos);
	backupPath = backupPath.substring(0, backupPath.lastIndexOf(".")) + ".";
	if(filenameSuffix) {
		var illegalFilenameCharacterOrSpaceRE = /[\\\/\*\?\":<> ]/g;
		backupPath += filenameSuffix.replace(illegalFilenameCharacterOrSpaceRE, "_") + ".";
	}
	backupPath += (new Date()).convertToYYYYMMDDHHMMSSMMM() + "." + (extension || "html");
	return backupPath;
}

//--
//-- RSS Saving
//--

function saveRss(localPath)
{
	var rssPath = localPath.substr(0, localPath.lastIndexOf(".")) + ".xml";
	if(saveFile(rssPath, generateRss()))
		displayMessage(config.messages.rssSaved, "file://" + rssPath);
	else
		alert(config.messages.rssFailed);
}

tiddlerToRssItem = function(tiddler, uri)
{
	var s = "<title" + ">" + tiddler.title.htmlEncode() + "</title" + ">\n";
	s += "<description>" + wikifyStatic(tiddler.text, null, tiddler).htmlEncode() + "</description>\n";
	for(var i = 0; i < tiddler.tags.length; i++)
		s += "<category>" + tiddler.tags[i] + "</category>\n";
	s += "<link>" + uri + "#" + encodeURIComponent(String.encodeTiddlyLink(tiddler.title)) + "</link>\n";
	s += "<pubDate>" + tiddler.modified.toGMTString() + "</pubDate>\n";
	return s;
};

function generateRss()
{
	var s = [];
	var d = new Date();
	var u = store.getTiddlerText("SiteUrl");
	// Assemble the header
	s.push("<" + "?xml version=\"1.0\"?" + ">");
	s.push("<rss version=\"2.0\">");
	s.push("<channel>");
	s.push("<title" + ">" + wikifyPlainText(store.getTiddlerText("SiteTitle", ""),
		null, tiddler).htmlEncode() + "</title" + ">");
	if(u) s.push("<link>" + u.htmlEncode() + "</link>");
	s.push("<description>" + wikifyPlainText(store.getTiddlerText("SiteSubtitle", ""),
		null, tiddler).htmlEncode() + "</description>");
	s.push("<language>" + config.locale + "</language>");
	s.push("<copyright>Copyright " + d.getFullYear() + " " + config.options.txtUserName.htmlEncode() + "</copyright>");
	s.push("<pubDate>" + d.toGMTString() + "</pubDate>");
	s.push("<lastBuildDate>" + d.toGMTString() + "</lastBuildDate>");
	s.push("<docs>http://blogs.law.harvard.edu/tech/rss</docs>");
	s.push("<generator>TiddlyWiki " + formatVersion() + "</generator>");
	// The body
	var tiddlers = store.getTiddlers("modified", "excludeLists");
	var i, n = config.numRssItems > tiddlers.length ? 0 : tiddlers.length - config.numRssItems;
	for(i = tiddlers.length - 1; i >= n; i--) {
		s.push("<item>\n" + tiddlerToRssItem(tiddlers[i], u) + "\n</item>");
	}
	// And footer
	s.push("</channel>");
	s.push("</rss>");
	// Save it all
	return s.join("\n");
}

//--
//-- Filesystem code
//--

// Copy a file in filesystem [Preemption]
window.copyFile = window.copyFile || function(dest, source)
{
	return config.browser.isIE ? ieCopyFile(dest, source) : false;
};

// Save a file in filesystem [Preemption]
window.saveFile = window.saveFile || function(fileUrl, content)
{
	var r = mozillaSaveFile(fileUrl, content);
	if(!r)
		r = ieSaveFile(fileUrl, content);
	if(!r)
		r = javaSaveFile(fileUrl, content);
	if(!r)
		r = HTML5DownloadSaveFile(fileUrl, content);
	if(!r)
		r = manualSaveFile(fileUrl, content);
	return r;
};

// A placeholder method that can be overwritten/decorated by savers.
// In such a case, it's required to call callback on both success and fail.
// See details about the callback in tw.io.saveFile.
tw.io.asyncSaveFile = tw.io.asyncSaveFile || function(fileUrl, content, callback)
{
	callback(false, { reason: 'Async saving is not implemented' });
};

// The general save method to use
// ==============================
// If callback is set, tries to save in an async fashion and do callback(success: boolean, details: object)
// ⚠️ Some savers within window.saveFile, like download saving or Timimi don't care about the callback,
// so it can be called before actual saving is done (or even give false positives).
tw.io.saveFile = function(fileUrl, content, callback)
{
	if(!callback) return saveFile(fileUrl, content);

	tw.io.asyncSaveFile(fileUrl, content, function(success, details) {
		if(success) callback(success, details);
		else {
			result = saveFile(fileUrl, content);
			callback(result, {});
		}
	});
};

// Load a file from filesystem [Preemption]
window.loadFile = window.loadFile || function(fileUrl)
{
	var r = mozillaLoadFile(fileUrl);
	if((r === null) || (r === false))
		r = ieLoadFile(fileUrl);
	if((r === null) || (r === false))
		r = javaLoadFile(fileUrl);
	if((r === null) || (r === false))
		r = tw.io.xhrLoadFile(fileUrl);
	return r;
};

tw.io.xhrLoadFile = function(filePath, callback)
{
	try {
		var isAsync = !!callback;
		var url = 'file://' + (filePath[0] != '/' ? '/' : '') + encodeURIComponent(filePath);
		if(isAsync) {
			httpReq('GET', url, function(status, params, responseText, url, xhr) {
				callback(responseText, { xhr: xhr });
			});
		} else {
			var xhr = new XMLHttpRequest();
			xhr.open('GET', url, isAsync);
			xhr.send(null);
			return xhr.responseText;
		}
	} catch(ex) {
		return callback ? callback(null) : null;
	}
};

// The general load method to use
// ==============================
// If callback is set, tries to load in an async fashion and do callback(result, details)
tw.io.loadFile = function(fileUrl, callback)
{
	if(!callback) return loadFile(fileUrl);

	tw.io.xhrLoadFile(fileUrl, function(result, details) {
		if(typeof result == 'string') {
			callback(result, details);
		} else {
			result = loadFile(fileUrl);
			callback(result);
		}
	});
};


function ieCreatePath(path)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	} catch(ex) {
		return null;
	}

	// Remove the filename, if present. Use trailing slash (i.e. "foo\bar\") if no filename.
	var pos = path.lastIndexOf("\\");
	if(pos == -1) pos = path.lastIndexOf("/");
	if(pos != -1) path = path.substring(0, pos + 1);

	// Walk up the path until we find a folder that exists
	var scan = [path];
	var parent = fso.GetParentFolderName(path);
	while(parent && !fso.FolderExists(parent)) {
		scan.push(parent);
		parent = fso.GetParentFolderName(parent);
	}

	// Walk back down the path, creating folders
	for(var i = scan.length - 1; i >= 0; i--) {
		if(!fso.FolderExists(scan[i])) {
			fso.CreateFolder(scan[i]);
		}
	}
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath, content)
{
	ieCreatePath(filePath);
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	} catch(ex) {
		return null;
	}
	var file = fso.OpenTextFile(filePath, 2, -1, 0);
	file.Write(convertUnicodeToHtmlEntities(content));
	file.Close();
	return true;
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var file = fso.OpenTextFile(filePath, 1);
		var content = file.ReadAll();
		file.Close();
	} catch(ex) {
		return null;
	}
	return content;
}

function ieCopyFile(dest, source)
{
	ieCreatePath(dest);
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		fso.GetFile(source).Copy(dest);
	} catch(ex) {
		return false;
	}
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath, content)
{
	if(!window.Components) return null;

	content = mozConvertUnicodeToUTF8(content);
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var file = Components.classes["@mozilla.org/file/local;1"]
			.createInstance(Components.interfaces.nsILocalFile);
		file.initWithPath(filePath);
		if(!file.exists())
			file.create(0, 0x01B4);// 0x01B4 = 0664
		var out = Components.classes["@mozilla.org/network/file-output-stream;1"]
			.createInstance(Components.interfaces.nsIFileOutputStream);
		out.init(file, 0x22, 0x04, null);
		out.write(content, content.length);
		out.flush();
		out.close();
		return true;
	} catch(ex) {
		return false;
	}
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
	if(!window.Components) return null;

	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
		file.initWithPath(filePath);
		if(!file.exists())
			return null;
		var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"]
			.createInstance(Components.interfaces.nsIFileInputStream);
		inputStream.init(file, 0x01, 0x04, null);
		var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"]
			.createInstance(Components.interfaces.nsIScriptableInputStream);
		sInputStream.init(inputStream);
		var contents = sInputStream.read(sInputStream.available());
		sInputStream.close();
		inputStream.close();
		return mozConvertUTF8ToUnicode(contents);
	} catch(ex) {
		return false;
	}
}

function HTML5DownloadSaveFile(filePath, content)
{
	var link = document.createElement("a");
	if(link.download === undefined)
		return null;

	config.saveByDownload = true;
	var slashpos = filePath.lastIndexOf("/");
	if (slashpos == -1) slashpos = filePath.lastIndexOf("\\");
	var filename = filePath.substr(slashpos + 1);
	var uri = getDataURI(content);
	link.setAttribute("target", "_blank");
	link.setAttribute("href", uri);
	link.setAttribute("download", filename);
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function manualSaveFile(filePath, content)
{
	// FALLBACK for showing a link to data: URI
	config.saveByManualDownload = true;
	var slashpos = filePath.lastIndexOf("/");
	if (slashpos == -1) slashpos = filePath.lastIndexOf("\\");
	var filename = filePath.substr(slashpos + 1);
	var uri = getDataURI(content);
	displayMessage(config.messages.mainDownloadManual, uri);
	return true;
}

// construct data URI (using base64 encoding to preserve multi-byte encodings)
function getDataURI(data)
{
	return config.browser.isIE ?
		"data:text/html," + encodeURIComponent(data) :

		// manualConvertUnicodeToUTF8 was moved here from convertUnicodeToFileFormat
		// In 2.9.1, it was used only for FireFox but happened to fix
		// download saving non-ASCII in Chrome & Safari as well (see 949aff6)
		"data:text/html;base64," + encodeBase64(manualConvertUnicodeToUTF8(data));
}

function encodeBase64(data)
{
	if (!data) return "";
	var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	var out = "";
	var chr1, chr2, chr3 = "";
	var enc1, enc2, enc3, enc4 = "";
	for (var i = 0; i < data.length; )
	{
		chr1 = data.charCodeAt(i++);
		chr2 = data.charCodeAt(i++);
		chr3 = data.charCodeAt(i++);
		enc1 = chr1 >> 2;
		enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
		enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
		enc4 = chr3 & 63;
		if (isNaN(chr2)) enc3 = enc4 = 64;
		else if (isNaN(chr3)) enc4 = 64;
		out += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
		chr1 = chr2 = chr3 = enc1 = enc2 = enc3 = enc4 = "";
	}
	return out;
}

//--
//-- Filesystem utilities
//--

function convertUTF8ToUnicode(u)
{
	return config.browser.isOpera || !window.netscape ? manualConvertUTF8ToUnicode(u) : mozConvertUTF8ToUnicode(u);
}


function manualConvertUTF8ToUnicode(utf)
{
	var uni = utf;
	var src = 0;
	var dst = 0;
	var b1, b2, b3;
	var c;
	while(src < utf.length) {
		b1 = utf.charCodeAt(src++);
		if(b1 < 0x80) {
			dst++;
		} else if(b1 < 0xE0) {
			b2 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0x1F) << 6) | (b2 & 0x3F));
			uni = uni.substring(0, dst++).concat(c, utf.substr(src));
		} else {
			b2 = utf.charCodeAt(src++);
			b3 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0xF) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));
			uni = uni.substring(0, dst++).concat(c, utf.substr(src));
		}
	}
	return uni;
}

function mozConvertUTF8ToUnicode(u)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"]
			.createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUTF8ToUnicode(u);
	} // fallback
	var s = converter.ConvertToUnicode(u);
	var fin = converter.Finish();
	return fin.length > 0 ? s + fin : s;
}

function manualConvertUnicodeToUTF8(s)
{
	return unescape(encodeURIComponent(s));
}

function mozConvertUnicodeToUTF8(s)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"]
			.createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUnicodeToUTF8(s);
	} // fallback
	var u = converter.ConvertFromUnicode(s);
	var fin = converter.Finish();
	return fin.length > 0 ? u + fin : u;
}

function convertUnicodeToHtmlEntities(s)
{
	var re = /[^\u0000-\u007F]/g;
	return s.replace(re, function($0) { return "&#" + $0.charCodeAt(0).toString() + ";" });
}

function convertUriToUTF8(uri, charSet)
{
	if(window.netscape == undefined || charSet == undefined || charSet == "")
		return uri;
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/utf8converterservice;1"]
			.getService(Components.interfaces.nsIUTF8ConverterService);
	} catch(ex) {
		return uri;
	}
	return converter.convertURISpecToUTF8(uri, charSet);
}

// deprecated helper for backward-compatibility with elder extensions
// (browser/saving method-specific convertion is only needed in browser-specific savers)
function convertUnicodeToFileFormat(s)
{
	return s;
}

// deprecated helper for backward-compatibility with elder extensions
function convertUnicodeToUTF8(s)
{
	return s;
}

//--
//-- Server adaptor base class
//--

function AdaptorBase()
{
	this.host = null;
	this.store = null;
	return this;
}

AdaptorBase.prototype.close = function()
{
	return true;
};

AdaptorBase.prototype.fullHostName = function(host)
{
	if(!host) return '';
	host = jQuery.trim(host);
	if(!host.match(/:\/\//))
		host = 'http://' + host;
	if(host.substr(host.length - 1) == '/')
		host = host.substr(0, host.length - 1);
	return host;
};

AdaptorBase.minHostName = function(host)
{
	return host;
};

AdaptorBase.prototype.setContext = function(context, userParams, callback)
{
	if(!context) context = {};
	context.userParams = userParams;
	if(callback) context.callback = callback;
	context.adaptor = this;
	if(!context.host)
		context.host = this.host;
	context.host = this.fullHostName(context.host);
	if(!context.workspace)
		context.workspace = this.workspace;
	return context;
};

// Open the specified host
//   host - uri of host (eg, "http://www.tiddlywiki.com/" or "www.tiddlywiki.com")
//   context is itself passed on as a parameter to the callback function
//   userParams - user settable object object that is passed on unchanged to the callback function
//   callback - optional function to be called on completion
// Return value is true if the request was successfully issued, false if this connector doesn't support openHost(),
//   or an error description string if there was a problem
// The callback parameters are callback(context)
//   context.status - true if OK, string if error
//   context.adaptor - reference to this adaptor object
//   userParams - parameters as originally passed into the openHost function
AdaptorBase.prototype.openHost = function(host, context, userParams, callback)
{
	this.host = host;
	context = this.setContext(context, userParams, callback);
	context.status = true;
	if(callback)
		window.setTimeout(function() { context.callback(context, userParams) }, 10);
	return true;
};

// Open the specified workspace
//   workspace - name of workspace to open
//   context - passed on as a parameter to the callback function
//   userParams - user settable object object that is passed on unchanged to the callback function
//   callback - function to be called on completion
// Return value is true if the request was successfully issued
//   or an error description string if there was a problem
// The callback parameters are callback(context, userParams)
//   context.status - true if OK, false if error
//   context.statusText - error message if there was an error
//   context.adaptor - reference to this adaptor object
//   userParams - parameters as originally passed into the openWorkspace function
AdaptorBase.prototype.openWorkspace = function(workspace, context, userParams, callback)
{
	this.workspace = workspace;
	context = this.setContext(context, userParams, callback);
	context.status = true;
	if(callback)
		window.setTimeout(function() { callback(context, userParams) }, 10);
	return true;
};

//--
//-- Server adaptor for talking to static TiddlyWiki files
//--

function FileAdaptor()
{
}

FileAdaptor.prototype = new AdaptorBase();

FileAdaptor.serverType = 'file';
FileAdaptor.serverLabel = 'TiddlyWiki';

FileAdaptor.loadTiddlyWikiSuccess = function(context, jqXHR)
{
	context.status = true;
	context.adaptor.store = new TiddlyWiki();
	if(!context.adaptor.store.importTiddlyWiki(jqXHR.responseText)) {
		context.statusText = config.messages.invalidFileError.format([context.host]);
		context.status = false;
	}
	context.complete(context, context.userParams);
};

FileAdaptor.loadTiddlyWikiError = function(context, jqXHR)
{
	context.status = false;
	context.statusText = jqXHR.message;
	context.complete(context, context.userParams);
};

// Get the list of workspaces on a given server
//   context - passed on as a parameter to the callback function
//   userParams - user settable object object that is passed on unchanged to the callback function
//   callback - function to be called on completion
// Return value is true if the request was successfully issued,
//   false if this connector doesn't support getWorkspaceList(),
//   or an error description string if there was a problem
// The callback parameters are callback(context, userParams)
//   context.status - true if OK, false if error
//   context.statusText - error message if there was an error
//   context.adaptor - reference to this adaptor object
//   userParams - parameters as originally passed into the getWorkspaceList function
FileAdaptor.prototype.getWorkspaceList = function(context, userParams, callback)
{
	context = this.setContext(context, userParams, callback);
	context.workspaces = [{ title: "(default)" }];
	context.status = true;
	if(callback)
		window.setTimeout(function() { callback(context, userParams) }, 10);
	return true;
};

// Gets the list of tiddlers within a given workspace
//   context - passed on as a parameter to the callback function
//   userParams - user settable object object that is passed on unchanged to the callback function
//   callback - function to be called on completion
//   filter - filter expression
// Return value is true if the request was successfully issued,
//   or an error description string if there was a problem
// The callback parameters are callback(context, userParams)
//   context.status - true if OK, false if error
//   context.statusText - error message if there was an error
//   context.adaptor - reference to this adaptor object
//   context.tiddlers - array of tiddler objects
//   userParams - parameters as originally passed into the getTiddlerList function
FileAdaptor.prototype.getTiddlerList = function(context, userParams, callback, filter)
{
	context = this.setContext(context, userParams, callback);
	if(!context.filter)
		context.filter = filter;
	context.complete = FileAdaptor.getTiddlerListComplete;
	if(this.store) {
		return context.complete(context, context.userParams);
	}
	var options = {
		type: "GET",
		url: context.host,
		file: context.file, // for HTML5 FileReader
		processData: false,
		success: function(data, textStatus, jqXHR) {
			FileAdaptor.loadTiddlyWikiSuccess(context, jqXHR);
		},
		error: function(jqXHR, textStatus, errorThrown) {
			context.xhr = jqXHR;
			FileAdaptor.loadTiddlyWikiError(context, jqXHR);
		}
	};
	return ajaxReq(options);
};

FileAdaptor.getTiddlerListComplete = function(context, userParams)
{
	if(context.status) {
		if(context.filter) {
			context.tiddlers = context.adaptor.store.filterTiddlers(context.filter);
		} else {
			context.tiddlers = [];
			context.adaptor.store.forEachTiddler(function(title, tiddler) { context.tiddlers.push(tiddler) });
		}
		for(var i = 0; i < context.tiddlers.length; i++) {
			context.tiddlers[i].fields['server.type'] = FileAdaptor.serverType;
			context.tiddlers[i].fields['server.host'] = AdaptorBase.minHostName(context.host);
			context.tiddlers[i].fields['server.page.revision'] = context.tiddlers[i].modified.convertToYYYYMMDDHHMM();
		}
		context.status = true;
	}
	if(context.callback) {
		window.setTimeout(function() { context.callback(context, userParams) }, 10);
	}
	return true;
};

FileAdaptor.prototype.generateTiddlerInfo = function(tiddler)
{
	return {
		uri: tiddler.fields['server.host'] + "#" + tiddler.title
	};
};

// Retrieve a tiddler from a given workspace on a given server
//   title - title of the tiddler to get
//   context - passed on as a parameter to the callback function
//   userParams - user settable object object that is passed on unchanged to the callback function
//   callback - function to be called on completion
// Return value is true if the request was successfully issued,
//   or an error description string if there was a problem
// The callback parameters are callback(context, userParams)
//   context.status - true if OK, false if error
//   context.statusText - error message if there was an error
//   context.adaptor - reference to this adaptor object
//   context.tiddler - the retrieved tiddler, or null if it cannot be found
//   userParams - parameters as originally passed into the getTiddler function
FileAdaptor.prototype.getTiddler = function(title, context, userParams, callback)
{
	context = this.setContext(context, userParams, callback);
	context.title = title;
	context.complete = FileAdaptor.getTiddlerComplete;
	if(context.adaptor.store) {
		return context.complete(context, context.userParams);
	}
	var options = {
		type: "GET",
		url: context.host,
		processData: false,
		success: function(data, textStatus, jqXHR) {
			FileAdaptor.loadTiddlyWikiSuccess(context, jqXHR);
		},
		error: function(jqXHR, textStatus, errorThrown) {
			FileAdaptor.loadTiddlyWikiError(context, jqXHR);
		}
	};
	return ajaxReq(options);
};

FileAdaptor.getTiddlerComplete = function(context, userParams)
{
	var t = context.adaptor.store.fetchTiddler(context.title);
	if(t) {
		t.fields['server.type'] = FileAdaptor.serverType;
		t.fields['server.host'] = AdaptorBase.minHostName(context.host);
		t.fields['server.page.revision'] = t.modified.convertToYYYYMMDDHHMM();
		context.tiddler = t;
		context.status = true;
	} else { //# tiddler does not exist in document
		context.status = false;
	}
	if(context.allowSynchronous) {
		context.isSynchronous = true;
		context.callback(context, userParams);
	} else {
		window.setTimeout(function() { context.callback(context, userParams) }, 10);
	}
	return true;
};

FileAdaptor.prototype.close = function()
{
	this.store = null;
};

config.adaptors[FileAdaptor.serverType] = FileAdaptor;

config.defaultAdaptor = FileAdaptor.serverType;

//--
//-- HTTP request code
//--

// Perform an http request using the jQuery ajax function
// fallback to privileged file I/O or HTML5 FileReader
function ajaxReq(args)
{
	if (args.file || args.url.startsWith("file"))  // LOCAL FILE
		return localAjax(args);
	return jQuery.ajax(args);
}

// perform local I/O and FAKE a minimal XHR response object
function localAjax(args)
{
	var success = function(data) {
		args.success(data, "success", { responseText: data });
	};
	var failure = function(who) {
		args.error({ message: who + ": cannot read local file" }, "error", 0);
	};

	if (args.file) try { // HTML5 FileReader (Chrome, FF20+, Safari, etc.)
		var reader = new FileReader();
		reader.onload = function(e)  { success(e.target.result) };
		reader.onerror = function(e) { failure("FileReader") };
		reader.readAsText(args.file);
		return true;
	} catch (ex) { ; }

	// local file I/O (IE, FF with security.fileuri.strict_origin_policy:false, etc.)
	try {
		var data = loadFile(getLocalPath(args.url));
		if (data) success(data);
		else failure("loadFile");
		return true;
	} catch (ex) { ; }

	return true;
}

// Perform an http request
//   type - GET/POST/PUT/DELETE
//   url - the source url
//   data - optional data for POST and PUT
//   contentType - optionalContent type for the data (defaults to application/x-www-form-urlencoded)
//   username - optional username for basic authentication
//   password - optional password for basic authentication
//   callback - function to call when there is a response
//   params - parameter object that gets passed to the callback for storing it's state
//   headers - optional hashmap of additional headers
//   allowCache - unless true, adds a "nocache=" parameter to the URL
// Return value is the underlying XMLHttpRequest object, or a string if there was an error
// Callback function is called like this:
//   callback(status, params, responseText, url, xhr)
//     status - true if OK, false if error
//     params - the parameter object provided to loadRemoteFile()
//     responseText - the text of the file
//     url - requested URL
//     xhr - the underlying XMLHttpRequest object
function httpReq(type, url, callback, params, headers, data, contentType, username, password, allowCache)
{
	var httpSuccess = function(xhr) {
		try {
			// IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450
			return (!xhr.status && location.protocol === "file:") ||
				(xhr.status >= 200 && xhr.status < 300) ||
				xhr.status === 304 || xhr.status === 1223;
		} catch(e) {}
		return false;
	};

	var options = {
		type: type,
		url: url,
		processData: false,
		data: data,
		cache: !!allowCache,
		beforeSend: function(xhr) {
			for(var i in headers)
				xhr.setRequestHeader(i, headers[i]);
		}
	};

	if(callback) {
		options.complete = function(xhr, textStatus) {
			if(httpSuccess(xhr))
				callback(true, params, xhr.responseText, url, xhr);
			else
				callback(false, params, null, url, xhr);
		};
	}
	if(contentType)
		options.contentType = contentType;
	if(username)
		options.username = username;
	if(password)
		options.password = password;
	try {
		if(window.Components && window.netscape && window.netscape.security
		   && document.location.protocol.indexOf("http") == -1)
			window.netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	} catch (ex) {
	}
	return jQuery.ajax(options);
}
//--
//-- TiddlyWiki-specific utility functions
//--

// Return TiddlyWiki version string
function formatVersion(v)
{
	v = v || version;
	return v.major + "." + v.minor + "." + v.revision +
		(v.alpha ? " (alpha " + v.alpha + ")" : "") +
		(v.beta ? " (beta " + v.beta + ")" : "") +
		(v.nightly ? " (nightly " + v.nightly + ")" : "");
}

function compareVersions(v1, v2)
{
	var x1, x2, i, a = ["major", "minor", "revision"];
	for(i = 0; i < a.length; i++)
	{
		x1 = v1[a[i]] || 0;
		x2 = v2[a[i]] || 0;
		if(x1 < x2) return +1;
		if(x1 > x2) return -1;
	}
	x1 = v1.beta || Infinity;
	x2 = v2.beta || Infinity;
	return x1 < x2 ? +1 :
	       x1 > x2 ? -1 : 0;
}

function merge(dst, src, preserveExisting)
{
	for(var key in src)
		if(!preserveExisting || dst[key] === undefined)
			dst[key] = src[key];

	return dst;
}

// Get the target of an event
function resolveTarget(event)
{
	var obj = event.target || event.srcElement;
	// defeat Safari bug
	if(obj.nodeType == 3)
		obj = obj.parentNode;
	return obj;
}

// Return the description of an exception (string)
function exceptionText(ex, prependedMessage)
{
	var s = ex.description || ex.toString();
	return prependedMessage ? (prependedMessage + ":\n" + s) : s;
}

// Display an alert of an exception description with optional message
function showException(e, prependedMessage)
{
	alert(exceptionText(e, prependedMessage));
}

function alertAndThrow(m)
{
	alert(m);
	throw(m);
}

function glyph(name)
{
	var g = config.glyphs;
	if(!g.codes[name]) return "";
	if(g.currBrowser == null) {
		var i = 0;
		while(i < g.browsers.length - 1 && !g.browsers[i]())
			i++;
		g.currBrowser = i;
	}
	return g.codes[name][g.currBrowser];
}

function createTiddlyText(parent, text)
{
	return parent.appendChild(document.createTextNode(text));
}

function createTiddlyCheckbox(parent, caption, checked, onChange)
{
	var cb = document.createElement("input");
	cb.setAttribute("type", "checkbox");
	cb.onclick = onChange;
	parent.appendChild(cb);
	cb.checked = checked;
	cb.className = "chkOptionInput";
	if(caption)
		wikify(caption, parent);
	return cb;
}

function createTiddlyElement(parent, element, id, className, text, attribs)
{
	var n, e = document.createElement(element);
	if(className != null) e.className = className;
	if(       id != null) e.setAttribute('id', id);
	if(     text != null) createTiddlyText(e, text);
	if(attribs) {
		for(n in attribs) e.setAttribute(n, attribs[n]);
	}
	if(parent != null) parent.appendChild(e);
	return e;
}

function createTiddlyButton(parent, text, tooltip, action, className, id, accessKey, customAttributes)
{
	var attributes = { href: 'javascript:;' };
	if(tooltip)   attributes.title = tooltip;
	if(accessKey) attributes.accessKey = accessKey;
	merge(attributes, customAttributes || {});

	var btn = createTiddlyElement(parent, 'a', id || null, className || 'button', text, attributes);
	if(action) btn.onclick = action;
	return btn;
}

function createExternalLink(place, url, label)
{
	var tooltip = config.messages.externalLinkTooltip;
	var link = createTiddlyElement(place, 'a', null, 'externalLink', label, {
		href: url,
		title: tooltip ? tooltip.format([url]) : url
	});
	if(config.options.chkOpenInNewWindow)
		link.target = "_blank";
	return link;
}

function getTiddlyLinkInfo(title, currClasses)
{
	var classes = currClasses ? currClasses.split(" ") : [];
	classes.pushUnique("tiddlyLink");
	var tiddler = store.fetchTiddler(title);
	var subTitle;
	if(tiddler) {
		subTitle = tiddler.getSubtitle();
		classes.pushUnique("tiddlyLinkExisting");
		classes.remove("tiddlyLinkNonExisting");
		classes.remove("shadow");
	} else {
	    var f;
		classes.remove("tiddlyLinkExisting");
		classes.pushUnique("tiddlyLinkNonExisting");
		if(store.isShadowTiddler(title)) {
			f = config.messages.shadowedTiddlerToolTip;
			classes.pushUnique("shadow");
		} else {
			f = config.messages.undefinedTiddlerToolTip;
			classes.remove("shadow");
		}
		subTitle = f ? f.format([title]) : "";
	}
	if(typeof config.annotations[title] == "string")
		subTitle = config.annotations[title];
	return { classes: classes.join(" "), subTitle: subTitle };
}

// Event handler for clicking on a tiddly link
function onClickTiddlerLink(ev)
{
	var e = ev || window.event;
	var target = resolveTarget(e);
	var link = target;
	var title = null;
	var fields = null;
	var noToggle = null;
	do {
		title = link.getAttribute("tiddlyLink");
		fields = link.getAttribute("tiddlyFields");
		noToggle = link.getAttribute("noToggle");
		link = link.parentNode;
	} while(title == null && link != null);
	if(!store.isShadowTiddler(title)) {
		var f = fields ? fields.decodeHashMap() : {};
		fields = String.encodeHashMap(merge(f, config.defaultCustomFields, true));
	}
	if(title) {
		var toggling = e.metaKey || e.ctrlKey;
		if(config.options.chkToggleLinks)
			toggling = !toggling;
		if(noToggle)
			toggling = false;
		if(store.getTiddler(title))
			fields = null;
		story.displayTiddler(target, title, null, true, null, fields, toggling);
	}
	clearMessage();
	return false;
}

function getTiddlerLinkHref(title)
{
	return window.location.toString().replace(/#.*$/, '') + story.getPermaViewHash([title]);
}

function createTiddlyLink(place, title, includeText, className, isStatic, linkedFromTiddler, noToggle)
{
	var title = jQuery.trim(title);
	var text = includeText ? title : null;
	var info = getTiddlyLinkInfo(title, className);
	var btn = isStatic ?
		createExternalLink(place, store.getTiddlerText("SiteUrl", null) + story.getPermaViewHash([title])) :
		createTiddlyButton(place, text, info.subTitle, onClickTiddlerLink, info.classes, '', '', {
			href: getTiddlerLinkHref(title)
		});
	if(isStatic)
		btn.className += ' ' + className;
	btn.setAttribute("refresh", "link");
	btn.setAttribute("tiddlyLink", title);
	if(noToggle)
		btn.setAttribute("noToggle", "true");
	if(linkedFromTiddler)
	{
		var fields = linkedFromTiddler.getInheritedFields();
		if(fields)
			btn.setAttribute("tiddlyFields", fields);
	}
	return btn;
}

function refreshTiddlyLink(e, title)
{
	var info = getTiddlyLinkInfo(title, e.className);
	e.className = info.classes;
	e.title = info.subTitle;
}

function createTiddlyDropDown(place, onchange, options, defaultValue)
{
	var sel = createTiddlyElement(place, "select");
	sel.onchange = onchange;

	for(var i = 0; i < options.length; i++)
	{
		var e = createTiddlyElement(sel, "option", null, null, options[i].caption);
		e.value = options[i].name;
		if(e.value == defaultValue)
			e.selected = true;
	}
	return sel;
}

//--
//-- TiddlyWiki-specific popup utility functions
//--

// Event handler for 'open all' on a tiddler popup
function onClickTagOpenAll(ev)
{
	var tiddlers = store.getTaggedTiddlers(this.getAttribute("tag"));
	var sortby = this.getAttribute("sortby");
	if(sortby && sortby.length) {
		store.sortTiddlers(tiddlers, sortby);
	}
	story.displayTiddlers(this, tiddlers);
	return false;
}

// Event handler for clicking on a tiddler tag
function onClickTag(ev)
{
	var e = ev || window.event;
	var popup = Popup.create(this);
	jQuery(popup).addClass("taggedTiddlerList");
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(popup && tag) {
		var tagged = tag.indexOf("[") == -1 ? store.getTaggedTiddlers(tag) : store.filterTiddlers(tag);
		var sortby = this.getAttribute("sortby");
		if(sortby && sortby.length) {
			store.sortTiddlers(tagged, sortby);
		}
		var titles = [];
		for(var i = 0; i < tagged.length; i++) {
			if(tagged[i].title != title)
				titles.push(tagged[i].title);
		}
		var lingo = config.views.wikified.tag;
		if(titles.length > 0) {
			var openAll = createTiddlyButton(createTiddlyElement(popup, "li"),
				lingo.openAllText.format([tag]), lingo.openAllTooltip, onClickTagOpenAll);
			openAll.setAttribute("tag", tag);
			openAll.setAttribute("sortby", sortby);
			createTiddlyElement(createTiddlyElement(popup, "li", null, "listBreak"), "div");
			for(i = 0; i < titles.length; i++) {
				createTiddlyLink(createTiddlyElement(popup, "li"), titles[i], true);
			}
		} else {
			createTiddlyElement(popup, "li", null, "disabled", lingo.popupNone.format([tag]));
		}
		createTiddlyElement(createTiddlyElement(popup, "li", null, "listBreak"), "div");
		var link = createTiddlyLink(createTiddlyElement(popup, "li"), tag, false);
		createTiddlyText(link, lingo.openTag.format([tag]));
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

// Create a button for a tag with a popup listing all the tiddlers that it tags
function createTagButton(place, tag, excludeTiddler, title, tooltip)
{
	var btn = createTiddlyButton(place, title || tag,
		(tooltip || config.views.wikified.tag.tooltip).format([tag]), onClickTag);
	btn.setAttribute("tag", tag);
	if(excludeTiddler)
		btn.setAttribute("tiddler", excludeTiddler);
	return btn;
}

function onClickTiddlyPopup(ev)
{
	var e = ev || window.event;
	var tiddler = this.tiddler;
	if(tiddler.text) {
		var popup = Popup.create(this, "div", "popupTiddler");
		wikify(tiddler.text, popup, null, tiddler);
		Popup.show();
	}
	if(e) e.cancelBubble = true;
	if(e && e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyPopup(place, caption, tooltip, tiddler)
{
	if(tiddler.text) {
		createTiddlyLink(place, caption, true);
		var btn = createTiddlyButton(place, glyph("downArrow"), tooltip, onClickTiddlyPopup, "tiddlerPopupButton");
		btn.tiddler = tiddler;
	} else {
		createTiddlyText(place, caption);
	}
}

function onClickError(ev)
{
	var e = ev || window.event;
	var popup = Popup.create(this);
	var lines = this.getAttribute("errorText").split("\n");
	for(var i = 0; i < lines.length; i++) {
		createTiddlyElement(popup, "li", null, "popupMessage", lines[i]);
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyError(place, title, text)
{
	var btn = createTiddlyButton(place, title, null, onClickError, "errorButton");
	if(text) btn.setAttribute("errorText", text);
}
//-
//- Animation engine
//-

function Animator()
{
	// Incremented at start of each animation, decremented afterwards. If zero, the interval timer is disabled
	this.running = 0;
	// ID of the timer used for animating
	this.timerID = 0;
	// List of animations in progress
	this.animations = [];
	return this;
}

// Start animation engine
Animator.prototype.startAnimating = function() //# Variable number of arguments
{
	for(var i = 0; i < arguments.length; i++)
		this.animations.push(arguments[i]);
	if(this.running == 0) {
		var me = this;
		this.timerID = window.setInterval(function() { me.doAnimate(me) }, 10);
	}
	this.running += arguments.length;
};

// Perform an animation engine tick, calling each of the known animation modules
Animator.prototype.doAnimate = function(me)
{
	var i = 0;
	while(i < me.animations.length) {
		if(me.animations[i].tick()) {
			i++;
		} else {
			me.animations.splice(i, 1);
			if(--me.running == 0)
				window.clearInterval(me.timerID);
		}
	}
};

Animator.slowInSlowOut = function(progress)
{
	return 1 - ((Math.cos(progress * Math.PI) + 1) / 2);
};

//--
//-- Morpher animation
//--

// Animate a set of properties of an element
function Morpher(element, duration, properties, callback)
{
	this.element = element;
	this.duration = duration;
	this.properties = properties;
	this.startTime = new Date();
	this.endTime = Number(this.startTime) + duration;
	this.callback = callback;
	this.tick();
	return this;
}

Morpher.prototype.assignStyle = function(element, style, value)
{
	switch(style) {
		case "-tw-vertScroll":
			window.scrollTo(findScrollX(), value);
			break;
		case "-tw-horizScroll":
			window.scrollTo(value, findScrollY());
			break;
		default:
			element.style[style] = value;
			break;
	}
};

Morpher.prototype.stop = function()
{
	for(var i = 0; i < this.properties.length; i++) {
		var p = this.properties[i];
		if(p.atEnd !== undefined) {
			this.assignStyle(this.element, p.style, p.atEnd);
		}
	}
	if(this.callback)
		this.callback(this.element, this.properties);
};

Morpher.prototype.tick = function()
{
	var currTime = Number(new Date());
	var i, progress = Animator.slowInSlowOut(Math.min(1, (currTime - this.startTime) / this.duration));
	for(i = 0; i < this.properties.length; i++) {
		var p = this.properties[i];
		if(p.start !== undefined && p.end !== undefined) {
			var template = p.template || "%0";
			switch(p.format) {
				case undefined:
				case "style":
					var value = p.start + (p.end - p.start) * progress;
					this.assignStyle(this.element, p.style, template.format([value]));
					break;
				case "color":
					break;
			}
		}
	}
	if(currTime >= this.endTime) {
		this.stop();
		return false;
	}
	return true;
};

//--
//-- Zoomer animation
//--

function Zoomer(text, startElement, targetElement, unused)
{
	var e = createTiddlyElement(document.body, "div", null, "zoomer");
	createTiddlyElement(e, "div", null, null, text);
	var winWidth = findWindowWidth();
	var winHeight = findWindowHeight();
	var p = [
		{ style: 'left', start: findPosX(startElement), end: findPosX(targetElement), template: '%0px' },
		{ style: 'top', start: findPosY(startElement), end: findPosY(targetElement), template: '%0px' },
		{ style: 'width', start: Math.min(startElement.scrollWidth, winWidth),
		  end: Math.min(targetElement.scrollWidth, winWidth), template: '%0px', atEnd: 'auto' },
		{ style: 'height', start: Math.min(startElement.scrollHeight, winHeight),
		  end: Math.min(targetElement.scrollHeight, winHeight), template: '%0px', atEnd: 'auto' },
		{ style: 'fontSize', start: 8, end: 24, template: '%0pt' }
	];
	var c = function(element) { jQuery(element).remove() };
	return new Morpher(e, config.animDuration, p, c);
}

//--
//-- Scroller animation
//--

function Scroller(targetElement)
{
	return new Morpher(targetElement, config.animDuration, [{
		style: '-tw-vertScroll', start: findScrollY(), end: ensureVisible(targetElement)
	}]);
}

//--
//-- Slider animation
//--

// deleteMode - "none", "all" [delete target element and it's children], [only] "children" [but not the target element]
function Slider(element, opening, unused, deleteMode)
{
	element.style.overflow = 'hidden';
	// Workaround a Firefox flashing bug
	if(opening) element.style.height = '0px';
	element.style.display = 'block';
	var height = element.scrollHeight;
	var props = [];
	var callback = null;
	if(opening) {
		props.push({ style: 'height', start: 0, end: height, template: '%0px', atEnd: 'auto' });
		props.push({ style: 'opacity', start: 0, end: 1, template: '%0' });
		props.push({ style: 'filter', start: 0, end: 100, template: 'alpha(opacity:%0)' });
	} else {
		props.push({ style: 'height', start: height, end: 0, template: '%0px' });
		props.push({ style: 'display', atEnd: 'none' });
		props.push({ style: 'opacity', start: 1, end: 0, template: '%0' });
		props.push({ style: 'filter', start: 100, end: 0, template: 'alpha(opacity:%0)' });
		switch(deleteMode) {
			case "all":
				callback = function(element, properties) { jQuery(element).remove() };
				break;
			case "children":
				callback = function(element, properties) { jQuery(element).empty() };
				break;
		}
	}
	return new Morpher(element, config.animDuration, props, callback);
}

//--
//-- Popup menu
//--

var Popup = {
	stack: [] // Array of objects with members root: and popup:
};

Popup.create = function(root, elem, className)
{
	var stackPosition = this.find(root, "popup");
	Popup.remove(stackPosition + 1);
	var popup = createTiddlyElement(document.body, elem || "ol", "popup", className || "popup");
	popup.stackPosition = stackPosition;
	Popup.stack.push({ root: root, popup: popup });
	return popup;
};

Popup.onDocumentClick = function(ev)
{
	var e = ev || window.event;
	if(e.eventPhase == undefined)
		Popup.remove();
	else if(e.eventPhase == Event.BUBBLING_PHASE || e.eventPhase == Event.AT_TARGET)
		Popup.remove();
	return true;
};

Popup.show = function(valign, halign, offset)
{
	var curr = Popup.stack[Popup.stack.length - 1];
	this.place(curr.root, curr.popup, valign, halign, offset);
	jQuery(curr.root).addClass("highlight");
	if(config.options.chkAnimate && anim && typeof Scroller == "function")
		anim.startAnimating(new Scroller(curr.popup));
	else
		window.scrollTo(0, ensureVisible(curr.popup));
};

Popup.place = function(root, popup, valign, halign, offset)
{
	if(!offset)
		offset = { x: 0, y: 0 };
	if(popup.stackPosition >= 0 && !valign && !halign) {
		offset.x = offset.x + root.offsetWidth;
	} else {
		offset.x = (halign == "right") ? offset.x + root.offsetWidth : offset.x;
		offset.y = (valign == "top") ? offset.y : offset.y + root.offsetHeight;
	}
	var rootLeft = findPosX(root);
	var rootTop = findPosY(root);
	var popupLeft = rootLeft + offset.x;
	var popupTop = rootTop + offset.y;
	var winWidth = findWindowWidth();
	if(popup.offsetWidth > winWidth * 0.75)
		popup.style.width = winWidth * 0.75 + "px";
	var popupWidth = popup.offsetWidth;
	var scrollWidth = winWidth - document.body.offsetWidth;
	if(popupLeft + popupWidth > winWidth - scrollWidth - 1) {
		if(halign == "right")
			popupLeft = popupLeft - root.offsetWidth - popupWidth;
		else
			popupLeft = winWidth - popupWidth - scrollWidth - 1;
	}
	popup.style.left = popupLeft + "px";
	popup.style.top = popupTop + "px";
	popup.style.display = "block";
};

Popup.find = function(e)
{
	var i, pos = -1;
	for(i = this.stack.length - 1; i >= 0; i--) {
		if(isDescendant(e, this.stack[i].popup))
			pos = i;
	}
	return pos;
};

Popup.remove = function(pos)
{
	if(!pos) pos = 0;
	if(Popup.stack.length > pos) {
		Popup.removeFrom(pos);
	}
};

Popup.removeFrom = function(from)
{
	for(var i = Popup.stack.length - 1; i >= from; i--) {
		var p = Popup.stack[i];
		jQuery(p.root).removeClass("highlight");
		jQuery(p.popup).remove();
	}
	Popup.stack = Popup.stack.slice(0, from);
};

//--
//-- Wizard support
//--

function Wizard(place)
{
	if(place) {
		this.formElem = findRelated(place, "wizard", "className");
		this.bodyElem = findRelated(this.formElem.firstChild, "wizardBody", "className", "nextSibling");
		this.footElem = findRelated(this.formElem.firstChild, "wizardFooter", "className", "nextSibling");
	} else {
		this.formElem = null;
		this.bodyElem = null;
		this.footElem = null;
	}
}

Wizard.prototype.setValue = function(name, value)
{
	jQuery(this.formElem).data(name, value);
};

Wizard.prototype.getValue = function(name)
{
	return this.formElem ? jQuery(this.formElem).data(name) : null;
};

Wizard.prototype.createWizard = function(place, title)
{
	this.formElem = createTiddlyElement(place, "form", null, "wizard");
	createTiddlyElement(this.formElem, "h1", null, "wizard__title", title);
	this.bodyElem = createTiddlyElement(this.formElem, "div", null, "wizardBody");
	this.footElem = createTiddlyElement(this.formElem, "div", null, "wizardFooter");
	return this.formElem;
};

Wizard.prototype.clear = function()
{
	jQuery(this.bodyElem).empty();
};

Wizard.prototype.setButtons = function(buttonInfo, status)
{
	jQuery(this.footElem).empty();
	for(var i = 0; i < buttonInfo.length; i++) {
		createTiddlyButton(this.footElem, buttonInfo[i].caption, buttonInfo[i].tooltip, buttonInfo[i].onClick);
		insertSpacer(this.footElem);
	}
	if(typeof status == "string") {
		createTiddlyElement(this.footElem, "span", null, "status").innerHTML = status;
	}
};

Wizard.prototype.addStep = function(stepTitle, htmlString)
{
	jQuery(this.bodyElem).empty();
	var wrapper = createTiddlyElement(this.bodyElem, "div");
	createTiddlyElement(wrapper, "h2", null, "wizard__subtitle", stepTitle);
	var step = createTiddlyElement(wrapper, "div", null, "wizardStep");
	step.innerHTML = htmlString;
	applyHtmlMacros(step, tiddler);
};

Wizard.prototype.getElement = function(name)
{
	return this.formElem.elements[name];
};

//--
//-- ListView gadget
//--

var ListView = {};

// Create a listview
ListView.create = function(place, listObject, listTemplate, callback, className)
{
	var table = createTiddlyElement(place, "table", null, className || "listView twtable");

	var thead = createTiddlyElement(table, "thead");
	var i, row = createTiddlyElement(thead, "tr");
	for(i = 0; i < listTemplate.columns.length; i++) {
		var columnTemplate = listTemplate.columns[i];
		var cell = createTiddlyElement(row, "th");
		var colType = ListView.columnTypes[columnTemplate.type];
		if(colType && colType.createHeader) {
			colType.createHeader(cell, columnTemplate, i);
			if(columnTemplate.className)
				jQuery(cell).addClass(columnTemplate.className);
		}
	}

	var rc, tbody = createTiddlyElement(table, "tbody");
	for(rc = 0; rc < listObject.length; rc++) {
		var rowObject = listObject[rc];
		row = createTiddlyElement(tbody, "tr");
		for(i = 0; i < listTemplate.rowClasses.length; i++) {
			if(rowObject[listTemplate.rowClasses[i].field])
				jQuery(row).addClass(listTemplate.rowClasses[i].className);
		}
		rowObject.rowElement = row;
		rowObject.colElements = {};
		for(i = 0; i < listTemplate.columns.length; i++) {
			cell = createTiddlyElement(row, "td");
			columnTemplate = listTemplate.columns[i];
			var field = columnTemplate.field;
			colType = ListView.columnTypes[columnTemplate.type];
			if(colType && colType.createItem) {
				colType.createItem(cell, rowObject, field, columnTemplate, i, rc);
				if(columnTemplate.className)
					jQuery(cell).addClass(columnTemplate.className);
			}
			rowObject.colElements[field] = cell;
		}
	}

	if(callback && listTemplate.actions)
		createTiddlyDropDown(place, ListView.getCommandHandler(callback), listTemplate.actions);

	if(callback && listTemplate.buttons) {
		for(i = 0; i < listTemplate.buttons.length; i++) {
			var b = listTemplate.buttons[i];
			if(b && b.name != "") createTiddlyButton(place, b.caption, null,
				ListView.getCommandHandler(callback, b.name, b.allowEmptySelection));
		}
	}
	return table;
};

ListView.getCommandHandler = function(callback, name, allowEmptySelection)
{
	return function(e) {
		var view = findRelated(this, "TABLE", null, "previousSibling");
		var tiddlers = ListView.getSelectedRows(view);
		if(tiddlers.length == 0 && !allowEmptySelection) {
			alert(config.messages.nothingSelected);
		} else {
			if(this.nodeName.toLowerCase() == "select") {
				callback(view, this.value, tiddlers);
				this.selectedIndex = 0;
			} else {
				callback(view, name, tiddlers);
			}
		}
	};
};

// Invoke a callback for each selector checkbox in the listview
ListView.forEachSelector = function(view, callback)
{
	var checkboxes = view.getElementsByTagName("input");
	var i, hadOne = false;
	for(i = 0; i < checkboxes.length; i++) {
		var cb = checkboxes[i];
		var rowName = cb.getAttribute("rowName");
		if(cb.getAttribute("type") != "checkbox" || !rowName) continue;
		callback(cb, rowName);
		hadOne = true;
	}
	return hadOne;
};

ListView.getSelectedRows = function(view)
{
	var rowNames = [];
	ListView.forEachSelector(view, function(e, rowName) {
		if(e.checked) rowNames.push(rowName);
	});
	return rowNames;
};

// describes filling cells of a column of each type, a map of typeName => { createHeader, createItem }
ListView.columnTypes = {};

ListView.columnTypes.String = {
	createHeader: function(place, columnTemplate, col)
	{
		createTiddlyText(place, columnTemplate.title);
	},
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v != undefined)
			createTiddlyText(place, v);
	}
};

ListView.columnTypes.WikiText = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v != undefined)
			wikify(v, place, null, null);
	}
};

ListView.columnTypes.Tiddler = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v != undefined && v.title)
			createTiddlyPopup(place, v.title, config.messages.listView.tiddlerTooltip, v);
	}
};

ListView.columnTypes.Size = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v == undefined) return;
		var i = 0, msg = config.messages.sizeTemplates;
		while(i < msg.length - 1 && v < msg[i].unit)
			i++;
		createTiddlyText(place, msg[i].template.format([Math.round(v / msg[i].unit)]));
	}
};

ListView.columnTypes.Link = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		var c = columnTemplate.text;
		if(v != undefined)
			createExternalLink(place, v, c || v);
	}
};

ListView.columnTypes.Date = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v != undefined)
			createTiddlyText(place, v.formatString(columnTemplate.dateFormat));
	}
};

ListView.columnTypes.StringList = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v == undefined) return;
		for(var i = 0; i < v.length; i++) {
			createTiddlyText(place, v[i]);
			createTiddlyElement(place, "br");
		}
	}
};

ListView.columnTypes.Selector = {
	createHeader: function(place, columnTemplate, col)
	{
		createTiddlyCheckbox(place, null, false, this.onHeaderChange);
	},
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var e = createTiddlyCheckbox(place, null, listObject[field], null);
		e.setAttribute("rowName", listObject[columnTemplate.rowName]);
	},
	onHeaderChange: function(e)
	{
		var state = this.checked;
		var view = findRelated(this, "TABLE");
		if(!view) return;
		ListView.forEachSelector(view, function(e, rowName) {
			e.checked = state;
		});
	}
};

ListView.columnTypes.Tags = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var tags = listObject[field];
		createTiddlyText(place, String.encodeTiddlyLinkList(tags));
	}
};

ListView.columnTypes.Boolean = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		if(listObject[field] == true)
			createTiddlyText(place, columnTemplate.trueText);
		if(listObject[field] == false)
			createTiddlyText(place, columnTemplate.falseText);
	}
};

ListView.columnTypes.TagCheckbox = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var e = createTiddlyCheckbox(place, null, listObject[field], this.onChange);
		e.setAttribute("tiddler", listObject.title);
		e.setAttribute("tag", columnTemplate.tag);
	},
	onChange: function(e)
	{
		var tag = this.getAttribute("tag");
		var tiddler = this.getAttribute("tiddler");
		store.setTiddlerTag(tiddler, this.checked, tag);
	}
};

ListView.columnTypes.TiddlerLink = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place, listObject, field, columnTemplate, col, row)
	{
		var v = listObject[field];
		if(v == undefined) return;
		var link = createTiddlyLink(place, listObject[columnTemplate.tiddlerLink], false, null);
		createTiddlyText(link, listObject[field]);
	}
};

//--
//-- Augmented methods for the JavaScript Array() object
//--

// Find an entry in a given field of the members of an array
Array.prototype.findByField = function(field, value)
{
	for(var i = 0; i < this.length; i++) {
		if(this[i][field] === value) return i;
	}
	return null;
};

// Return whether an entry exists in an array
Array.prototype.contains = function(item)
{
	return this.indexOf(item) != -1;
};

// Return whether one of a list of values exists in an array
Array.prototype.containsAny = function(items)
{
	for(var i = 0; i < items.length; i++) {
		if(this.indexOf(items[i]) != -1)
			return true;
	}
	return false;
};

// Return whether all of a list of values exists in an array
Array.prototype.containsAll = function(items)
{
	for(var i = 0; i < items.length; i++) {
		if(this.indexOf(items[i]) == -1)
			return false;
	}
	return true;
};

// Push a new value into an array only if it is not already present in the array.
// If the optional unique parameter is false, it reverts to a normal push
Array.prototype.pushUnique = function(item, unique)
{
	if(unique === false || this.indexOf(item) == -1) {
		this.push(item);
	}
};

Array.prototype.remove = function(item)
{
	var p = this.indexOf(item);
	if(p != -1) this.splice(p, 1);
};

//--
//-- Augmented methods for the JavaScript String() object
//--

// todo: create functions substituting String augmenting methods, use in the core; deprecate all String augmenting methods

// Trim whitespace from both ends of a string
String.prototype.trim = function()
{
	return this.replace(/^\s*|\s*$/g, "");
};

// Substitute substrings from an array into a format string that includes '%1'-type specifiers
String.prototype.format = function(s)
{
	var substrings = s && s.constructor == Array ? s : arguments;
	var subRegExp = /(?:%(\d+))/mg;
	var currPos = 0;
	var match, r = [];
	while(match = subRegExp.exec(this)) {
		if(!match[1]) continue;
		if(match.index > currPos)
			r.push(this.substring(currPos, match.index));
		r.push(substrings[parseInt(match[1], 10)]);
		currPos = subRegExp.lastIndex;
	}
	if(currPos < this.length)
		r.push(this.substring(currPos, this.length));
	return r.join("");
};

// Escape any special RegExp characters with that character preceded by a backslash
String.prototype.escapeRegExp = function()
{
	return this.replace(/[\-\/\\\^\$\*\+\?\.\(\)\|\[\]\{\}]/g, '\\$&'); // #157
};

// Convert "\" to "\s", newlines to "\n" (and remove carriage returns)
String.prototype.escapeLineBreaks = function()
{
	return this.replace(/\\/mg, "\\s").replace(/\n/mg, "\\n").replace(/\r/mg, "");
};

// Convert "\n" to newlines, "\b" to " ", "\s" to "\" (and remove carriage returns)
String.prototype.unescapeLineBreaks = function()
{
	return this.replace(/\\n/mg, "\n").replace(/\\b/mg, " ").replace(/\\s/mg, "\\").replace(/\r/mg, "");
};

// Convert & to "&amp;", < to "&lt;", > to "&gt;" and " to "&quot;"
String.prototype.htmlEncode = function()
{
	return this.replace(/&/mg, "&amp;").replace(/</mg, "&lt;").replace(/>/mg, "&gt;").replace(/\"/mg, "&quot;");
};

// Convert "&amp;" to &, "&lt;" to <, "&gt;" to > and "&quot;" to "
String.prototype.htmlDecode = function()
{
	return this.replace(/&lt;/mg, "<").replace(/&gt;/mg, ">").replace(/&quot;/mg, "\"").replace(/&amp;/mg, "&");
};

// Parse a space-separated string of name:value parameters
// The result is an array of objects:
//   result[0] = object with a member for each parameter name, value of that member being an array of values
//   result[1..n] = one object for each parameter, with 'name' and 'value' members
String.prototype.parseParams = function(defaultName, defaultValue, allowEval, noNames, cascadeDefaults)
{
	var dblQuote = "(?:\"((?:(?:\\\\\")|[^\"])+)\")";
	var sngQuote = "(?:'((?:(?:\\\\\')|[^'])+)')";
	var dblSquare = "(?:\\[\\[((?:\\s|\\S)*?)\\]\\])";
	var dblBrace = "(?:\\{\\{((?:\\s|\\S)*?)\\}\\})";
	var unQuoted = noNames ? "([^\"'\\s]\\S*)" : "([^\"':\\s][^\\s:]*)";
	var emptyQuote = "((?:\"\")|(?:''))";
	var skipSpace = "(?:\\s*)";
	var token = "(?:" + dblQuote + "|" + sngQuote + "|" + dblSquare + "|" +
		dblBrace + "|" + unQuoted + "|" + emptyQuote + ")";
	var re = noNames ? new RegExp(token, "mg") :
		new RegExp(skipSpace + token + skipSpace + "(?:(\\:)" + skipSpace + token + ")?", "mg");

	var parseToken = function(match, p) {
		// Double quoted
		if(match[p])     return match[p].replace(/\\"/g, '"');
		// Single quoted
		if(match[p + 1]) return match[p + 1].replace(/\\'/g, "'");
		// Double-square-bracket quoted
		if(match[p + 2]) return match[p + 2];
		// Double-brace quoted
		if(match[p + 3]) {
			var value = match[p + 3];
			if(allowEval && config.evaluateMacroParameters != "none") {
				try {
					if(config.evaluateMacroParameters == "restricted") {
						if(window.restrictedEval) value = window.restrictedEval(value);
					} else {
						value = window.eval(value);
					}
				} catch(ex) {
					throw "Unable to evaluate {{" + value + "}}: " + exceptionText(ex);
				}
			}
			return value;
		}
		// Unquoted
		if(match[p + 4]) return match[p + 4];
		// Empty quote
		if(match[p + 5]) return "";
	};

	var summary = {};
	var results = [summary], match;
	while(match = re.exec(this)) {
		// matched bit is like  firstToken  or  firstToken:tokenAfterColon  (like "param":{{evaluated expression}})
		var firstToken = parseToken(match, 1);
		if(noNames) {
			results.push({ name: "", value: firstToken });
			continue;
		}

		var tokenAfterColon = parseToken(match, 8);
		var newItem = {
			name: firstToken,
			value: tokenAfterColon
		};
		if(newItem.value == null) {
			if(defaultName) {
				newItem.value = firstToken;
				newItem.name = defaultName;
			}
			else if(defaultValue) newItem.value = defaultValue;
		}

		results.push(newItem);
		if(cascadeDefaults) {
			defaultName = newItem.name;
			defaultValue = newItem.value;
		}
	}

	for(var i = 1; i < results.length; i++) {
		var name = results[i].name;
		var value = results[i].value;
		if(!summary[name])
			summary[name] = [value];
		else
			summary[name].push(value);
	}
	return results;
};

// Process a string list of macro parameters into an array. Parameters can be quoted with "", '',
// [[]], {{ }} or left unquoted (and therefore space-separated). Double-braces {{}} results in
// an *evaluated* parameter: e.g. {{config.options.txtUserName}} results in the current user's name.
String.prototype.readMacroParams = function(notAllowEval)
{
	var p = this.parseParams("list", null, !notAllowEval, true);
	return p.slice(1).map(function(param) { return param.value });
};

// Process a string list of unique tiddler names into an array. Tiddler names that have spaces in them must be [[bracketed]]
String.prototype.readBracketedList = function(unique)
{
	var p = this.parseParams("list", null, false, true);
	var i, n = [];
	for(i = 1; i < p.length; i++) {
		if(p[i].value)
			n.pushUnique(p[i].value, unique);
	}
	return n;
};

// Get [startIndex, endIndex] of chunk between given startMarker and endMarker inside text, or undefined.
tw.textUtils.getChunkRange = function(text, startMarker, endMarker)
{
	var s = text.indexOf(startMarker);
	if(s == -1) return;
	s += startMarker.length;
	var e = text.indexOf(endMarker, s);
	if(e != -1) return [s, e];
};

// Replace a chunk of a string given start and end markers
tw.textUtils.replaceChunk = function(text, startMarker, endMarker, newValue)
{
	var r = this.getChunkRange(text, startMarker, endMarker);
	return r ? text.substring(0, r[0]) + newValue + text.substring(r[1]) : text;
};


// Static method to bracket a string with double square brackets if it contains a space
String.encodeTiddlyLink = function(title)
{
	return title.indexOf(" ") == -1 ? title : "[[" + title + "]]";
};

// Static method to encodeTiddlyLink for every item in an array and join them with spaces
String.encodeTiddlyLinkList = function(list)
{
	if(!list) return "";
	return list.map(function(item) { return String.encodeTiddlyLink(item) }).join(" ");
};

// Convert a string as a sequence of name:"value" pairs into a hashmap
String.prototype.decodeHashMap = function()
{
	var fields = this.parseParams("anon", "", false);
	var i, hashmap = {};
	for(i = 1; i < fields.length; i++)
		hashmap[fields[i].name] = fields[i].value;
	return hashmap;
};

// Static method to encode a hashmap into a name:"value"... string
String.encodeHashMap = function(hashmap)
{
	var name, r = [];
	for(name in hashmap)
		r.push(name + ':"' + hashmap[name] + '"');
	return r.join(" ");
};

// Static method to left-pad a string with 0s to a certain width
String.zeroPad = function(n, width)
{
	var s = n.toString();
	if(s.length >= width) return s;
	return "000000000000000000000000000".substring(0, width - s.length) + s;
};

String.prototype.startsWith = function(prefix)
{
	return !prefix || this.substring(0, prefix.length) == prefix;
};

// Returns the first value of the given named parameter.
function getParam(params, name, defaultValue)
{
	if(!params) return defaultValue;
	var p = params[0][name];
	return p ? p[0] : defaultValue;
}

// Returns the first value of the given boolean named parameter.
function getFlag(params, name, defaultValue)
{
	return !!getParam(params, name, defaultValue);
}

//--
//-- Augmented methods for the JavaScript Date() object
//--

// Substitute date components into a string
Date.prototype.formatString = function(template)
{
	var tz = this.getTimezoneOffset();
	var atz = Math.abs(tz);
	var t = template
		.replace(/0hh12/g, String.zeroPad(this.getHours12(), 2))
		.replace(/hh12/g, this.getHours12())
		.replace(/0hh/g, String.zeroPad(this.getHours(), 2))
		.replace(/hh/g, this.getHours())
		.replace(/mmm/g, config.messages.dates.shortMonths[this.getMonth()])
		.replace(/0mm/g, String.zeroPad(this.getMinutes(), 2))
		.replace(/mm/g, this.getMinutes())
		.replace(/0ss/g, String.zeroPad(this.getSeconds(), 2))
		.replace(/ss/g, this.getSeconds())
		.replace(/[ap]m/g, this.getAmPm().toLowerCase())
		.replace(/[AP]M/g, this.getAmPm().toUpperCase())
		.replace(/wYYYY/g, this.getYearForWeekNo())
		.replace(/wYY/g, String.zeroPad(this.getYearForWeekNo() - 2000, 2))
		.replace(/YYYY/g, this.getFullYear())
		.replace(/YY/g, String.zeroPad(this.getFullYear() - 2000, 2))
		.replace(/MMM/g, config.messages.dates.months[this.getMonth()])
		.replace(/0MM/g, String.zeroPad(this.getMonth() + 1, 2))
		.replace(/MM/g, this.getMonth() + 1)
		.replace(/0WW/g, String.zeroPad(this.getWeek(), 2))
		.replace(/WW/g, this.getWeek())
		.replace(/DDD/g, config.messages.dates.days[this.getDay()])
		.replace(/ddd/g, config.messages.dates.shortDays[this.getDay()])
		.replace(/0DD/g, String.zeroPad(this.getDate(), 2))
		.replace(/DDth/g, this.getDate() + this.daySuffix())
		.replace(/DD/g, this.getDate())
		.replace(/TZD/g, (tz < 0 ? '+' : '-') + String.zeroPad(Math.floor(atz / 60), 2) +
			':' + String.zeroPad(atz % 60, 2))
		.replace(/\\/g, "");
	return t;
};

Date.prototype.getWeek = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	// JavaScript Sun=0, ISO Sun=7
	if(d == 0) d = 7;
	// shift day to Thurs of same week to calculate weekNo
	dt.setTime(dt.getTime() + (4 - d) * 86400000);
	var n = Math.floor((dt.getTime() - new Date(dt.getFullYear(), 0, 1) + 3600000) / 86400000);
	return Math.floor(n / 7) + 1;
};

Date.prototype.getYearForWeekNo = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	// JavaScript Sun=0, ISO Sun=7
	if(d == 0) d = 7;
	// shift day to Thurs of same week
	dt.setTime(dt.getTime() + (4 - d) * 86400000);
	return dt.getFullYear();
};

Date.prototype.getHours12 = function()
{
	var h = this.getHours();
	return h > 12 ? h - 12 : ( h > 0 ? h : 12 );
};

Date.prototype.getAmPm = function()
{
	return this.getHours() >= 12 ? config.messages.dates.pm : config.messages.dates.am;
};

Date.prototype.daySuffix = function()
{
	return config.messages.dates.daySuffixes[this.getDate() - 1];
};

// Convert to local YYYYMMDDHHMM format string
Date.prototype.convertToLocalYYYYMMDDHHMM = function()
{
	return this.getFullYear() + String.zeroPad(this.getMonth() + 1, 2) + String.zeroPad(this.getDate(), 2) +
		String.zeroPad(this.getHours(), 2) + String.zeroPad(this.getMinutes(), 2);
};

// Convert to UTC YYYYMMDDHHMM format string
Date.prototype.convertToYYYYMMDDHHMM = function()
{
	return this.getUTCFullYear() + String.zeroPad(this.getUTCMonth() + 1, 2) + String.zeroPad(this.getUTCDate(), 2) +
		String.zeroPad(this.getUTCHours(), 2) + String.zeroPad(this.getUTCMinutes(), 2);
};

// Convert to UTC YYYYMMDD.HHMMSSMMM format string
Date.prototype.convertToYYYYMMDDHHMMSSMMM = function()
{
	return this.getUTCFullYear() + String.zeroPad(this.getUTCMonth() + 1, 2) +
		String.zeroPad(this.getUTCDate(), 2) + "." + String.zeroPad(this.getUTCHours(), 2) +
		String.zeroPad(this.getUTCMinutes(), 2) + String.zeroPad(this.getUTCSeconds(), 2) +
		String.zeroPad(this.getUTCMilliseconds(), 3) + "0";
};

// Static. Create a date from a UTC YYYYMMDDHHMM format string
Date.convertFromYYYYMMDDHHMM = function(d)
{
	d = d ? d.replace(/[^0-9]/g, "") : "";
	return Date.convertFromYYYYMMDDHHMMSSMMM(d.substr(0, 12));
};

// Static. Create a date from a UTC YYYYMMDDHHMMSS format string
Date.convertFromYYYYMMDDHHMMSS = function(d)
{
	d = d ? d.replace(/[^0-9]/g, "") : "";
	return Date.convertFromYYYYMMDDHHMMSSMMM(d.substr(0, 14));
};

// Static. Create a date from a UTC YYYYMMDDHHMMSSMMM format string
Date.convertFromYYYYMMDDHHMMSSMMM = function(d)
{
	d = d ? d.replace(/[^0-9]/g, "") : "";
	return new Date(Date.UTC(parseInt(d.substr(0, 4), 10),
		parseInt(d.substr(4, 2), 10) - 1,
		parseInt(d.substr(6, 2), 10),
		parseInt(d.substr(8, 2) || "00", 10),
		parseInt(d.substr(10, 2) || "00", 10),
		parseInt(d.substr(12, 2) || "00", 10),
		parseInt(d.substr(14, 3) || "000", 10)));
};

//--
//-- RGB colour object
//--

// Construct an RGB colour object from a '#rrggbb', '#rgb' or 'rgb(n,n,n)' string or from separate r,g,b values
function RGB(r, g, b)
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	if(typeof r == "string") {
		if(r.substr(0, 1) == "#") {
			if(r.length == 7) {
				this.r = parseInt(r.substr(1, 2), 16) / 255;
				this.g = parseInt(r.substr(3, 2), 16) / 255;
				this.b = parseInt(r.substr(5, 2), 16) / 255;
			} else {
				this.r = parseInt(r.substr(1, 1), 16) / 15;
				this.g = parseInt(r.substr(2, 1), 16) / 15;
				this.b = parseInt(r.substr(3, 1), 16) / 15;
			}
		} else {
			var rgbPattern = /rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/;
			var c = r.match(rgbPattern);
			if(c) {
				this.r = parseInt(c[1], 10) / 255;
				this.g = parseInt(c[2], 10) / 255;
				this.b = parseInt(c[3], 10) / 255;
			}
		}
	} else {
		this.r = r;
		this.g = g;
		this.b = b;
	}
	return this;
}

// Mixes this colour with another in a specified proportion
// c = other colour to mix
// f = 0..1 where 0 is this colour and 1 is the new colour
// Returns an RGB object
RGB.prototype.mix = function(c, f)
{
	return new RGB(this.r + (c.r - this.r) * f, this.g + (c.g - this.g) * f, this.b + (c.b - this.b) * f);
};

// Return an rgb colour as a #rrggbb format hex string
RGB.prototype.toString = function()
{
	var to255Range = function(value) {
		var clamped = value < 0 ? 0 : value > 1 ? 1 : value;
		return clamped * 255;
	};

	var to2DigitString = function(value) {
		var s = Math.floor(value).toString(16);
		return ("0" + s).slice(-2);
	};

	return "#" +
		to2DigitString(to255Range(this.r)) +
		to2DigitString(to255Range(this.g)) +
		to2DigitString(to255Range(this.b));
};

//--
//-- DOM utilities - many derived from www.quirksmode.org
//--

tw.assets.icons.closeSvg =
	'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10" class="tw-icon">' +
	'	<line x1="1" y1="1" x2="9" y2="9" rx="1" ry="1"/>' +
	'	<line x1="9" y1="1" x2="1" y2="9" rx="1" ry="1"/>' +
	'</svg>';

function drawGradient(place, horiz, loColors, hiColors)
{
	if(!hiColors) hiColors = loColors;

	for(var i = 0; i <= 100; i += 2)
	{
		var bar = document.createElement("div");
		place.appendChild(bar);
		bar.style.position = "absolute";
		bar.style.left = horiz ? i + "%" : 0;
		bar.style.top = horiz ? 0 : i + "%";
		bar.style.width = horiz ? (101 - i) + "%" : "100%";
		bar.style.height = horiz ? "100%" : (101 - i) + "%";
		bar.style.zIndex = -1;
		var p = i / 100 * (loColors.length - 1);
		var hc = hiColors[Math.floor(p)];
		if(typeof hc == "string")
			hc = new RGB(hc);
		var lc = loColors[Math.ceil(p)];
		if(typeof lc == "string")
			lc = new RGB(lc);
		bar.style.backgroundColor = hc.mix(lc, p - Math.floor(p)).toString();
	}
}

function addEvent(obj, type, fn)
{
	if(obj.attachEvent) {
		obj["e" + type + fn] = fn;
		obj[type + fn] = function() { obj["e" + type + fn](window.event) };
		obj.attachEvent("on" + type, obj[type + fn]);
	} else {
		obj.addEventListener(type, fn, false);
	}
}

function removeEvent(obj, type, fn)
{
	if(obj.detachEvent) {
		obj.detachEvent("on" + type, obj[type + fn]);
		obj[type + fn] = null;
	} else {
		obj.removeEventListener(type, fn, false);
	}
}

// Find the closest relative with a given property value (property defaults to tagName, relative defaults to parentNode)
function findRelated(e, value, name, relative)
{
	name = name || "tagName";
	relative = relative || "parentNode";
	if(name == "className") {
		while(e && !jQuery(e).hasClass(value)) {
			e = e[relative];
		}
	} else {
		while(e && e[name] != value) {
			e = e[relative];
		}
	}
	return e;
}

// Get the scroll position for window.scrollTo necessary to scroll a given element into view
function ensureVisible(e)
{
	var posTop = findPosY(e);
	var posBot = posTop + e.offsetHeight;
	var winTop = findScrollY();
	var winHeight = findWindowHeight();
	var winBot = winTop + winHeight;
	if(posTop < winTop) {
		return posTop;
	} else if(posBot > winBot) {
		if(e.offsetHeight < winHeight)
			return posTop - (winHeight - e.offsetHeight);
		else
			return posTop;
	} else {
		return winTop;
	}
}

// Get the current width of the display window
function findWindowWidth()
{
	return window.innerWidth || document.documentElement.clientWidth;
}

// Get the current height of the display window
function findWindowHeight()
{
	return window.innerHeight || document.documentElement.clientHeight;
}

// Get the current height of the document
function findDocHeight() {
	var d = document;
	return Math.max(
		Math.max(d.body.scrollHeight, d.documentElement.scrollHeight),
		Math.max(d.body.offsetHeight, d.documentElement.offsetHeight),
		Math.max(d.body.clientHeight, d.documentElement.clientHeight)
	);
}

// Get the current horizontal page scroll position
function findScrollX()
{
	return window.scrollX || document.documentElement.scrollLeft;
}

// Get the current vertical page scroll position
function findScrollY()
{
	return window.scrollY || document.documentElement.scrollTop;
}

function findPosX(obj)
{
	var curleft = 0;
	while(obj.offsetParent) {
		curleft += obj.offsetLeft;
		obj = obj.offsetParent;
	}
	return curleft;
}

function findPosY(obj)
{
	var curtop = 0;
	while(obj.offsetParent) {
		curtop += obj.offsetTop;
		obj = obj.offsetParent;
	}
	return curtop;
}

function blurElement(e)
{
	if(e && e.focus && e.blur) {
		e.focus();
		e.blur();
	}
}

// Create a non-breaking space
function insertSpacer(place)
{
	var e = document.createTextNode(String.fromCharCode(160));
	if(place) place.appendChild(e);
	return e;
}

// Replace the current selection of a textarea or text input and scroll it into view
function replaceSelection(e, text)
{
	if(e.setSelectionRange) {
		var oldpos = e.selectionStart;
		var isRange = e.selectionEnd > e.selectionStart;
		e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd);
		e.setSelectionRange(isRange ? oldpos : oldpos + text.length, oldpos + text.length);
		// scroll into view
		var linecount = e.value.split("\n").length;
		var thisline = e.value.substr(0, e.selectionStart).split("\n").length - 1;
		e.scrollTop = Math.floor((thisline - e.rows / 2) * e.scrollHeight / linecount);
	} else if(document.selection) { // support IE
		var range = document.selection.createRange();
		if(range.parentElement() == e) {
			var isCollapsed = range.text == "";
			range.text = text;
			if(!isCollapsed) {
				range.moveStart("character", -text.length);
				range.select();
			}
		}
	}
}

// Set the caret position in a text area
function setCaretPosition(e, pos)
{
	if(e.selectionStart || e.selectionStart == '0') {
		e.selectionStart = pos;
		e.selectionEnd = pos;
		e.focus();
	} else if(document.selection) { // support IE
		e.focus();
		var sel = document.selection.createRange();
		sel.moveStart('character', -e.value.length);
		sel.moveStart('character', pos);
		sel.moveEnd('character', 0);
		sel.select();
	}
}

// Returns the text of the given (text) node, possibly merging subsequent text nodes
function getNodeText(e)
{
	var text = "";
	while(e && e.nodeName == "#text") {
		text += e.nodeValue;
		e = e.nextSibling;
	}
	return text;
}

// Returns true if the element e has a given ancestor element
function isDescendant(e, ancestor)
{
	while(e) {
		if(e === ancestor)
			return true;
		e = e.parentNode;
	}
	return false;
}


// deprecate the following...

// Prevent an event from bubbling
function stopEvent(e)
{
	var ev = e || window.event;
	ev.cancelBubble = true;
	if(ev.stopPropagation) ev.stopPropagation();
	return false;
}

// Remove any event handlers or non-primitve custom attributes
function scrubNode(e)
{
	if(!config.browser.isIE) return;
	var att = e.attributes;
	if(att) {
		for(var i = 0; i < att.length; i++) {
			var n = att[i].name;
			if(n !== "style" && (typeof e[n] === "function" || (typeof e[n] === "object" && e[n] != null))) {
				try {
					e[n] = null;
				} catch(ex) {
				}
			}
		}
	}
	var c = e.firstChild;
	while(c) {
		scrubNode(c);
		c = c.nextSibling;
	}
}

function setStylesheet(s, id, doc)
{
	jQuery.twStylesheet(s, { id: id, doc: doc });
}

function removeStyleSheet(id)
{
	jQuery.twStylesheet.remove({ id: id });
}

//--
//-- LoaderBase and SaverBase
//--

function LoaderBase() {}

LoaderBase.prototype.loadTiddler = function(store, node, tiddlers)
{
	var title = this.getTitle(store, node);
	if(!title) return;
	if(safeMode && store.isShadowTiddler(title)) return;

	var tiddler = store.createTiddler(title);
	this.internalizeTiddler(store, tiddler, title, node);
	tiddlers.push(tiddler);
};

LoaderBase.prototype.loadTiddlers = function(store, nodes)
{
	var i, tiddlers = [];
	for(i = 0; i < nodes.length; i++) {
		try {
			this.loadTiddler(store, nodes[i], tiddlers);
		} catch(ex) {
			showException(ex, config.messages.tiddlerLoadError.format([this.getTitle(store, nodes[i])]));
		}
	}
	return tiddlers;
};

function SaverBase() {}

SaverBase.prototype.externalize = function(store)
{
	var results = [];
	var i, tiddlers = store.getTiddlers("title");
	for(i = 0; i < tiddlers.length; i++) {
		if(!tiddlers[i].doNotSave())
			results.push(this.externalizeTiddler(store, tiddlers[i]));
	}
	return results.join("\n");
};

//--
//-- TW21Loader (inherits from LoaderBase)
//--

function TW21Loader() {}

TW21Loader.prototype = new LoaderBase();

TW21Loader.prototype.getTitle = function(store, node)
{
	var title = null;
	if(node.getAttribute) {
		title = node.getAttribute("title") || node.getAttribute("tiddler");
	}
	if(!title && node.id) {
		var prefixLen = store.idPrefix.length;
		if(node.id.substr(0, prefixLen) == store.idPrefix)
			title = node.id.substr(prefixLen);
	}
	return title;
};

TW21Loader.prototype.internalizeTiddler = function(store, tiddler, title, node)
{
	var e = node.firstChild;
	var text = null;
	if(node.getAttribute && node.getAttribute("tiddler")) {
		text = getNodeText(e).unescapeLineBreaks();
	} else {
		while(e.nodeName != "PRE" && e.nodeName != "pre") {
			e = e.nextSibling;
		}
		text = e.innerHTML.replace(/\r/mg, "").htmlDecode();
	}
	var creator = node.getAttribute("creator");
	var modifier = node.getAttribute("modifier");
	var c = node.getAttribute("created");
	var m = node.getAttribute("modified");
	var created = c ? Date.convertFromYYYYMMDDHHMMSS(c) : version.date;
	var modified = m ? Date.convertFromYYYYMMDDHHMMSS(m) : created;
	var tags = node.getAttribute("tags");
	var fields = {};
	var i, attrs = node.attributes;
	for(i = attrs.length - 1; i >= 0; i--) {
		var name = attrs[i].name;
		if(attrs[i].specified && !TiddlyWiki.isStandardField(name)) {
			fields[name] = attrs[i].value.unescapeLineBreaks();
		}
	}
	tiddler.assign(title, text, modifier, modified, tags, created, fields, creator);
	return tiddler;
};

//--
//-- TW21Saver (inherits from SaverBase)
//--

function TW21Saver() {}

TW21Saver.prototype = new SaverBase();

TW21Saver.prototype.externalizeTiddler = function(store, tiddler)
{
	try {
		var usePre = config.options.chkUsePreForStorage;
		var created = tiddler.created;
		var modified = tiddler.modified;
		var tags = tiddler.getTags();
		var attributes =
			(tiddler.creator ? ' creator="' + tiddler.creator.htmlEncode() + '"' : "") +
			(tiddler.modifier ? ' modifier="' + tiddler.modifier.htmlEncode() + '"' : "") +
			((usePre && created == version.date) ? "" : ' created="' + created.convertToYYYYMMDDHHMM() + '"') +
			((usePre && modified == created) ? "" : ' modified="' + modified.convertToYYYYMMDDHHMM() + '"') +
			((!usePre || tags) ? ' tags="' + tags.htmlEncode() + '"' : "");
		var extendedAttributes = "";
		store.forEachField(tiddler, function(tiddler, fieldName, value) {
			if(typeof value != "string")
				value = "";
			// don't store fields from the temp namespace
			if(!fieldName.match(/^temp\./))
				extendedAttributes += ' %0="%1"'.format([fieldName, value.escapeLineBreaks().htmlEncode()]);
		}, true);
		return ('<div %0="%1"%2%3>%4</' + 'div>').format([
			usePre ? "title" : "tiddler",
			tiddler.title.htmlEncode(),
			attributes,
			extendedAttributes,
			usePre ? "\n<pre>" + tiddler.text.htmlEncode() + "</pre>\n" : tiddler.text.escapeLineBreaks().htmlEncode()
		]);
	} catch (ex) {
		throw exceptionText(ex, config.messages.tiddlerSaveError.format([tiddler.title]));
	}
};



//]]>
</script>

<script id="jsdeprecatedArea" type="text/javascript">
//<![CDATA[
//--
//-- Deprecated Crypto functions and associated conversion routines.
//-- Use the jQuery.encoding functions directly instead.
//--

// Crypto 'namespace'
function Crypto() {}

// Convert a string to an array of big-endian 32-bit words
Crypto.strToBe32s = function(str)
{
	return jQuery.encoding.strToBe32s(str);
};

// Convert an array of big-endian 32-bit words to a string
Crypto.be32sToStr = function(be)
{
	return jQuery.encoding.be32sToStr(be);
};

// Convert an array of big-endian 32-bit words to a hex string
Crypto.be32sToHex = function(be)
{
	return jQuery.encoding.be32sToHex(be);
};

// Return, in hex, the SHA-1 hash of a string
Crypto.hexSha1Str = function(str)
{
	return jQuery.encoding.digests.hexSha1Str(str);
};

// Return the SHA-1 hash of a string
Crypto.sha1Str = function(str)
{
	return jQuery.encoding.digests.sha1Str(str);
};

// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
Crypto.sha1 = function(x,blen)
{
	return jQuery.encoding.digests.sha1(x,blen);
};

//--
//-- Deprecated code
//--

// @Deprecated: Use createElementAndWikify and this.termRegExp instead
config.formatterHelpers.charFormatHelper = function(w)
{
	w.subWikify(createTiddlyElement(w.output, this.element), this.terminator);
};

// @Deprecated: Use enclosedTextHelper and this.lookaheadRegExp instead
config.formatterHelpers.monospacedByLineHelper = function(w)
{
	var lookaheadRegExp = new RegExp(this.lookahead, "mg");
	lookaheadRegExp.lastIndex = w.matchStart;
	var lookaheadMatch = lookaheadRegExp.exec(w.source);
	if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
		var text = lookaheadMatch[1];
		if(config.browser.isIE) text = text.replace(/\n/g, "\r");
		createTiddlyElement(w.output, "pre", null, null, text);
		w.nextMatch = lookaheadRegExp.lastIndex;
	}
};

// @Deprecated: Use <br> or <br /> instead of <<br>>
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place, "br");
};

// Find an item in an array. If a predicate is provided, use the native Array.find (return the item);
// otherwise (for backwards compatibility) treat the argument as an item to find (return the index or null)
// @Deprecated: Use indexOf instead
Array.prototype.orig_find = Array.prototype.find;
Array.prototype.find = function(itemOrPredicate)
{
	if(itemOrPredicate instanceof Function) return Array.prototype.orig_find.apply(this, arguments);
	var i = this.indexOf(itemOrPredicate);
	return i == -1 ? null : i;
};

// Adds, removes or toggles a particular value within an array
//  value - value to add
//  mode - +1 to add value, -1 to remove value, 0 to toggle it
// @Deprecated: No direct substitution
Array.prototype.setItem = function(value, mode)
{
	var i = this.indexOf(value);
	if(mode == 0) mode = (i == -1) ? +1 : -1;
	if(mode == +1) {
		if(i == -1) this.push(value);
	} else if(mode == -1) {
		if(i != -1) this.splice(i, 1);
	}
};

// For IE up to 8 (https://caniuse.com/?search=indexOf)
if(!Array.prototype.map) {
	Array.prototype.map = function(fn, thisObj)
	{
		var scope = thisObj || window;
		var i, j, a = [];
		for(i = 0, j = this.length; i < j; ++i) {
			a.push(fn.call(scope, this[i], i, this));
		}
		return a;
	};
}

// For IE up to 8 (https://caniuse.com/?search=indexOf)
if(!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(item, from)
	{
		if(!from) from = 0;
		for(var i = from; i < this.length; i++) {
			if(this[i] === item) return i;
		}
		return -1;
	};
}

// Load a tiddler from an HTML DIV. The caller should make sure to later call Tiddler.changed()
// @Deprecated: Use store.getLoader().internalizeTiddler instead
Tiddler.prototype.loadFromDiv = function(divRef, title)
{
	return store.getLoader().internalizeTiddler(store, this, title, divRef);
};

// Format the text for storage in an HTML DIV
// @Deprecated: Use store.getSaver().externalizeTiddler instead.
Tiddler.prototype.saveToDiv = function()
{
	return store.getSaver().externalizeTiddler(store, this);
};

// @Deprecated: Use store.allTiddlersAsHtml() instead
function allTiddlersAsHtml()
{
	return store.allTiddlersAsHtml();
}

// @Deprecated: Use refreshPageTemplate instead
function applyPageTemplate(title)
{
	refreshPageTemplate(title);
}

// @Deprecated: Use story.displayTiddlers instead
function displayTiddlers(srcElement, titles, template, unused1, unused2, animate, unused3)
{
	story.displayTiddlers(srcElement, titles, template, animate);
}

// @Deprecated: Use story.displayTiddler instead
function displayTiddler(srcElement, title, template, unused1, unused2, animate, unused3)
{
	story.displayTiddler(srcElement, title, template, animate);
}

// @Deprecated: Java IO is no longer supported;
// these "empty" versions are only left for the tiny chance of backwards
// compatibility issues and will be removed completely in the future
function javaSaveFile(filePath, content)
{
	return null;
}

function javaLoadFile(filePath)
{
	return null;
}

// @Deprecated: Use functions on right hand side directly instead
var createTiddlerPopup = Popup.create;
var scrollToTiddlerPopup = Popup.show;
var hideTiddlerPopup = Popup.remove;

// @Deprecated: Use right hand side directly instead
var regexpBackSlashEn = new RegExp("\\\\n", "mg");
var regexpBackSlash = new RegExp("\\\\", "mg");
var regexpBackSlashEss = new RegExp("\\\\s", "mg");
var regexpNewLine = new RegExp("\n", "mg");
var regexpCarriageReturn = new RegExp("\r", "mg");

//--
//-- Deprecated FileAdaptor functions
//--

FileAdaptor.loadTiddlyWikiCallback = function(status,context,responseText,url,xhr)
{
	context.status = status;
	if(!status) {
		context.statusText = "Error reading file";
	} else {
		context.adaptor.store = new TiddlyWiki();
		if(!context.adaptor.store.importTiddlyWiki(responseText)) {
			context.statusText = config.messages.invalidFileError.format([url]);
			context.status = false;
		}
	}
	context.complete(context,context.userParams);
};

//--
//-- Deprecated HTTP request code
//-- Use the jQuery ajax functions directly instead
//--

function loadRemoteFile(url,callback,params)
{
	return httpReq("GET",url,callback,params);
}

function doHttp(type,url,data,contentType,username,password,callback,params,headers,allowCache)
{
	return httpReq(type,url,callback,params,headers,data,contentType,username,password,allowCache);
}

//--
//-- Deprecated String functions
//--

// @Deprecated: no direct replacement, since not used in core code
String.prototype.toJSONString = function()
{
	// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
	var m = {
		'\b': '\\b',
		'\f': '\\f',
		'\n': '\\n',
		'\r': '\\r',
		'\t': '\\t',
		'"':  '\\"',
		'\\': '\\\\'
	};
	var replaceFn = function(a, b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
	};
	if(/["\\\x00-\x1f]/.test(this))
		return '"' + this.replace(/([\x00-\x1f\\"])/g, replaceFn) + '"';
	return '"' + this + '"';
};

// @Deprecated: no direct replacement, since not used in core code
String.prototype.right = function(n)
{
	return n < this.length ? this.slice(this.length - n) : this;
};

// @Deprecated: no direct replacement, since not used in core code (see unDash in inlineCssHelper)
// Convert a string from a CSS style property name to a JavaScript style name ("background-color" -> "backgroundColor")
String.prototype.unDash = function()
{
	var i, words = this.split("-");
	for(i = 1; i < words.length; i++)
		words[i] = words[i].substring(0, 1).toUpperCase() + words[i].substring(1);
	return words.join("");
};

// @Deprecated: use tw.textUtils.getChunkRange instead
String.prototype.getChunkRange = function(startMarker, endMarker)
{
	return tw.textUtils.getChunkRange(this, startMarker, endMarker);
};

// @Deprecated: no direct replacement, since not used in core code
// Get a chunk of a string between startMarker and endMarker, or undefined
String.prototype.getChunk = function(startMarker, endMarker)
{
	var r = tw.textUtils.getChunkRange(this, startMarker, endMarker);
	if(r) return this.substring(r[0], r[1]);
};

// @Deprecated: use tw.textUtils.replaceChunk instead
String.prototype.replaceChunk = function(startMarker, endMarker, newValue)
{
	return tw.textUtils.replaceChunk(this, startMarker, endMarker, newValue);
};

//--
//-- Deprecated Tiddler code
//--

// @Deprecated: Use tiddlerToRssItem(tiddler,uri) instead
Tiddler.prototype.toRssItem = function(uri)
{
	return tiddlerToRssItem(this,uri);
};

// @Deprecated: Use "<item>\n" + tiddlerToRssItem(tiddler,uri)  + "\n</item>" instead
Tiddler.prototype.saveToRss = function(uri)
{
	return "<item>\n" + tiddlerToRssItem(this,uri) + "\n</item>";
};

// @Deprecated: Use jQuery.encoding.digests.hexSha1Str instead
Tiddler.prototype.generateFingerprint = function()
{
	return "0x" + Crypto.hexSha1Str(this.text);
};

//--
//-- Deprecated Number functions
//--

// @Deprecated: no direct replacement, since not used in core code
// Clamp a number to a range
Number.prototype.clamp = function(min, max)
{
	var c = this;
	if(c < min) c = min;
	if(c > max) c = max;
	return Number(c);
};

//--
//-- Deprecated utility functions
//-- Use the jQuery functions directly instead
//--

// Remove all children of a node
function removeChildren(e)
{
	jQuery(e).empty();
}

// Remove a node and all its children
function removeNode(e)
{
	jQuery(e).remove();
}

// Return the content of an element as plain text with no formatting
function getPlainText(e)
{
	return jQuery(e).text();
}

function addClass(e, className)
{
	jQuery(e).addClass(className);
}

function removeClass(e, className)
{
	jQuery(e).removeClass(className);
}

function hasClass(e, className)
{
	return jQuery(e).hasClass(className);
}

//--
//-- Deprecated Wikifier code
//--

function wikifyPlain(title,theStore,limit)
{
	if(!theStore)
		theStore = store;
	if(theStore.tiddlerExists(title) || theStore.isShadowTiddler(title)) {
		return wikifyPlainText(theStore.getTiddlerText(title),limit,tiddler);
	} else {
		return "";
	}
}


//]]>
</script>
<script id="jslibArea" type="text/javascript">
//<![CDATA[
/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/(function(e,t){var n,r,i=typeof t,o=e.document,a=e.location,s=e.jQuery,u=e.$,l={},c=[],p="1.9.1",f=c.concat,d=c.push,h=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,b=function(e,t){return new b.fn.init(e,t,r)},x=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^[\],:{}\s]*$/,E=/(?:^|:|,)(?:\s*\[)+/g,S=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,A=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,j=/^-ms-/,D=/-([\da-z])/gi,L=function(e,t){return t.toUpperCase()},H=function(e){(o.addEventListener||"load"===e.type||"complete"===o.readyState)&&(q(),b.ready())},q=function(){o.addEventListener?(o.removeEventListener("DOMContentLoaded",H,!1),e.removeEventListener("load",H,!1)):(o.detachEvent("onreadystatechange",H),e.detachEvent("onload",H))};b.fn=b.prototype={jquery:p,constructor:b,init:function(e,n,r){var i,a;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:o,!0)),C.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(a=o.getElementById(i[2]),a&&a.parentNode){if(a.id!==i[2])return r.find(e);this.length=1,this[0]=a}return this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return h.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(h.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:d,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||b.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(o=arguments[u]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,a=e&&b.isArray(e)?e:[]):a=e&&b.isPlainObject(e)?e:{},s[i]=b.extend(c,a,r)):r!==t&&(s[i]=r));return s},b.extend({noConflict:function(t){return e.$===b&&(e.$=u),t&&e.jQuery===b&&(e.jQuery=s),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?!--b.readyWait:!b.isReady){if(!o.body)return setTimeout(b.ready);b.isReady=!0,e!==!0&&--b.readyWait>0||(n.resolveWith(o,[b]),b.fn.trigger&&b(o).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===b.type(e)},isArray:Array.isArray||function(e){return"array"===b.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==b.type(e)||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!y.call(e,"constructor")&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||y.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=b.trim(n),n&&k.test(n.replace(S,"@").replace(A,"]").replace(E,"")))?Function("return "+n)():(b.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(j,"ms-").replace(D,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:v&&!v.call("\ufeff\u00a0")?function(e){return null==e?"":v.call(e)}:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?b.merge(n,"string"==typeof e?[e]:e):d.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(g)return g.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return f.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),b.isFunction(e)?(r=h.call(arguments,2),i=function(){return e.apply(n||this,r.concat(h.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===b.type(r)){o=!0;for(u in r)b.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,b.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(b(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n)if(n=b.Deferred(),"complete"===o.readyState)setTimeout(b.ready);else if(o.addEventListener)o.addEventListener("DOMContentLoaded",H,!1),e.addEventListener("load",H,!1);else{o.attachEvent("onreadystatechange",H),e.attachEvent("onload",H);var r=!1;try{r=null==e.frameElement&&o.documentElement}catch(i){}r&&r.doScroll&&function a(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(a,50)}q(),b.ready()}}()}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=b(o);var _={};function F(e){var t=_[e]={};return b.each(e.match(w)||[],function(e,n){t[n]=!0}),t}b.Callbacks=function(e){e="string"==typeof e?_[e]||F(e):b.extend({},e);var n,r,i,o,a,s,u=[],l=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=u.length,n=!0;u&&o>a;a++)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,u&&(l?l.length&&c(l.shift()):r?u=[]:p.disable())},p={add:function(){if(u){var t=u.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);"function"===r?e.unique&&p.has(n)||u.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=u.length:r&&(s=t,c(r))}return this},remove:function(){return u&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,u,r))>-1)u.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?b.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],this},disable:function(){return u=l=r=t,this},disabled:function(){return!u},lock:function(){return l=t,r||p.disable(),this},locked:function(){return!l},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!u||i&&!l||(n?l.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,o){var a=o[0],s=b.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=h.call(arguments),r=n.length,i=1!==r||e&&b.isFunction(e.promise)?r:0,o=1===i?e:b.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?h.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,u,l;if(r>1)for(s=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(a(t,l,n)).fail(o.reject).progress(a(t,u,s)):--i;return i||o.resolveWith(l,n),o.promise()}}),b.support=function(){var t,n,r,a,s,u,l,c,p,f,d=o.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*"),r=d.getElementsByTagName("a")[0],!n||!r||!n.length)return{};s=o.createElement("select"),l=s.appendChild(o.createElement("option")),a=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:"t"!==d.className,leadingWhitespace:3===d.firstChild.nodeType,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:"/a"===r.getAttribute("href"),opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==o.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===o.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},a.checked=!0,t.noCloneChecked=a.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!l.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}a=o.createElement("input"),a.setAttribute("value",""),t.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),t.radioValue="t"===a.value,a.setAttribute("checked","t"),a.setAttribute("name","t"),u=o.createDocumentFragment(),u.appendChild(a),t.appendChecked=a.checked,t.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;return d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip,b(function(){var n,r,a,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",u=o.getElementsByTagName("body")[0];u&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",u.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",a=d.getElementsByTagName("td"),a[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===a[0].offsetHeight,a[0].style.display="",a[1].style.display="none",t.reliableHiddenOffsets=p&&0===a[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=4===d.offsetWidth,t.doesNotIncludeMarginInBodyOffset=1!==u.offsetTop,e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(o.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(u.style.zoom=1)),u.removeChild(n),n=d=a=r=null)}),n=s=u=l=r=a=null,t}();var O=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,B=/([A-Z])/g;function P(e,n,r,i){if(b.acceptData(e)){var o,a,s=b.expando,u="string"==typeof n,l=e.nodeType,p=l?b.cache:e,f=l?e[s]:e[s]&&s;if(f&&p[f]&&(i||p[f].data)||!u||r!==t)return f||(l?e[s]=f=c.pop()||b.guid++:f=s),p[f]||(p[f]={},l||(p[f].toJSON=b.noop)),("object"==typeof n||"function"==typeof n)&&(i?p[f]=b.extend(p[f],n):p[f].data=b.extend(p[f].data,n)),o=p[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[b.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[b.camelCase(n)])):a=o,a}}function R(e,t,n){if(b.acceptData(e)){var r,i,o,a=e.nodeType,s=a?b.cache:e,u=a?e[b.expando]:b.expando;if(s[u]){if(t&&(o=n?s[u]:s[u].data)){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in o?t=[t]:(t=b.camelCase(t),t=t in o?[t]:t.split(" "));for(r=0,i=t.length;i>r;r++)delete o[t[r]];if(!(n?$:b.isEmptyObject)(o))return}(n||(delete s[u].data,$(s[u])))&&(a?b.cleanData([e],!0):b.support.deleteExpando||s!=s.window?delete s[u]:s[u]=null)}}}b.extend({cache:{},expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!$(e)},data:function(e,t,n){return P(e,t,n)},removeData:function(e,t){return R(e,t)},_data:function(e,t,n){return P(e,t,n,!0)},_removeData:function(e,t){return R(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,o=this[0],a=0,s=null;if(e===t){if(this.length&&(s=b.data(o),1===o.nodeType&&!b._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>a;a++)i=r[a].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),W(o,i,s[i]));b._data(o,"parsedAttrs",!0)}return s}return"object"==typeof e?this.each(function(){b.data(this,e)}):b.access(this,function(n){return n===t?o?W(o,e,b.data(o,e)):null:(this.each(function(){b.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}});function W(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(B,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:O.test(r)?b.parseJSON(r):r}catch(o){}b.data(e,n,r)}else r=t}return r}function $(e){var t;for(t in e)if(("data"!==t||!b.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}b.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=b._data(e,n),r&&(!i||b.isArray(r)?i=b._data(e,n,b.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t),a=function(){b.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=b.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=b._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var I,z,X=/[\t\r\n]/g,U=/\r/g,V=/^(?:input|select|textarea|button|object)$/i,Y=/^(?:a|area)$/i,J=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,G=/^(?:checked|selected)$/i,Q=b.support.getSetAttribute,K=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=b.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=b(this),u=t,l=e.match(w)||[];while(o=l[a++])u=r?u:!s.hasClass(o),s[u?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=b.isFunction(e),this.each(function(n){var o,a=b(this);1===this.nodeType&&(o=i?e.call(this,n,a.val()):e,null==o?o="":"number"==typeof o?o+="":b.isArray(o)&&(o=b.map(o,function(e){return null==e?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=b.valHooks[o.type]||b.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(U,""):null==n?"":n)}}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;for(;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(b.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&b.nodeName(n.parentNode,"optgroup"))){if(t=b(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var o,a,s,u=e.nodeType;if(e&&3!==u&&8!==u&&2!==u)return typeof e.getAttribute===i?b.prop(e,n,r):(a=1!==u||!b.isXMLDoc(e),a&&(n=n.toLowerCase(),o=b.attrHooks[n]||(J.test(n)?z:I)),r===t?o&&a&&"get"in o&&null!==(s=o.get(e,n))?s:(typeof e.getAttribute!==i&&(s=e.getAttribute(n)),null==s?t:s):null!==r?o&&a&&"set"in o&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r):(b.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=b.propFix[n]||n,J.test(n)?!Q&&G.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&"radio"===t&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!b.isXMLDoc(e),a&&(n=b.propFix[n]||n,o=b.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):V.test(e.nodeName)||Y.test(e.nodeName)&&e.href?0:t}}}}),z={get:function(e,n){var r=b.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?K&&Q?null!=i:G.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}},K&&Q||(b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,n,r){return b.nodeName(e,"input")?(e.defaultValue=n,t):I&&I.set(e,n,r)}}),Q||(I=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:I.get,set:function(e,t,n){I.set(e,""===t?!1:t,n)}},b.each(["width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,n){return b.isArray(n)?e.checked=b.inArray(b(e).val(),n)>=0:t}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}b.event={global:{},add:function(e,n,r,o,a){var s,u,l,c,p,f,d,h,g,m,y,v=b._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=b.guid++),(u=v.events)||(u=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof b===i||e&&b.event.triggered===e.type?t:b.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(w)||[""],l=n.length;while(l--)s=rt.exec(n[l])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),p=b.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=b.event.special[g]||{},d=b.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&b.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=u[g])||(h=u[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),b.event.global[g]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,p,f,d,h,g,m=b.hasData(e)&&b._data(e);if(m&&(c=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(s=rt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=b.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),u=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));u&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||b.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(c)&&(delete m.handle,b._removeData(e,"events"))}},trigger:function(n,r,i,a){var s,u,l,c,p,f,d,h=[i||o],g=y.call(n,"type")?n.type:n,m=y.call(n,"namespace")?n.namespace.split("."):[];if(l=f=i=i||o,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+b.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),u=0>g.indexOf(":")&&"on"+g,n=n[b.expando]?n:new b.Event(g,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:b.makeArray(r,[n]),p=b.event.special[g]||{},a||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!a&&!p.noBubble&&!b.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(l=l.parentNode);l;l=l.parentNode)h.push(l),f=l;f===(i.ownerDocument||o)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((l=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(b._data(l,"events")||{})[n.type]&&b._data(l,"handle"),s&&s.apply(l,r),s=u&&l[u],s&&b.acceptData(l)&&s.apply&&s.apply(l,r)===!1&&n.preventDefault();if(n.type=g,!(a||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===g&&b.nodeName(i,"a")||!b.acceptData(i)||!u||!i[g]||b.isWindow(i))){f=i[u],f&&(i[u]=null),b.event.triggered=g;try{i[g]()}catch(v){}b.event.triggered=t,f&&(i[u]=f)}return n.result}},dispatch:function(e){e=b.event.fix(e);var n,r,i,o,a,s=[],u=h.call(arguments),l=(b._data(this,"events")||{})[e.type]||[],c=b.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=b.event.handlers.call(this,e,l),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,u),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(1===l.nodeType&&(l.disabled!==!0||"click"!==e.type)){for(o=[],a=0;u>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?b(r,this).index(l)>=0:b.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,a=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new b.Event(a),t=r.length;while(t--)n=r[t],e[n]=a[n];return e.target||(e.target=a.srcElement||o),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,a):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,a,s=n.button,u=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||o,a=i.documentElement,r=i.body,e.pageX=n.clientX+(a&&a.scrollLeft||r&&r.scrollLeft||0)-(a&&a.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(a&&a.scrollTop||r&&r.scrollTop||0)-(a&&a.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&u&&(e.relatedTarget=u===e.target?n.toElement:u),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return b.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==o.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===o.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=o.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,n){return this instanceof b.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&b.extend(this,n),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0,t):new b.Event(e,n)},b.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;
return(!i||i!==r&&!b.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){return b.nodeName(this,"form")?!1:(b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return b.nodeName(this,"form")?!1:(b.event.remove(this,"._submit"),t)}}),b.support.changeBubbles||(b.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(b.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)})),!1):(b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return b().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?b.event.trigger(e,n,r,!0):t}}),function(e,t){var n,r,i,o,a,s,u,l,c,p,f,d,h,g,m,y,v,x="sizzle"+-new Date,w=e.document,T={},N=0,C=0,k=it(),E=it(),S=it(),A=typeof t,j=1<<31,D=[],L=D.pop,H=D.push,q=D.slice,M=D.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},_="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=F.replace("w","w#"),B="([*^$|!~]?=)",P="\\["+_+"*("+F+")"+_+"*(?:"+B+_+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+O+")|)|)"+_+"*\\]",R=":("+F+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+P.replace(3,8)+")*)|.*)\\)|)",W=RegExp("^"+_+"+|((?:^|[^\\\\])(?:\\\\.)*)"+_+"+$","g"),$=RegExp("^"+_+"*,"+_+"*"),I=RegExp("^"+_+"*([\\x20\\t\\r\\n\\f>+~])"+_+"*"),z=RegExp(R),X=RegExp("^"+O+"$"),U={ID:RegExp("^#("+F+")"),CLASS:RegExp("^\\.("+F+")"),NAME:RegExp("^\\[name=['\"]?("+F+")['\"]?\\]"),TAG:RegExp("^("+F.replace("w","w*")+")"),ATTR:RegExp("^"+P),PSEUDO:RegExp("^"+R),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+_+"*(even|odd|(([+-]|)(\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\d+)|))"+_+"*\\)|)","i"),needsContext:RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+_+"*((?:-\\d)?\\d*)"+_+"*\\)|)(?=[^-]|$)","i")},V=/[\x20\t\r\n\f]*[+~]/,Y=/^[^{]+\{\s*\[native code/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,G=/^(?:input|select|textarea|button)$/i,Q=/^h\d$/i,K=/'|\\/g,Z=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,et=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{q.call(w.documentElement.childNodes,0)[0].nodeType}catch(nt){q=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}function rt(e){return Y.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[x]=!0,e}function at(e){var t=p.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function st(e,t,n,r){var i,o,a,s,u,l,f,g,m,v;if((t?t.ownerDocument||t:w)!==p&&c(t),t=t||p,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!d&&!r){if(i=J.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&y(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return H.apply(n,q.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&T.getByClassName&&t.getElementsByClassName)return H.apply(n,q.call(t.getElementsByClassName(a),0)),n}if(T.qsa&&!h.test(e)){if(f=!0,g=x,m=t,v=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){l=ft(e),(f=t.getAttribute("id"))?g=f.replace(K,"\\$&"):t.setAttribute("id",g),g="[id='"+g+"'] ",u=l.length;while(u--)l[u]=g+dt(l[u]);m=V.test(e)&&t.parentNode||t,v=l.join(",")}if(v)try{return H.apply(n,q.call(m.querySelectorAll(v),0)),n}catch(b){}finally{f||t.removeAttribute("id")}}}return wt(e.replace(W,"$1"),t,n,r)}a=st.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},c=st.setDocument=function(e){var n=e?e.ownerDocument||e:w;return n!==p&&9===n.nodeType&&n.documentElement?(p=n,f=n.documentElement,d=a(n),T.tagNameNoComments=at(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),T.attributes=at(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),T.getByClassName=at(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),T.getByName=at(function(e){e.id=x+0,e.innerHTML="<a name='"+x+"'></a><div name='"+x+"'></div>",f.insertBefore(e,f.firstChild);var t=n.getElementsByName&&n.getElementsByName(x).length===2+n.getElementsByName(x+0).length;return T.getIdNotName=!n.getElementById(x),f.removeChild(e),t}),i.attrHandle=at(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==A&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},T.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==A&&!d){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==A&&!d){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==A&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==A&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=T.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==A?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.NAME=T.getByName&&function(e,n){return typeof n.getElementsByName!==A?n.getElementsByName(name):t},i.find.CLASS=T.getByClassName&&function(e,n){return typeof n.getElementsByClassName===A||d?t:n.getElementsByClassName(e)},g=[],h=[":focus"],(T.qsa=rt(n.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||h.push("\\["+_+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&h.push("[*^$]="+_+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(T.matchesSelector=rt(m=f.matchesSelector||f.mozMatchesSelector||f.webkitMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){T.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",R)}),h=RegExp(h.join("|")),g=RegExp(g.join("|")),y=rt(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},v=f.compareDocumentPosition?function(e,t){var r;return e===t?(u=!0,0):(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&r||e.parentNode&&11===e.parentNode.nodeType?e===n||y(w,e)?-1:t===n||y(w,t)?1:0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return u=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:0;if(o===a)return ut(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?ut(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},u=!1,[0,0].sort(v),T.detectDuplicates=u,p):p},st.matches=function(e,t){return st(e,null,null,t)},st.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Z,"='$1']"),!(!T.matchesSelector||d||g&&g.test(t)||h.test(t)))try{var n=m.call(e,t);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return st(t,p,null,[e]).length>0},st.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},st.attr=function(e,t){var n;return(e.ownerDocument||e)!==p&&c(e),d||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):d||T.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},st.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},st.uniqueSort=function(e){var t,n=[],r=1,i=0;if(u=!T.detectDuplicates,e.sort(v),u){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e};function ut(e,t){var n=t&&e,r=n&&(~t.sourceIndex||j)-(~e.sourceIndex||j);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ct(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function pt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}o=st.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=st.selectors={cacheLength:50,createPseudo:ot,match:U,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||st.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&st.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&z.test(n)&&(t=ft(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[e+" "];return t||(t=RegExp("(^|"+_+")"+e+"("+_+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==A&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=st.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[x]||(m[x]={}),l=c[e]||[],d=l[0]===N&&l[1],f=l[0]===N&&l[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[N,d,f];break}}else if(v&&(l=(t[x]||(t[x]={}))[e])&&l[0]===N)f=l[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[x]||(p[x]={}))[e]=[N,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||st.error("unsupported pseudo: "+e);return r[x]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=M.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=s(e.replace(W,"$1"));return r[x]?ot(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ot(function(e){return function(t){return st(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:ot(function(e){return X.test(e||"")||st.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=d?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Q.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:pt(function(){return[0]}),last:pt(function(e,t){return[t-1]}),eq:pt(function(e,t,n){return[0>n?n+t:n]}),even:pt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:pt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:pt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:pt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=lt(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=ct(n);function ft(e,t){var n,r,o,a,s,u,l,c=E[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=i.preFilter;while(s){(!n||(r=$.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(o=[])),n=!1,(r=I.exec(s))&&(n=r.shift(),o.push({value:n,type:r[0].replace(W," ")}),s=s.slice(n.length));for(a in i.filter)!(r=U[a].exec(s))||l[a]&&!(r=l[a](r))||(n=r.shift(),o.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?st.error(e):E(e,u).slice(0)}function dt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function ht(e,t,n){var i=t.dir,o=n&&"parentNode"===i,a=C++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,s){var u,l,c,p=N+" "+a;if(s){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[x]||(t[x]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,s)||r,l[1]===!0)return!0}}function gt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var o,a=[],s=0,u=e.length,l=null!=t;for(;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function yt(e,t,n,r,i,o){return r&&!r[x]&&(r=yt(r)),i&&!i[x]&&(i=yt(i,o)),ot(function(o,a,s,u){var l,c,p,f=[],d=[],h=a.length,g=o||xt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:mt(g,f,e,s,u),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,u),r){l=mt(y,d),r(l,[],s,u),c=l.length;while(c--)(p=l[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?M.call(o,p):f[c])>-1&&(o[l]=!(a[l]=p))}}else y=mt(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):H.apply(a,y)})}function vt(e){var t,n,r,o=e.length,a=i.relative[e[0].type],s=a||i.relative[" "],u=a?1:0,c=ht(function(e){return e===t},s,!0),p=ht(function(e){return M.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>u;u++)if(n=i.relative[e[u].type])f=[ht(gt(f),n)];else{if(n=i.filter[e[u].type].apply(null,e[u].matches),n[x]){for(r=++u;o>r;r++)if(i.relative[e[r].type])break;return yt(u>1&&gt(f),u>1&&dt(e.slice(0,u-1)).replace(W,"$1"),n,r>u&&vt(e.slice(u,r)),o>r&&vt(e=e.slice(r)),o>r&&dt(e))}f.push(n)}return gt(f)}function bt(e,t){var n=0,o=t.length>0,a=e.length>0,s=function(s,u,c,f,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,T=l,C=s||a&&i.find.TAG("*",d&&u.parentNode||u),k=N+=null==T?1:Math.random()||.1;for(w&&(l=u!==p&&u,r=n);null!=(h=C[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,u,c)){f.push(h);break}w&&(N=k,r=++n)}o&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,o&&b!==v){g=0;while(m=t[g++])m(x,y,u,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=L.call(f));y=mt(y)}H.apply(f,y),w&&!s&&y.length>0&&v+t.length>1&&st.uniqueSort(f)}return w&&(N=k,l=T),x};return o?ot(s):s}s=st.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=ft(e)),n=t.length;while(n--)o=vt(t[n]),o[x]?r.push(o):i.push(o);o=S(e,bt(i,r))}return o};function xt(e,t,n){var r=0,i=t.length;for(;i>r;r++)st(e,t[r],n);return n}function wt(e,t,n,r){var o,a,u,l,c,p=ft(e);if(!r&&1===p.length){if(a=p[0]=p[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&!d&&i.relative[a[1].type]){if(t=i.find.ID(u.matches[0].replace(et,tt),t)[0],!t)return n;e=e.slice(a.shift().value.length)}o=U.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],i.relative[l=u.type])break;if((c=i.find[l])&&(r=c(u.matches[0].replace(et,tt),V.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=r.length&&dt(a),!e)return H.apply(n,q.call(r,0)),n;break}}}return s(e,p)(r,t,d,n,V.test(e)),n}i.pseudos.nth=i.pseudos.eq;function Tt(){}i.filters=Tt.prototype=i.pseudos,i.setFilters=new Tt,c(),st.attr=b.attr,b.find=st,b.expr=st.selectors,b.expr[":"]=b.expr.pseudos,b.unique=st.uniqueSort,b.text=st.getText,b.isXMLDoc=st.isXML,b.contains=st.contains}(e);var at=/Until$/,st=/^(?:parents|prev(?:Until|All))/,ut=/^.[^:#\[\.,]*$/,lt=b.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return r=this,this.pushStack(b(e).filter(function(){for(t=0;i>t;t++)if(b.contains(r[t],this))return!0}));for(n=[],t=0;i>t;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1))},filter:function(e){return this.pushStack(ft(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?lt.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],a=lt.test(e)||"string"!=typeof e?b(e,t||this.context):0;for(;i>r;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&11!==n.nodeType){if(a?a.index(n)>-1:b.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}}return this.pushStack(o.length>1?b.unique(o):o)},index:function(e){return e?"string"==typeof e?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack;function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return at.test(e)||(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),i=this.length>1&&!ct[e]?b.unique(i):i,this.length>1&&st.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!b(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(t=t||0,b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=b.grep(e,function(e){return 1===e.nodeType});if(ut.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Nt=/^(?:checkbox|radio)$/i,Ct=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(o),Dt=jt.appendChild(o.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;null!=(n=this[r]);r++)(!e||b.filter(e,[n]).length>0)&&(t||1!==n.nodeType||b.cleanData(Ot(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Mt(Ot(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&b.cleanData(Ot(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!b.support.htmlSerialize&&mt.test(e)||!b.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(b.cleanData(Ot(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return t||"string"==typeof e||(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=f.apply([],e);var i,o,a,s,u,l,c=0,p=this.length,d=this,h=p-1,g=e[0],m=b.isFunction(g);if(m||!(1>=p||"string"!=typeof g||b.support.checkClone)&&Ct.test(g))return this.each(function(i){var o=d.eq(i);m&&(e[0]=g.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(p&&(l=b.buildFragment(e,this[0].ownerDocument,!1,this),i=l.firstChild,1===l.childNodes.length&&(l=i),i)){for(n=n&&b.nodeName(i,"tr"),s=b.map(Ot(l,"script"),Ht),a=s.length;p>c;c++)o=l,c!==h&&(o=b.clone(o,!0,!0),a&&b.merge(s,Ot(o,"script"))),r.call(n&&b.nodeName(this[c],"table")?Lt(this[c],"tbody"):this[c],o,c);if(a)for(u=s[s.length-1].ownerDocument,b.map(s,qt),c=0;a>c;c++)o=s[c],kt.test(o.type||"")&&!b._data(o,"globalEval")&&b.contains(u,o)&&(o.src?b.ajax({url:o.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((o.text||o.textContent||o.innerHTML||"").replace(St,"")));l=i=null}return this}});function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function Ht(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Mt(e,t){var n,r=0;for(;null!=(n=e[r]);r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function _t(e,t){if(1===t.nodeType&&b.hasData(e)){var n,r,i,o=b._data(e),a=b._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)b.event.add(t,n,s[n][r])}a.data&&(a.data=b.extend({},a.data))}}function Ft(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Nt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],o=b(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),b(o[r])[t](n),d.apply(i,n.get());return this.pushStack(i)}});function Ot(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||b.nodeName(o,n)?s.push(o):b.merge(s,Ot(o,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],s):s}function Bt(e){Nt.test(e.type)&&(e.defaultChecked=e.checked)}b.extend({clone:function(e,t,n){var r,i,o,a,s,u=b.contains(e.ownerDocument,e);if(b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(b.support.noCloneEvent&&b.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(r=Ot(o),s=Ot(e),a=0;null!=(i=s[a]);++a)r[a]&&Ft(i,r[a]);if(t)if(n)for(s=s||Ot(e),r=r||Ot(o),a=0;null!=(i=s[a]);a++)_t(i,r[a]);else _t(e,o);return r=Ot(o,"script"),r.length>0&&Mt(r,!u&&Ot(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,u,l,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===b.type(o))b.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),u=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[u]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!b.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!b.support.tbody){o="table"!==u||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)b.nodeName(l=o.childNodes[i],"tbody")&&!l.childNodes.length&&o.removeChild(l)
}b.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),b.support.appendChecked||b.grep(Ot(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===b.inArray(o,r))&&(a=b.contains(o.ownerDocument,o),s=Ot(f.appendChild(o),"script"),a&&Mt(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,u=b.expando,l=b.cache,p=b.support.deleteExpando,f=b.event.special;for(;null!=(n=e[s]);s++)if((t||b.acceptData(n))&&(o=n[u],a=o&&l[o])){if(a.events)for(r in a.events)f[r]?b.event.remove(n,r):b.removeEvent(n,r,a.handle);l[o]&&(delete l[o],p?delete n[u]:typeof n.removeAttribute!==i?n.removeAttribute(u):n[u]=null,c.push(o))}}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+x+")(.*)$","i"),Yt=RegExp("^("+x+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+x+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===b.css(e,"display")||!b.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=b._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=b._data(r,"olddisplay",un(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&b._data(r,"olddisplay",i?n:b.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}b.fn.extend({css:function(e,n){return b.access(this,function(e,n,r){var i,o,a={},s=0;if(b.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=b.css(e,n[s],!1,o);return a}return r!==t?b.style(e,n,r):b.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:nn(this))?b(this).show():b(this).hide()})}}),b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":b.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,u=b.camelCase(n),l=e.style;if(n=b.cssProps[u]||(b.cssProps[u]=tn(l,u)),s=b.cssHooks[n]||b.cssHooks[u],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:l[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(b.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||b.cssNumber[u]||(r+="px"),b.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{l[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,u=b.camelCase(n);return n=b.cssProps[u]||(b.cssProps[u]=tn(e.style,u)),s=b.cssHooks[n]||b.cssHooks[u],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||b.isNumeric(o)?o||0:a):a},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s.getPropertyValue(n)||s[n]:t,l=e.style;return s&&(""!==u||b.contains(e.ownerDocument,e)||(u=b.style(e,n)),Yt.test(u)&&Ut.test(n)&&(i=l.width,o=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=u,u=s.width,l.width=i,l.minWidth=o,l.maxWidth=a)),u}):o.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s[n]:t,l=e.style;return null==u&&l&&l[n]&&(u=l[n]),Yt.test(u)&&!zt.test(n)&&(i=l.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),l.left="fontSize"===n?"1em":u,u=l.pixelLeft+"px",l.left=i,a&&(o.left=a)),""===u?"auto":u});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=b.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=b.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=b.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=b.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=b.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(b.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function un(e){var t=o,n=Gt[e];return n||(n=ln(e,t),"none"!==n&&n||(Pt=(Pt||b("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=ln(e,t),Pt.detach()),Gt[e]=n),n}function ln(e,t){var n=b(t.createElement(e)).appendTo(t.body),r=b.css(n[0],"display");return n.remove(),r}b.each(["height","width"],function(e,n){b.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(b.css(e,"display"))?b.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,i),i):0)}}}),b.support.opacity||(b.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=b.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===b.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),b(function(){b.support.reliableMarginRight||(b.cssHooks.marginRight={get:function(e,n){return n?b.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!b.support.pixelPosition&&b.fn.position&&b.each(["top","left"],function(e,n){b.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?b(e).position()[n]+"px":r):t}}})}),b.expr&&b.expr.filters&&(b.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!b.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||b.css(e,"display"))},b.expr.filters.visible=function(e){return!b.expr.filters.hidden(e)}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(b.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Nt.test(e))}).map(function(e,t){var n=b(this).val();return null==n?null:b.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),b.param=function(e,n){var r,i=[],o=function(e,t){t=b.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=b.ajaxSettings&&b.ajaxSettings.traditional),b.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(b.isArray(t))b.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==b.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.hover=function(e,t){return this.mouseenter(e).mouseleave(t||e)};var mn,yn,vn=b.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Nn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Cn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=b.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=a.href}catch(Ln){yn=o.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(b.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(u){var l;return o[u]=!0,b.each(e[u]||[],function(e,u){var c=u(n,r,i);return"string"!=typeof c||a||o[c]?a?!(l=c):t:(n.dataTypes.unshift(c),s(c),!1)}),l}return s(n.dataTypes[0])||!o["*"]&&s("*")}function Mn(e,n){var r,i,o=b.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&b.extend(!0,e,r),e}b.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,u=e.indexOf(" ");return u>=0&&(i=e.slice(u,e.length),e=e.slice(0,u)),b.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&b.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?b("<div>").append(b.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.each(["get","post"],function(e,n){b[n]=function(e,r,i,o){return b.isFunction(r)&&(o=o||i,i=r,r=t),b.ajax({url:e,type:n,dataType:o,data:r,success:i})}}),b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Nn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":b.parseJSON,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Mn(Mn(e,b.ajaxSettings),t):Mn(b.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,u,l,c,p=b.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?b(f):b.event,h=b.Deferred(),g=b.Callbacks("once memory"),m=p.statusCode||{},y={},v={},x=0,T="canceled",N={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return x||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)m[t]=[m[t],e[t]];else N.always(e[N.status]);return this},abort:function(e){var t=e||T;return l&&l.abort(t),k(0,t),this}};if(h.promise(N).complete=g.add,N.success=N.done,N.error=N.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=b.trim(p.dataType||"*").toLowerCase().match(w)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?80:443))==(mn[3]||("http:"===mn[1]?80:443)))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=b.param(p.data,p.traditional)),qn(An,p,n,N),2===x)return N;u=p.global,u&&0===b.active++&&b.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Cn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(b.lastModified[o]&&N.setRequestHeader("If-Modified-Since",b.lastModified[o]),b.etag[o]&&N.setRequestHeader("If-None-Match",b.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&N.setRequestHeader("Content-Type",p.contentType),N.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)N.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,N,p)===!1||2===x))return N.abort();T="abort";for(i in{success:1,error:1,complete:1})N[i](p[i]);if(l=qn(jn,p,n,N)){N.readyState=1,u&&d.trigger("ajaxSend",[N,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){N.abort("timeout")},p.timeout));try{x=1,l.send(y,k)}catch(C){if(!(2>x))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,C=n;2!==x&&(x=2,s&&clearTimeout(s),l=t,a=i||"",N.readyState=e>0?4:0,r&&(w=_n(p,N,r)),e>=200&&300>e||304===e?(p.ifModified&&(T=N.getResponseHeader("Last-Modified"),T&&(b.lastModified[o]=T),T=N.getResponseHeader("etag"),T&&(b.etag[o]=T)),204===e?(c=!0,C="nocontent"):304===e?(c=!0,C="notmodified"):(c=Fn(p,w),C=c.state,y=c.data,v=c.error,c=!v)):(v=C,(e||!C)&&(C="error",0>e&&(e=0))),N.status=e,N.statusText=(n||C)+"",c?h.resolveWith(f,[y,C,N]):h.rejectWith(f,[N,C,v]),N.statusCode(m),m=t,u&&d.trigger(c?"ajaxSuccess":"ajaxError",[N,p,c?y:v]),g.fireWith(f,[N,C]),u&&(d.trigger("ajaxComplete",[N,p]),--b.active||b.event.trigger("ajaxStop")))}return N},getScript:function(e,n){return b.get(e,t,n,"script")},getJSON:function(e,t,n){return b.get(e,t,n,"json")}});function _n(e,n,r){var i,o,a,s,u=e.contents,l=e.dataTypes,c=e.responseFields;for(s in c)s in r&&(n[c[s]]=r[s]);while("*"===l[0])l.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in u)if(u[s]&&u[s].test(o)){l.unshift(s);break}if(l[0]in r)a=l[0];else{for(s in r){if(!l[0]||e.converters[s+" "+l[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==l[0]&&l.unshift(a),r[a]):t}function Fn(e,t){var n,r,i,o,a={},s=0,u=e.dataTypes.slice(),l=u[0];if(e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u[1])for(i in e.converters)a[i.toLowerCase()]=e.converters[i];for(;r=u[++s];)if("*"!==r){if("*"!==l&&l!==r){if(i=a[l+" "+r]||a["* "+r],!i)for(n in a)if(o=n.split(" "),o[1]===r&&(i=a[l+" "+o[0]]||a["* "+o[0]])){i===!0?i=a[n]:a[n]!==!0&&(r=o[0],u.splice(s--,0,r));break}if(i!==!0)if(i&&e["throws"])t=i(t);else try{t=i(t)}catch(c){return{state:"parsererror",error:i?c:"No conversion from "+l+" to "+r}}}l=r}return{state:"success",data:t}}b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),b.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=o.head||b("head")[0]||o.documentElement;return{send:function(t,i){n=o.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var On=[],Bn=/(=)\?(?=&|$)|\?\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=On.pop()||b.expando+"_"+vn++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,u=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return u||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=b.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,u?n[u]=n[u].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||b.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,On.push(o)),s&&b.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}b.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=b.ajaxSettings.xhr(),b.support.cors=!!Rn&&"withCredentials"in Rn,Rn=b.support.ajax=!!Rn,Rn&&b.ajaxTransport(function(n){if(!n.crossDomain||b.support.cors){var r;return{send:function(i,o){var a,s,u=n.xhr();if(n.username?u.open(n.type,n.url,n.async,n.username,n.password):u.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)u[s]=n.xhrFields[s];n.mimeType&&u.overrideMimeType&&u.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)u.setRequestHeader(s,i[s])}catch(l){}u.send(n.hasContent&&n.data||null),r=function(e,i){var s,l,c,p;try{if(r&&(i||4===u.readyState))if(r=t,a&&(u.onreadystatechange=b.noop,$n&&delete Pn[a]),i)4!==u.readyState&&u.abort();else{p={},s=u.status,l=u.getAllResponseHeaders(),"string"==typeof u.responseText&&(p.text=u.responseText);try{c=u.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,l)},n.async?4===u.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},b(e).unload($n)),Pn[a]=r),u.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+x+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=Yn.exec(t),a=i.cur(),s=+a||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(b.cssNumber[e]?"":"px"),"px"!==r&&s){s=b.css(i.elem,e,!0)||n||1;do u=u||".5",s/=u,b.style(i.elem,e,s+r);while(u!==(u=i.cur()/a)&&1!==u&&--l)}i.unit=r,i.start=s,i.end=o[1]?s+(o[1]+1)*n:n}return i}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=b.now()}function Zn(e,t){b.each(t,function(t,n){var r=(Qn[t]||[]).concat(Qn["*"]),i=0,o=r.length;for(;o>i;i++)if(r[i].call(e,t,n))return})}function er(e,t,n){var r,i,o=0,a=Gn.length,s=b.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;for(;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?s.resolveWith(e,[l,t]):s.rejectWith(e,[l,t]),this}}),c=l.props;for(tr(c,l.opts.specialEasing);a>o;o++)if(r=Gn[o].call(l,e,c,l.opts))return r;return Zn(l,c),b.isFunction(l.opts.start)&&l.opts.start.call(e,l),b.fx.timer(b.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function tr(e,t){var n,r,i,o,a;for(i in e)if(r=b.camelCase(i),o=t[r],n=e[i],b.isArray(n)&&(o=n[1],n=e[i]=n[0]),i!==r&&(e[r]=n,delete e[i]),a=b.cssHooks[r],a&&"expand"in a){n=a.expand(n),delete e[r];for(i in n)i in e||(e[i]=n[i],t[i]=o)}else t[r]=o}b.Animation=b.extend(er,{tweener:function(e,t){b.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,u,l,c,p,f=this,d=e.style,h={},g=[],m=e.nodeType&&nn(e);n.queue||(c=b._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,p=c.empty.fire,c.empty.fire=function(){c.unqueued||p()}),c.unqueued++,f.always(function(){f.always(function(){c.unqueued--,b.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],"inline"===b.css(e,"display")&&"none"===b.css(e,"float")&&(b.support.inlineBlockNeedsLayout&&"inline"!==un(e.nodeName)?d.zoom=1:d.display="inline-block")),n.overflow&&(d.overflow="hidden",b.support.shrinkWrapBlocks||f.always(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(i in t)if(a=t[i],Vn.exec(a)){if(delete t[i],u=u||"toggle"===a,a===(m?"hide":"show"))continue;g.push(i)}if(o=g.length){s=b._data(e,"fxshow")||b._data(e,"fxshow",{}),"hidden"in s&&(m=s.hidden),u&&(s.hidden=!m),m?b(e).show():f.done(function(){b(e).hide()}),f.done(function(){var t;b._removeData(e,"fxshow");for(t in h)b.style(e,t,h[t])});for(i=0;o>i;i++)r=g[i],l=f.createTween(r,m?s[r]:0),h[r]=s[r]||b.style(e,r),r in s||(s[r]=l.start,m&&(l.end=l.start,l.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}b.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(b.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=b.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[b.cssProps[e.prop]]||b.cssHooks[e.prop])?b.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),o=b.speed(t,n,r),a=function(){var t=er(this,b.extend({},e),o);a.finish=function(){t.stop(!0)},(i||b._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=b.timers,a=b._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&b.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=b._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=b.timers,a=r?r.length:0;for(n.finish=!0,b.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}b.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.speed=function(e,t,n){var r=e&&"object"==typeof e?b.extend({},e):{complete:n||!n&&t||b.isFunction(e)&&e,duration:e,easing:n&&t||t&&!b.isFunction(t)&&t};return r.duration=b.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in b.fx.speeds?b.fx.speeds[r.duration]:b.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){b.isFunction(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},b.timers=[],b.fx=rr.prototype.init,b.fx.tick=function(){var e,n=b.timers,r=0;for(Xn=b.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||b.fx.stop(),Xn=t},b.fx.timer=function(e){e()&&b.timers.push(e)&&b.fx.start()},b.fx.interval=13,b.fx.start=function(){Un||(Un=setInterval(b.fx.tick,b.fx.interval))},b.fx.stop=function(){clearInterval(Un),Un=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fx.step={},b.expr&&b.expr.filters&&(b.expr.filters.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length}),b.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){b.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,b.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},b.offset={setOffset:function(e,t,n){var r=b.css(e,"position");"static"===r&&(e.style.position="relative");var i=b(e),o=i.offset(),a=b.css(e,"top"),s=b.css(e,"left"),u=("absolute"===r||"fixed"===r)&&b.inArray("auto",[a,s])>-1,l={},c={},p,f;u?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),b.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(l.top=t.top-o.top+p),null!=t.left&&(l.left=t.left-o.left+f),"using"in t?t.using.call(e,l):i.css(l)}},b.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===b.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),b.nodeName(e[0],"html")||(n=e.offset()),n.top+=b.css(e[0],"borderTopWidth",!0),n.left+=b.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-b.css(r,"marginTop",!0),left:t.left-n.left-b.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||o.documentElement;while(e&&!b.nodeName(e,"html")&&"static"===b.css(e,"position"))e=e.offsetParent;return e||o.documentElement})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);b.fn[e]=function(i){return b.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?b(a).scrollLeft():o,r?o:b(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return b.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}b.each({Height:"height",Width:"width"},function(e,n){b.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){b.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return b.access(this,function(n,r,i){var o;return b.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?b.css(n,r,s):b.style(n,r,i,s)},n,a?i:t,a,null)}})}),e.jQuery=e.$=b,"function"==typeof define&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return b})})(window);
//]]>
</script>
<script id="jqueryArea" type="text/javascript">
//<![CDATA[
/*
jQuery.encoding.digests.sha1.js

SHA-1 digest and associated utility functions

Copyright (c) UnaMesa Association 2009

Dual licensed under the MIT and GPL licenses:
  http://www.opensource.org/licenses/mit-license.php
  http://www.gnu.org/licenses/gpl.html
*/

(function($) {

if(!$.encoding)
	$.encoding = {};
	$.extend($.encoding,{
		strToBe32s: function(str) {
			// Convert a string to an array of big-endian 32-bit words
			var be=[];
			var len=Math.floor(str.length/4);
			var i, j;
			for(i=0, j=0; i<len; i++, j+=4) {
				be[i]=((str.charCodeAt(j)&0xff) << 24)|((str.charCodeAt(j+1)&0xff) << 16)|((str.charCodeAt(j+2)&0xff) << 8)|(str.charCodeAt(j+3)&0xff);
			}
			while(j<str.length) {
				be[j>>2] |= (str.charCodeAt(j)&0xff)<<(24-(j*8)%32);
				j++;
			}
			return be;
		},
		be32sToStr: function(be) {
			// Convert an array of big-endian 32-bit words to a string
			var str='';
			for(var i=0;i<be.length*32;i+=8) {
				str += String.fromCharCode((be[i>>5]>>>(24-i%32)) & 0xff);
			}
			return str;
		},
		be32sToHex: function(be) {
			// Convert an array of big-endian 32-bit words to a hex string
			var hex='0123456789ABCDEF';
			var str='';
			for(var i=0;i<be.length*4;i++) {
				str += hex.charAt((be[i>>2]>>((3-i%4)*8+4))&0xF) + hex.charAt((be[i>>2]>>((3-i%4)*8))&0xF);
			}
			return str;
		}
	});
})(jQuery);


(function($) {

if(!$.encoding.digests)
	$.encoding.digests = {};
	$.extend($.encoding.digests,{
		hexSha1Str: function(str) {
			// Return, in hex, the SHA-1 hash of a string
			return $.encoding.be32sToHex($.encoding.digests.sha1Str(str));
		},
		sha1Str: function(str) {
			// Return the SHA-1 hash of a string
			return sha1($.encoding.strToBe32s(str),str.length);
		},
		sha1: function(x,blen) {
			// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
			return sha1($.encoding.strToBe32s(str),str.length);
		}
	});

	// Private functions.
	function sha1(x,blen) {
		// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
		function add32(a,b) {
			// Add 32-bit integers, wrapping at 32 bits
			// Uses 16-bit operations internally to work around bugs in some JavaScript interpreters.
			var lsw=(a&0xFFFF)+(b&0xFFFF);
			var msw=(a>>16)+(b>>16)+(lsw>>16);
			return (msw<<16)|(lsw&0xFFFF);
		}
		function AA(a,b,c,d,e) {
			// Cryptographic round helper function. Add five 32-bit integers, wrapping at 32 bits, second parameter is rotated left 5 bits before the addition
			// Uses 16-bit operations internally to work around bugs in some JavaScript interpreters.
			b=(b>>>27)|(b<<5);
			var lsw=(a&0xFFFF)+(b&0xFFFF)+(c&0xFFFF)+(d&0xFFFF)+(e&0xFFFF);
			var msw=(a>>16)+(b>>16)+(c>>16)+(d>>16)+(e>>16)+(lsw>>16);
			return (msw<<16)|(lsw&0xFFFF);
		}
		function RR(w,j) {
			// Cryptographic round helper function.
			var n=w[j-3]^w[j-8]^w[j-14]^w[j-16];
			return (n>>>31)|(n<<1);
		}

		var len=blen*8;
		x[len>>5] |= 0x80 << (24-len%32);
		x[((len+64>>9)<<4)+15]=len;
		var w=new Array(80);

		var k1=0x5A827999;
		var k2=0x6ED9EBA1;
		var k3=0x8F1BBCDC;
		var k4=0xCA62C1D6;

		var h0=0x67452301;
		var h1=0xEFCDAB89;
		var h2=0x98BADCFE;
		var h3=0x10325476;
		var h4=0xC3D2E1F0;

		for(var i=0;i<x.length;i+=16) {
			var j=0;
			var t;
			var a=h0;
			var b=h1;
			var c=h2;
			var d=h3;
			var e=h4;
			while(j<16) {
				w[j]=x[i+j];
				t=AA(e,a,d^(b&(c^d)),w[j],k1);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<20) {
				w[j]=RR(w,j);
				t=AA(e,a,d^(b&(c^d)),w[j],k1);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<40) {
				w[j]=RR(w,j);
				t=AA(e,a,b^c^d,w[j],k2);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<60) {
				w[j]=RR(w,j);
				t=AA(e,a,(b&c)|(d&(b|c)),w[j],k3);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<80) {
				w[j]=RR(w,j);
				t=AA(e,a,b^c^d,w[j],k4);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			h0=add32(h0,a);
			h1=add32(h1,b);
			h2=add32(h2,c);
			h3=add32(h3,d);
			h4=add32(h4,e);
		}
		return [h0,h1,h2,h3,h4];
	}
})(jQuery);
/*
jQuery.twStylesheet.js

jQuery plugin to dynamically insert CSS rules into a document

Usage:
  jQuery.twStylesheet applies style definitions
  jQuery.twStylesheet.remove neutralizes style definitions

Copyright (c) UnaMesa Association 2009

Triple licensed under the BSD, MIT and GPL licenses:
  http://www.opensource.org/licenses/bsd-license.php
  http://www.opensource.org/licenses/mit-license.php
  http://www.gnu.org/licenses/gpl.html
*/

(function($) {

var defaultId = "customStyleSheet"; // XXX: rename to dynamicStyleSheet?

// Add or replace a style sheet
// css argument is a string of CSS rule sets
// options.id is an optional name identifying the style sheet
// options.doc is an optional document reference
// N.B.: Uses DOM methods instead of jQuery to ensure cross-browser comaptibility.
$.twStylesheet = function(css, options) {
	options = options || {};
	var id = options.id || defaultId;
	var doc = options.doc || document;
	var el = doc.getElementById(id);
	if(doc.createStyleSheet) { // IE-specific handling
		if(el) {
			el.parentNode.removeChild(el);
		}
		doc.getElementsByTagName("head")[0].insertAdjacentHTML("beforeEnd",
			'&nbsp;<style id="' + id + '" type="text/css">' + css + '</style>'); // fails without &nbsp;
	} else { // modern browsers
		if(el) {
			el.replaceChild(doc.createTextNode(css), el.firstChild);
		} else {
			el = doc.createElement("style");
			el.type = "text/css";
			el.id = id;
			el.appendChild(doc.createTextNode(css));
			doc.getElementsByTagName("head")[0].appendChild(el);
		}
	}
};

// Remove existing style sheet
// options.id is an optional name identifying the style sheet
// options.doc is an optional document reference
$.twStylesheet.remove = function(options) {
	options = options || {};
	var id = options.id || defaultId;
	var doc = options.doc || document;
	var el = doc.getElementById(id);
	if(el) {
		el.parentNode.removeChild(el);
	}
};

})(jQuery);

//]]>
</script>
<script type="text/javascript">
//<![CDATA[
if(useJavaSaver)
	document.write("<applet style='position:absolute;left:-1px' name='TiddlySaver' code='TiddlySaver.class' archive='TiddlySaver.jar' width='1' height='1'></applet>");
//]]>
</script>
<!--POST-SCRIPT-START-->
<!--POST-SCRIPT-END-->
</body>
</html>
